[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Avanzado",
    "section": "",
    "text": "Bienvenida\nEste es el sitio web de la segunda edición de “R Avanzado”, un libro de la Serie R de Chapman & Hall. El libro está diseñado principalmente para usuarios de R que desean mejorar sus habilidades de programación y comprensión del lenguaje. También debería ser útil para los programadores que llegan a R desde otros lenguajes, ya que les ayuda a comprender por qué R funciona de la forma en que lo hace.\nSi está buscando la primera edición, puede encontrarla en http://adv-r.had.co.nz/.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "R Avanzado",
    "section": "Licencia",
    "text": "Licencia\n\nEste trabajo, en su conjunto, está licenciado bajo la licencia Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\nEl código contenido en este libro está disponible simultáneamente bajo la licencia MIT; esto significa que puede usarlo en sus propios paquetes, siempre que cite la fuente.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#otros-libros",
    "href": "index.html#otros-libros",
    "title": "R Avanzado",
    "section": "Otros libros",
    "text": "Otros libros\nUsted también podría estar interesado en:\n\n“Advanced R Solutions” de Malte Grosser y Henning Bumann, proporciona soluciones elaboradas para los ejercicios de este libro.\n“R para ciencia de datos” que le presenta R como una herramienta para hacer ciencia de datos, centrándose en un conjunto consistente de paquetes conocido como tidyverse.\n“R Packages” que le enseña cómo aprovechar al máximo el fantástico sistema de paquetes de R.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "Preface.html",
    "href": "Preface.html",
    "title": "Prefacio",
    "section": "",
    "text": "Bienvenido a la segunda edición de R Avanzado. Tenía tres objetivos principales para esta edición:\n\nMejorar la cobertura de conceptos importantes que entendí completamente solo después de la publicación de la primera edición.\nReducir el tiempo de cobertura de temas que han demostrado ser menos útiles, o que creo que son realmente apasionantes pero resultan no ser tan prácticos.\nEn general, hacer que el material sea más fácil de entender con un mejor texto, un código más claro y muchos más diagramas.\n\nSi está familiarizado con la primera edición, este prefacio describe los principales cambios para que pueda enfocar su lectura en las nuevas áreas. Si está leyendo una versión impresa de este libro, notará un gran cambio muy rápidamente: ¡R Avanzado ahora está en color! Esto ha mejorado considerablemente el resaltado de sintaxis de los fragmentos de código y ha facilitado mucho la creación de diagramas útiles. Aproveché esto e incluí más de 100 diagramas nuevos en todo el libro.\nOtro gran cambio en esta versión es el uso de nuevos paquetes, particularmente rlang, que proporciona una interfaz limpia para operaciones y estructuras de datos de bajo nivel. La primera edición usó funciones base R casi exclusivamente, lo que creó algunos desafíos pedagógicos porque muchas funciones evolucionaron de forma independiente durante varios años, lo que dificulta ver las grandes ideas subyacentes ocultas entre las variaciones incidentales en los nombres y argumentos de las funciones. Continúo mostrando los equivalentes base en las barras laterales, notas al pie y, cuando sea necesario, en secciones individuales, pero si desea ver la expresión R base más pura de las ideas de este libro, le recomiendo leer la primera edición, que puede encontrar en línea en http://adv-r.had.co.nz.\nLos fundamentos de R no han cambiado en los cinco años desde la primera edición, pero mi comprensión de ellos ciertamente sí. Por lo tanto, la estructura general de “Fundamentos” se ha mantenido más o menos igual, pero muchos de los capítulos individuales se han mejorado considerablemente:\n\nCapítulo 2  Nombres y valores, “Nombres y valores”, es un capítulo completamente nuevo que lo ayuda a comprender la diferencia entre objetos y nombres de objetos. Esto lo ayuda a predecir con mayor precisión cuándo R hará una copia de una estructura de datos y sienta las bases importantes para comprender la programación funcional.\nCapítulo 3  Vectores, “Vectores” (anteriormente denominadas estructuras de datos), se ha reescrito para centrarse en tipos de vectores como números enteros, factores y marcos de datos. Contiene más detalles de vectores S3 importantes (como fechas y fechas-horas), analiza la variación del marco de datos proporcionado por el paquete tibble (Müller y Wickham 2018) y, en general, refleja mi comprensión mejorada de los tipos de datos vectoriales.\nCapítulo 4  Subconjunto, “Subconjunto”, ahora distingue entre [ y [[ por su intención: [ extrae muchos valores y [[ extrae un solo valor (anteriormente se caracterizaban por si “simplificaban” o “conservaban”). La sección 4.3 Selección de un solo elemento dibuja el “tren” para ayudarlo a comprender cómo funciona [[ con listas e introduce nuevas funciones que brindan un comportamiento más consistente para índices fuera de los límites.\nCapítulo 5  Flujo de control, “Flujo de control”, es un nuevo capítulo: de alguna manera me olvidé de herramientas importantes como declaraciones if y bucles for.\nCapítulo 6  Funciones, “Funciones”, tiene un ordenamiento mejorado, introduce las canalizaciones (%&gt;% y |&gt;) como una tercera forma de componer funciones (Sección 6.3 Composición de funciones) y ha mejorado considerablemente la cobertura de formas de funciones (Sección 6.8 Formas de función).\nCapítulo 7  Entornos, “Entornos”, tiene un tratamiento reorganizado de entornos especiales 7.4 Entornos especiales, y una discusión muy mejorada de la pila de llamadas 7.5 Pilas de llamadas.\nCapítulo 8  Condiciones, “Condiciones”, contiene material previamente en “Excepciones y depuración”, y mucho contenido nuevo sobre cómo funciona el sistema de condiciones de R. También le muestra cómo crear sus propias clases de condiciones personalizadas 8.5 Condiciones personalizadas.\n\nLos capítulos que siguen a la Parte I, Fundamentos, se han reorganizado en torno a los tres paradigmas de programación más importantes en R: programación funcional, programación orientada a objetos y metaprogramación.\n\nLa programación funcional ahora se divide más claramente en las tres técnicas principales: “Funcionales” (Capítulo 9  Funcionales), “Fábricas de funciones” (Capítulo 10  Fábricas de funciones) y “Operadores de funciones” (Capítulo 11  Operadores de funciones). Me he centrado en ideas que tienen aplicaciones prácticas en la ciencia de datos y he reducido la cantidad de teoría pura.\nEstos capítulos ahora usan funciones provistas por el paquete purrr (Henry y Wickham 2018), lo que me permite concentrarme más en las ideas subyacentes y menos en los detalles secundarios. Esto condujo a una simplificación considerable del capítulo de operadores de funciones, ya que un uso importante era evitar la ausencia de puntos suspensivos (...) en los funcionales base.\nLa programación orientada a objetos (POO) ahora forma una sección importante del libro con capítulos completamente nuevos sobre tipos base (Capítulo 12  Tipos básicos), S3 (Capítulo 13  S3), S4 (Capítulo 15  S4), R6 (Capítulo 14  R6) y las compensaciones entre los sistemas (Capítulo 16  Compensaciones).\nEstos capítulos se enfocan en cómo funcionan los diferentes sistemas de objetos, no en cómo usarlos de manera efectiva. Esto es desafortunado, pero necesario, porque muchos de los detalles técnicos no se describen en otra parte, y el uso efectivo de OOP necesita un libro completo propio.\nLa metaprogramación (anteriormente llamada “computación en el lenguaje”) describe el conjunto de herramientas que puede usar para generar código con código. En comparación con la primera edición, este material se ha ampliado sustancialmente y ahora se centra en la “evaluación ordenada”, un conjunto de ideas y teorías que hacen que la metaprogramación sea segura, tenga buenos principios y sea accesible para muchos más programadores de R. Capítulo 17  Panorama general, “Panorama general” establece de forma aproximada cómo encajan todas las piezas; Capítulo 18  Expresiones, “Expresiones”, describe las estructuras de datos subyacentes; Capítulo 19  Cuasicita, “Cuasicita”, cubre las citas y las no comillas; Capítulo 20  Evaluación, “Evaluación”, explica la evaluación del código en entornos especiales; y Capítulo 21  Traducir código R, “Traducciones”, reúne todos los temas para mostrar cómo puede traducir de un lenguaje (de programación) a otro.\n\nLa sección final del libro reúne los capítulos sobre técnicas de programación: creación de perfiles, medición y mejora del rendimiento y Rcpp. Los contenidos son muy similares a la primera edición, aunque la organización es un poco diferente. He realizado ligeras actualizaciones a lo largo de estos capítulos, especialmente para usar paquetes más nuevos (microbenchmark -&gt; bench, lineprof -&gt; profvis), pero la mayor parte del texto es el mismo.\nSi bien la segunda edición ha ampliado principalmente la cobertura del material existente, se han eliminado cinco capítulos:\n\nEl capítulo de vocabulario se eliminó porque siempre fue un poco extraño, y hay formas más efectivas de presentar listas de vocabulario que en un capítulo de libro.\nEl capítulo de estilo ha sido reemplazado por una guía de estilo en línea, http://style.tidyverse.org/. La guía de estilo se combina con el nuevo paquete styler (Müller y Walthert 2018) que puede aplicar automáticamente muchas de las reglas.\nEl capítulo de C se ha movido a https://github.com/hadley/r-internals, que, con el tiempo, proporcionará una guía para escribir código C que funcione con las estructuras de datos de R.\nEl capítulo de memoria ha sido eliminado. Gran parte del material se ha integrado en Capítulo 2  Nombres y valores y el resto se sintió demasiado técnico y no tan importante de entender.\nSe eliminó el capítulo sobre el desempeño de R como lenguaje. Proporcionó pocas ideas procesables y se volvió anticuado a medida que cambiaba R.\n\n\n\n\n\nHenry, Lionel, y Hadley Wickham. 2018. purrr: functional programming tools. https://purrr.tidyverse.org.\n\n\nMüller, Kirill, y Lorenz Walthert. 2018. styler: Non-Invasive Pretty Printing of R Code. http://styler.r-lib.org.\n\n\nMüller, Kirill, y Hadley Wickham. 2018. tibble: simple data frames. http://tibble.tidyverse.org/.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1 ¿Por qué R?\nSi es nuevo en R, es posible que se pregunte qué hace que valga la pena aprender un lenguaje tan peculiar. Para mí, algunas de las mejores características son:\nPor supuesto, R no es perfecto. El mayor desafío (¡y oportunidad!) de R es que la mayoría de los usuarios de R no son programadores. Esto significa que:\nPersonalmente, creo que estos desafíos crean una gran oportunidad para que los programadores experimentados tengan un profundo impacto positivo en R y en la comunidad de R. Los usuarios de R se preocupan por escribir código de alta calidad, en particular para la investigación reproducible, pero aún no tienen las habilidades para hacerlo. Espero que este libro no solo ayude a más usuarios de R a convertirse en programadores de R, sino que también anime a los programadores de otros lenguajes a contribuir con R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#por-qué-r",
    "href": "Introduction.html#por-qué-r",
    "title": "1  Introducción",
    "section": "",
    "text": "Es gratis, de código abierto y está disponible en todas las plataformas principales. Como resultado, si realiza su análisis en R, cualquiera puede replicarlo fácilmente, independientemente de dónde viva o cuánto dinero gane.\nR tiene una comunidad diversa y acogedora, tanto en línea (por ejemplo, la comunidad de Twitter #rstats) como en persona (como las muchas reuniones de R). Dos grupos comunitarios particularmente inspiradores son rweekly newsletter que facilita mantenerse al día con R, y R-Ladies que ha creado una comunidad maravillosamente acogedora para mujeres y otros géneros minoritarios.\nUn conjunto masivo de paquetes para modelado estadístico, aprendizaje automático, visualización e importación y manipulación de datos. Sea cual sea el modelo o el gráfico que esté tratando de hacer, lo más probable es que alguien ya haya intentado hacerlo y pueda aprender de sus esfuerzos.\nPotentes herramientas para comunicar sus resultados. Quarto facilita convertir sus resultados en archivos HTML, PDF, documentos de Word, presentaciones de PowerPoint, tableros y más. Shiny le permite crear hermosas aplicaciones interactivas sin ningún conocimiento de HTML o javascript.\nRStudio, proporciona un entorno de desarrollo integrado, adaptado a las necesidades de la ciencia de datos, el análisis interactivo de datos y la programación estadística.\nHerramientas de vanguardia. Los investigadores en estadística y aprendizaje automático suelen publicar un paquete R para acompañar sus artículos. Esto significa acceso inmediato a las últimas técnicas e implementaciones estadísticas.\nSoporte de lenguaje profundamente arraigado para el análisis de datos. Esto incluye funciones como valores perdidos, marcos de datos y vectorización.\nUna base sólida de programación funcional. Las ideas de la programación funcional se adaptan bien a los desafíos de la ciencia de datos, y el lenguaje R es funcional en el fondo y proporciona muchas primitivas necesarias para una programación funcional efectiva.\nPosit, que gana dinero vendiendo productos profesionales a equipos de usuarios de R, y da la vuelta e invierte gran parte de ese dinero en la comunidad de código abierto (más del 50 % de los ingenieros de software de Posit trabajan en proyectos de código abierto). Trabajo para Posit porque creo fundamentalmente en su misión.\nPotentes instalaciones de metaprogramación. Las capacidades de metaprogramación de R le permiten escribir funciones mágicamente sucintas y concisas y proporcionan un entorno excelente para diseñar lenguajes específicos de dominio como ggplot2, dplyr, data.table y más.\nLa facilidad con la que R puede conectarse a lenguajes de programación de alto rendimiento como C, Fortran y C++.\n\n\n\nGran parte del código R que verá en la naturaleza está escrito a toda prisa para resolver un problema apremiante. Como resultado, el código no es muy elegante, rápido o fácil de entender. La mayoría de los usuarios no revisan su código para abordar estas deficiencias.\nEn comparación con otros lenguajes de programación, la comunidad R está más enfocada en los resultados que en los procesos. El conocimiento de las mejores prácticas de ingeniería de software es irregular. Por ejemplo, no hay suficientes programadores de R que usen control de código fuente o pruebas automatizadas.\nLa metaprogramación es un arma de doble filo. Demasiadas funciones de R usan trucos para reducir la cantidad de escritura a costa de crear un código que es difícil de entender y que puede fallar de formas inesperadas.\nLa incoherencia abunda entre los paquetes contribuidos, e incluso dentro de la base R. Cada vez que usa R, se enfrenta a más de 25 años de evolución, y esto puede dificultar el aprendizaje de R porque hay muchos casos especiales que recordar.\nR no es un lenguaje de programación particularmente rápido, y el código R mal escrito puede ser terriblemente lento. R también es un usuario derrochador de la memoria.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#who-should-read",
    "href": "Introduction.html#who-should-read",
    "title": "1  Introducción",
    "section": "1.2 ¿Quién debería leer este libro?",
    "text": "1.2 ¿Quién debería leer este libro?\nEste libro está dirigido a dos públicos complementarios:\n\nProgramadores intermedios de R que quieran profundizar en R, comprender cómo funciona el lenguaje y aprender nuevas estrategias para resolver diversos problemas.\nProgramadores de otros lenguajes que están aprendiendo R y quieren entender por qué R funciona de la forma en que lo hace.\n\nPara aprovechar al máximo este libro, deberá haber escrito una cantidad decente de código en R u otro lenguaje de programación. Debe estar familiarizado con los conceptos básicos del análisis de datos (es decir, importación, manipulación y visualización de datos), haber escrito una serie de funciones y estar familiarizado con la instalación y el uso de paquetes CRAN.\nEste libro recorre la estrecha línea entre ser un libro de referencia (utilizado principalmente para búsquedas) y ser legible linealmente. Esto implica algunas compensaciones, porque es difícil linealizar el material sin dejar de mantener juntos los materiales relacionados, y algunos conceptos son mucho más fáciles de explicar si ya está familiarizado con el vocabulario técnico específico. He tratado de usar notas al pie y referencias cruzadas para asegurarme de que aún pueda tener sentido incluso si solo sumerge los dedos de los pies en un capítulo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#what-you-will-get",
    "href": "Introduction.html#what-you-will-get",
    "title": "1  Introducción",
    "section": "1.3 ¿Qué obtendrás de este libro?",
    "text": "1.3 ¿Qué obtendrás de este libro?\nEste libro brinda el conocimiento que creo que un programador avanzado de R debe poseer: una comprensión profunda de los fundamentos junto con un amplio vocabulario que significa que puede aprender tácticamente más sobre un tema cuando sea necesario.\nDespués de leer este libro, usted:\n\nEstará familiarizado con los fundamentos de R. Comprenderá los tipos de datos complejos y las mejores formas de realizar operaciones en ellos. Tendrá una comprensión profunda de cómo funcionan las funciones, sabrá qué son los entornos y cómo hacer uso del sistema de condiciones.\nComprenderá qué significa la programación funcional y por qué es una herramienta útil para la ciencia de datos. Podrá aprender rápidamente cómo usar las herramientas existentes y tener el conocimiento para crear sus propias herramientas funcionales cuando sea necesario.\nConocerá la rica variedad de sistemas orientados a objetos de R. Estará más familiarizado con S3, pero sabrá de S4 y R6 y dónde buscar más información cuando sea necesario.\nApreciará la espada de doble filo de la metaprogramación. Podrá crear funciones que utilicen una evaluación ordenada, ahorrando tipeo y creando código elegante para expresar operaciones importantes. También comprenderá los peligros y cuándo evitarlos.\nTendrá una buena intuición para saber qué operaciones en R son lentas o usan mucha memoria. Sabrá cómo usar la creación de perfiles para identificar cuellos de botella en el rendimiento y sabrá lo suficiente de C++ para convertir funciones lentas de R en equivalentes rápidos de C++.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#qué-no-aprenderás",
    "href": "Introduction.html#qué-no-aprenderás",
    "title": "1  Introducción",
    "section": "1.4 ¿Qué no aprenderás?",
    "text": "1.4 ¿Qué no aprenderás?\nEste libro trata sobre R, el lenguaje de programación, no sobre R, la herramienta de análisis de datos. Si está buscando mejorar sus habilidades en ciencia de datos, le recomiendo que aprenda sobre tidyverse, una colección de paquetes consistentes desarrollados por mis colegas y yo. En este libro aprenderá las técnicas utilizadas para desarrollar los paquetes tidyverse; si desea aprender a usarlos, le recomiendo R para la Ciencia de Datos.\nSi desea compartir su código R con otros, deberá crear un paquete R. Esto le permite agrupar el código junto con la documentación y las pruebas unitarias, y distribuirlo fácilmente a través de CRAN. En mi opinión, la forma más sencilla de desarrollar paquetes es con devtools, roxygen2, testthat y usethis. Puede aprender a usar estos paquetes para crear su propio paquete en Paquetes de R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#meta-techniques",
    "href": "Introduction.html#meta-techniques",
    "title": "1  Introducción",
    "section": "1.5 Meta-técnicas",
    "text": "1.5 Meta-técnicas\nHay dos metatécnicas que son tremendamente útiles para mejorar tus habilidades como programador de R: leer el código fuente y adoptar una mentalidad científica.\nLeer el código fuente es importante porque te ayudará a escribir mejor código. Un excelente lugar para comenzar a desarrollar esta habilidad es mirar el código fuente de las funciones y paquetes que usa con más frecuencia. Encontrará cosas que vale la pena emular en su propio código y desarrollará un sentido del gusto por lo que hace un buen código R. También verás cosas que no te gustan, ya sea porque sus virtudes no son evidentes o porque ofende tu sensibilidad. No obstante, dicho código es valioso, porque ayuda a concretar sus opiniones sobre el código bueno y el malo.\nUna mentalidad científica es extremadamente útil cuando se aprende R. Si no comprende cómo funciona algo, debe desarrollar una hipótesis, diseñar algunos experimentos, ejecutarlos y registrar los resultados. Este ejercicio es extremadamente útil ya que si no puede resolver algo y necesita ayuda, puede mostrar fácilmente a otros lo que intentó. Además, cuando aprendas la respuesta correcta, estarás mentalmente preparado para actualizar tu visión del mundo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#recommended-reading",
    "href": "Introduction.html#recommended-reading",
    "title": "1  Introducción",
    "section": "1.6 Lectura recomendada",
    "text": "1.6 Lectura recomendada\nDebido a que la comunidad de R se compone principalmente de científicos de datos, no de informáticos, hay relativamente pocos libros que profundicen en los fundamentos técnicos de R. En mi viaje personal para comprender R, he encontrado que es particularmente útil usar recursos de otros lenguajes de programación. R tiene aspectos de lenguajes de programación tanto funcionales como orientados a objetos (OO). Aprender cómo se expresan estos conceptos en R lo ayudará a aprovechar su conocimiento existente de otros lenguajes de programación y lo ayudará a identificar áreas en las que puede mejorar.\nPara comprender por qué los sistemas de objetos de R funcionan de la forma en que lo hacen, descubrí que La estructura e interpretación de los programas informáticos1Abelson, Sussman, y Sussman (1996) es particularmente útil. Es un libro conciso pero profundo, y después de leerlo, sentí por primera vez que podía diseñar mi propio sistema orientado a objetos. El libro fue mi primera introducción al paradigma encapsulado de la programación orientada a objetos que se encuentra en R y me ayudó a comprender las fortalezas y debilidades de este sistema. SICP también enseña la mentalidad funcional en la que crea funciones que son simples individualmente y que se vuelven poderosas cuando se componen juntas.\nPara comprender las compensaciones que ha hecho R en comparación con otros lenguajes de programación, encontré Conceptos, técnicas y modelos de programación de computadoras (Van-Roy y Haridi 2004) extremadamente útil. Me ayudó a comprender que la semántica de copiar al modificar de R hace que sea sustancialmente más fácil razonar sobre el código y que, si bien su implementación actual no es particularmente eficiente, es un problema solucionable.\nSi quieres aprender a ser un mejor programador, no hay mejor lugar al que acudir que El programador pragmático (Hunt y Thomas 1990). Este libro es independiente del lenguaje y brinda excelentes consejos sobre cómo ser un mejor programador.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#sec-getting-help",
    "href": "Introduction.html#sec-getting-help",
    "title": "1  Introducción",
    "section": "1.7 Obteniendo ayuda",
    "text": "1.7 Obteniendo ayuda\n \nActualmente, hay tres lugares principales para obtener ayuda cuando está atascado y no puede averiguar qué está causando el problema: Comunidad Posit, StackOverflow y la lista de correo R-help. Puede obtener ayuda fantástica en cada lugar, pero tienen sus propias culturas y expectativas. Por lo general, es una buena idea pasar un poco de tiempo investigando, aprendiendo sobre las expectativas de la comunidad, antes de publicar tu primera publicación.\nAlgunos buenos consejos generales:\n\nAlgunos buenos consejos generales: asegúrese de tener la última versión de R y del paquete (o paquetes) con los que tiene problemas. Puede ser que su problema sea el resultado de un error solucionado recientemente.\nDedique algún tiempo a crear un ejemplo reproducible o reprex (de sus siglas en inglés reproducible example). Esto ayudará a que otros te ayuden y, a menudo, conduce a una solución sin preguntar a otros, porque en el proceso de hacer que el problema sea reproducible, a menudo descubres la causa raíz. Recomiendo aprender y usar el paquete reprex.\n\n\nSi está buscando ayuda específica para resolver los ejercicios de este libro, las soluciones de Malte Grosser y Henning Bumann están disponibles en https://advanced-r-solutions.rbind.io.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#intro-ack",
    "href": "Introduction.html#intro-ack",
    "title": "1  Introducción",
    "section": "1.8 Reconocimientos",
    "text": "1.8 Reconocimientos\nMe gustaría agradecer a los muchos colaboradores de R-devel y R-help y, más recientemente, Stack Overflow y Posit Community. Hay demasiados para nombrarlos individualmente, pero me gustaría agradecer especialmente a Luke Tierney, John Chambers, JJ Allaire y Brian Ripley por brindarme generosamente su tiempo y corregir mis innumerables malentendidos.\nEste libro fue escrito al aire libre, y los capítulos se anunciaron en twitter cuando se completó. Es verdaderamente un esfuerzo de la comunidad: muchas personas leen borradores, corrigen errores tipográficos, sugieren mejoras y contribuyen con contenido. Sin esos colaboradores, el libro no sería tan bueno como es y estoy profundamente agradecido por su ayuda. Un agradecimiento especial a Jeff Hammerbacher, Peter Li, Duncan Murdoch y Greg Wilson, quienes leyeron el libro de cabo a rabo y proporcionaron muchas correcciones y sugerencias.\n\nA big thank you to all 386 contributors (in alphabetical order by username): Aaron Wolen (@aaronwolen), @absolutelyNoWarranty, Adam Hunt (@adamphunt), @agrabovsky, Alexander Grueneberg (@agrueneberg), Anthony Damico (@ajdamico), James Manton (@ajdm), Aaron Schumacher (@ajschumacher), Alan Dipert (@alandipert), Alex Brown (@alexbbrown), @alexperrone, Alex Whitworth (@alexWhitworth), Alexandros Kokkalis (@alko989), @amarchin, Amelia McNamara (@AmeliaMN), Bryce Mecum (@amoeba), Andrew Laucius (@andrewla), Andrew Bray (@andrewpbray), Andrie de Vries (@andrie), Angela Li (@angela-li), @aranlunzer, Ari Lamstein (@arilamstein), @asnr, Andy Teucher (@ateucher), Albert Vilella (@avilella), baptiste (@baptiste), Brian G. Barkley (@BarkleyBG), Mara Averick (@batpigandme), Byron (@bcjaeger), Brandon Greenwell (@bgreenwell), Brandon Hurr (@bhive01), Jason Knight (@binarybana), Brett Klamer (@bklamer), Jesse Anderson (@blindjesse), Brian Mayer (@blmayer), Benjamin L. Moore (@blmoore), Brian Diggs (@BrianDiggs), Brian S. Yandell (@byandell), @carey1024, Chip Hogg (@chiphogg), Chris Muir (@ChrisMuir), Christopher Gandrud (@christophergandrud), Clay Ford (@clayford), Colin Fay (@ColinFay), @cortinah, Cameron Plouffe (@cplouffe), Carson Sievert (@cpsievert), Craig Citro (@craigcitro), Craig Grabowski (@craiggrabowski), Christopher Roach (@croach), Peter Meilstrup (@crowding), Crt Ahlin (@crtahlin), Carlos Scheidegger (@cscheid), Colin Gillespie (@csgillespie), Christopher Brown (@ctbrown), Davor Cubranic (@cubranic), Darren Cusanovich (@cusanovich), Christian G. Warden (@cwarden), Charlotte Wickham (@cwickham), Dean Attali (@daattali), Dan Sullivan (@dan87134), Daniel Barnett (@daniel-barnett), Daniel (@danielruc91), Kenny Darrell (@darrkj), Tracy Nance (@datapixie), Dave Childers (@davechilders), David Vukovic (@david-vukovic), David Rubinger (@davidrubinger), David Chudzicki (@dchudz), Deependra Dhakal (@DeependraD), Daisuke ICHIKAWA (@dichika), david kahle (@dkahle), David LeBauer (@dlebauer), David Schweizer (@dlschweizer), David Montaner (@dmontaner), @dmurdoch, Zhuoer Dong (@dongzhuoer), Doug Mitarotonda (@dougmitarotonda), Dragoș Moldovan-Grünfeld (@dragosmg), Jonathan Hill (@Dripdrop12), @drtjc, Julian During (@duju211), @duncanwadsworth, @eaurele, Dirk Eddelbuettel (@eddelbuettel), @EdFineOKL, Eduard Szöcs (@EDiLD), Edwin Thoen (@EdwinTh), Ethan Heinzen (@eheinzen), @eijoac, Joel Schwartz (@eipi10), Eric Ronald Legrand (@elegrand), Elio Campitelli (@eliocamp), Ellis Valentiner (@ellisvalentiner), Emil Hvitfeldt (@EmilHvitfeldt), Emil Rehnberg (@EmilRehnberg), Daniel Lee (@erget), Eric C. Anderson (@eriqande), Enrico Spinielli (@espinielli), @etb, David Hajage (@eusebe), Fabian Scheipl (@fabian-s), @flammy0530, François Michonneau (@fmichonneau), Francois Pepin (@fpepin), Frank Farach (@frankfarach), @freezby, Frans van Dunné (@FvD), @fyears, @gagnagaman, Garrett Grolemund (@garrettgman), Gavin Simpson (@gavinsimpson), Brooke Anderson (@geanders), @gezakiss7, @gggtest, Gökçen Eraslan (@gokceneraslan), Josh Goldberg (@GoldbergData), Georg Russ (@gr650), @grasshoppermouse, Gregor Thomas (@gregorp), Garrett See (@gsee), Ari Friedman (@gsk3), Gunnlaugur Thor Briem (@gthb), Greg Wilson (@gvwilson), Hamed (@hamedbh), Jeff Hammerbacher (@hammer), Harley Day (@harleyday), @hassaad85, @helmingstay, Henning (@henningsway), Henrik Bengtsson (@HenrikBengtsson), Ching Boon (@hoscb), @hplieninger, Hörmet Yiltiz (@hyiltiz), Iain Dillingham (@iaindillingham), @IanKopacka, Ian Lyttle (@ijlyttle), Ilan Man (@ilanman), Imanuel Costigan (@imanuelcostigan), Thomas Bürli (@initdch), Os Keyes (@Ironholds), @irudnyts, i (@isomorphisms), Irene Steves (@isteves), Jan Gleixner (@jan-glx), Jannes Muenchow (@jannes-m), Jason Asher (@jasonasher), Jason Davies (@jasondavies), Chris (@jastingo), jcborras (@jcborras), Joe Cheng (@jcheng5), John Blischak (@jdblischak), @jeharmse, Lukas Burk (@jemus42), Jennifer (Jenny) Bryan (@jennybc), Justin Jent (@jentjr), Jeston (@JestonBlu), Josh Cook (@jhrcook), Jim Hester (@jimhester), @JimInNashville, @jimmyliu2017, Jim Vine (@jimvine), Jinlong Yang (@jinlong25), J.J. Allaire (@jjallaire), @JMHay, Jochen Van de Velde (@jochenvdv), Johann Hibschman (@johannh), John Baumgartner (@johnbaums), John Horton (@johnjosephhorton), @johnthomas12, Jon Calder (@jonmcalder), Jon Harmon (@jonthegeek), Julia Gustavsen (@jooolia), JorneBiccler (@JorneBiccler), Jeffrey Arnold (@jrnold), Joyce Robbins (@jtr13), Juan Manuel Truppia (@juancentro), @juangomezduaso, Kevin Markham (@justmarkham), john verzani (@jverzani), Michael Kane (@kaneplusplus), Bart Kastermans (@kasterma), Kevin D’Auria (@kdauria), Karandeep Singh (@kdpsingh), Ken Williams (@kenahoo), Kendon Bell (@kendonB), Kent Johnson (@kent37), Kevin Ushey (@kevinushey), 电线杆 (@kfeng123), Karl Forner (@kforner), Kirill Sevastyanenko (@kirillseva), Brian Knaus (@knausb), Kirill Müller (@krlmlr), Kriti Sen Sharma (@ksens), Kai Tang (唐恺） (@ktang), Kevin Wright (@kwstat), suo.lawrence.liu@gmail.com (@Lawrence-Liu), @ldfmrails, Kevin Kainan Li (@legendre6891), Rachel Severson (@leighseverson), Laurent Gatto (@lgatto), C. Jason Liang (@liangcj), Steve Lianoglou (@lianos), Yongfu Liao (@liao961120), Likan (@likanzhan), @lindbrook, Lingbing Feng (@Lingbing), Marcel Ramos (@LiNk-NY), Zhongpeng Lin (@linzhp), Lionel Henry (@lionel-), Lluís (@llrs), myq (@lrcg), Luke W Johnston (@lwjohnst86), Kevin Lynagh (@lynaghk), @MajoroMask, Malcolm Barrett (@malcolmbarrett), @mannyishere, @mascaretti, Matt (@mattbaggott), Matthew Grogan (@mattgrogan), @matthewhillary, Matthieu Gomez (@matthieugomez), Matt Malin (@mattmalin), Mauro Lepore (@maurolepore), Max Ghenis (@MaxGhenis), Maximilian Held (@maxheld83), Michal Bojanowski (@mbojan), Mark Rosenstein (@mbrmbr), Michael Sumner (@mdsumner), Jun Mei (@meijun), merkliopas (@merkliopas), mfrasco (@mfrasco), Michael Bach (@michaelbach), Michael Bishop (@MichaelMBishop), Michael Buckley (@michaelmikebuckley), Michael Quinn (@michaelquinn32), @miguelmorin, Michael (@mikekaminsky), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), @mjsduncan, Mamoun Benghezal (@MoBeng), Matt Pettis (@mpettis), Martin Morgan (@mtmorgan), Guy Dawson (@Mullefa), Nacho Caballero (@nachocab), Natalya Rapstine (@natalya-patrikeeva), Nick Carchedi (@ncarchedi), Pascal Burkhard (@Nenuial), Noah Greifer (@ngreifer), Nicholas Vasile (@nickv9), Nikos Ignatiadis (@nignatiadis), Nina Munkholt Jakobsen (@nmjakobsen), Xavier Laviron (@norival), Nick Pullen (@nstjhp), Oge Nnadi (@ogennadi), Oliver Paisley (@oliverpaisley), Pariksheet Nanda (@omsai), Øystein Sørensen (@osorensen), Paul (@otepoti), Otho Mantegazza (@othomantegazza), Dewey Dunnington (@paleolimbot), Paola Corrales (@paocorrales), Parker Abercrombie (@parkerabercrombie), Patrick Hausmann (@patperu), Patrick Miller (@patr1ckm), Patrick Werkmeister (@Patrick01), @paulponcet, @pdb61, Tom Crockett (@pelotom), @pengyu, Jeremiah (@perryjer1), Peter Hickey (@PeteHaitch), Phil Chalmers (@philchalmers), Jose Antonio Magaña Mesa (@picarus), Pierre Casadebaig (@picasa), Antonio Piccolboni (@piccolbo), Pierre Roudier (@pierreroudier), Poor Yorick (@pooryorick), Marie-Helene Burle (@prosoitos), Peter Schulam (@pschulam), John (@quantbo), Quyu Kong (@qykong), Ramiro Magno (@ramiromagno), Ramnath Vaidyanathan (@ramnathv), Kun Ren (@renkun-ken), Richard Reeve (@richardreeve), Richard Cotton (@richierocks), Robert M Flight (@rmflight), R. Mark Sharp (@rmsharp), Robert Krzyzanowski (@robertzk), @robiRagan, Romain François (@romainfrancois), Ross Holmberg (@rossholmberg), Ricardo Pietrobon (@rpietro), @rrunner, Ryan Walker (@rtwalker), @rubenfcasal, Rob Weyant (@rweyant), Rumen Zarev (@rzarev), Nan Wang (@sailingwave), Samuel Perreault (@samperochkin), @sbgraves237, Scott Kostyshak (@scottkosty), Scott Leishman (@scttl), Sean Hughes (@seaaan), Sean Anderson (@seananderson), Sean Carmody (@seancarmody), Sebastian (@sebastian-c), Matthew Sedaghatfar (@sedaghatfar), @see24, Sven E. Templer (@setempler), @sflippl, @shabbybanks, Steven Pav (@shabbychef), Shannon Rush (@shannonrush), S’busiso Mkhondwane (@sibusiso16), Sigfried Gold (@Sigfried), Simon O’Hanlon (@simonohanlon101), Simon Potter (@sjp), Leo Razoumov (@slonik-az), Richard M. Smith (@Smudgerville), Steve (@SplashDance), Scott Ritchie (@sritchie73), Tim Cole (@statist7), @ste-fan, @stephens999, Steve Walker (@stevencarlislewalker), Stefan Widgren (@stewid), Homer Strong (@strongh), Suman Khanal (@sumanstats), Dirk (@surmann), Sebastien Vigneau (@svigneau), Steven Nydick (@swnydick), Taekyun Kim (@taekyunk), Tal Galili (@talgalili), @Tazinho, Tyler Bradley (@tbradley1013), Tom B (@tbuckl), @tdenes, @thomasherbig, Thomas (@thomaskern), Thomas Lin Pedersen (@thomasp85), Thomas Zumbrunn (@thomaszumbrunn), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Nagler (@tnagler), Anton Antonov (@tonytonov), Ben Torvaney (@Torvaney), Jeff Allen (@trestletech), Tyler Rinker (@trinker), Chitu Okoli (@Tripartio), Kirill Tsukanov (@tskir), Terence Teo (@tteo), Tim Triche, Jr. (@ttriche), @tyhenkaline, Tyler Ritchie (@tylerritchie), Tyler Littlefield (@tyluRp), Varun Agrawal (@varun729), Vijay Barve (@vijaybarve), Victor (@vkryukov), Vaidotas Zemlys-Balevičius (@vzemlys), Winston Chang (@wch), Linda Chin (@wchi144), Welliton Souza (@Welliton309), Gregg Whitworth (@whitwort), Will Beasley (@wibeasley), William R Bauer (@WilCrofter), William Doane (@WilDoane), Sean Wilkinson (@wilkinson), Christof Winter (@winterschlaefer), Jake Thompson (@wjakethompson), Bill Carver (@wmc3), Wolfgang Huber (@wolfganghuber), Krishna Sankar (@xsankar), Yihui Xie (@yihui), yang (@yiluheihei), Yoni Ben-Meshulam (@yoni), @yuchouchen, Yuqi Liao (@yuqiliao), Hiroaki Yutani (@yutannihilation), Zachary Foster (@zachary-foster), @zachcp, @zackham, Sergio Oller (@zeehio), Edward Cho (@zerokarmaleft), Albert Zhao (@zxzb).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#conventions",
    "href": "Introduction.html#conventions",
    "title": "1  Introducción",
    "section": "1.9 Convenciones",
    "text": "1.9 Convenciones\nA lo largo de este libro utilizo f() para referirme a funciones, g para referirme a variables y parámetros de funciones, y h/ a rutas.\nLos bloques de código más grandes entremezclan la entrada y la salida. La salida se comenta (#&gt;) de modo que si tiene una versión electrónica del libro, por ejemplo, https://adv-r.hadley.nz/, puede copiar y pegar fácilmente ejemplos en R.\nMuchos ejemplos usan números aleatorios. Estos se hacen reproducibles mediante set.seed(1014), que se ejecuta automáticamente al comienzo de cada capítulo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#colophon",
    "href": "Introduction.html#colophon",
    "title": "1  Introducción",
    "section": "1.10 Colofón",
    "text": "1.10 Colofón\nEste libro fue escrito en bookdown dentro de RStudio. El sitio web está alojado en netlify, y travis-ci lo actualiza automáticamente después de cada confirmación. La fuente completa está disponible en GitHub. El código del libro impreso se establece en inconsolata. Las imágenes de emoji en el libro impreso provienen de [Twitter Emoji] con licencia abierta (https://github.com/twitter/twemoji).\nEsta versión del libro se creó con R version 4.4.0 (2024-04-24) y los siguientes paquetes.\n\n\n\n\n\n\n\n\n\npackage\nversion\nsource\n\n\n\n\nbench\n1.1.3\nRSPM (R 4.4.0)\n\n\nbookdown\n0.39\nRSPM (R 4.4.0)\n\n\nbslib\n0.7.0\nRSPM (R 4.4.0)\n\n\ndbplyr\n2.5.0\nRSPM (R 4.4.0)\n\n\ndesc\n1.4.3\nRSPM (R 4.4.0)\n\n\ndownlit\n0.4.3\nRSPM (R 4.4.0)\n\n\nemo\n0.0.0.9000\ngit (hadley/emo@3f03b11491ce3d6fc5601e210927eff73bf8e350)\n\n\nggbeeswarm\n0.7.2\nRSPM (R 4.4.0)\n\n\nggplot2\n3.5.1\nRSPM (R 4.4.0)\n\n\njsonlite\n1.8.8\nRSPM (R 4.4.0)\n\n\nknitr\n1.46\nRSPM (R 4.4.0)\n\n\nlobstr\n1.1.2\nRSPM (R 4.4.0)\n\n\nmemoise\n2.0.1\nRSPM (R 4.4.0)\n\n\npng\n0.1-8\nRSPM (R 4.4.0)\n\n\nprofvis\n0.3.8\nRSPM (R 4.4.0)\n\n\nRcpp\n1.0.12\nRSPM (R 4.4.0)\n\n\nrlang\n1.1.3\nRSPM (R 4.4.0)\n\n\nRSQLite\n2.3.6\nRSPM (R 4.4.0)\n\n\nscales\n1.3.0\nRSPM (R 4.4.0)\n\n\nsessioninfo\n1.2.2\nRSPM (R 4.4.0)\n\n\nsloop\n1.0.1\nRSPM (R 4.4.0)\n\n\ntestthat\n3.2.1.1\nRSPM (R 4.4.0)\n\n\ntidyr\n1.3.1\nRSPM (R 4.4.0)\n\n\nvctrs\n0.6.5\nRSPM (R 4.4.0)\n\n\nxml2\n1.3.6\nRSPM (R 4.4.0)\n\n\nzeallot\n0.1.0\nRSPM (R 4.4.0)\n\n\n\n\n\n\n\n\nAbelson, Harold, Gerald Jay Sussman, y Julie Sussman. 1996. Structure and Interpretation of Computer Programs. MIT Press.\n\n\nHunt, Andrew, y David Thomas. 1990. The Pragmatic Programmer. Addison Wesley.\n\n\nVan-Roy, Peter, y Seif Haridi. 2004. Concepts, Techniques, and Models of Computer Programming. MIT press.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Introduction.html#footnotes",
    "href": "Introduction.html#footnotes",
    "title": "1  Introducción",
    "section": "",
    "text": "Puedes leerlo en línea gratis en https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "Foundations.html",
    "href": "Foundations.html",
    "title": "Introducción",
    "section": "",
    "text": "Para comenzar su viaje en el dominio de R, los siguientes siete capítulos lo ayudarán a aprender los componentes básicos de R. Espero que ya haya visto muchas de estas piezas antes, pero probablemente no las haya estudiado en profundidad. Para ayudarlo a verificar su conocimiento actual, cada capítulo comienza con un cuestionario; Si responde correctamente todas las preguntas, ¡siéntase libre de pasar al siguiente capítulo!\n\nEl 2  Nombres y valores le enseña sobre una distinción importante en la que probablemente no ha pensado profundamente: la diferencia entre un objeto y su nombre. Mejorar su modelo mental aquí lo ayudará a hacer mejores predicciones sobre cuándo R copia los datos y, por lo tanto, qué operaciones básicas son baratas y cuáles son caras.\nEl 3  Vectores se sumerge en los detalles de los vectores, ayudándole a aprender cómo encajan los diferentes tipos de vectores. También aprenderá sobre los atributos, que le permiten almacenar metadatos arbitrarios y forman la base de dos de los juegos de herramientas de programación orientada a objetos de R.\nEl 4  Subconjunto describe cómo usar subsetting para escribir código R claro, conciso y eficiente. Comprender los componentes fundamentales le permitirá resolver nuevos problemas al combinar los componentes básicos de formas novedosas.\nEl 5  Flujo de control presenta herramientas de control de flujo que le permiten ejecutar código solo bajo ciertas condiciones, o ejecutar código repetidamente con entradas cambiantes. Estos incluyen las construcciones importantes if y for, así como herramientas relacionadas como switch() y while.\nEl 6  Funciones trata sobre las funciones, los bloques de construcción más importantes del código R. Aprenderá exactamente cómo funcionan, incluidas las reglas de scooping, que rigen cómo R busca valores de nombres. También aprenderá más sobre los detalles detrás de la evaluación diferida y cómo puede controlar lo que sucede cuando sale de una función.\nEl 7  Entornos describe una estructura de datos que es crucial para entender cómo funciona R, pero poco importante para el análisis de datos: el entorno. Los entornos son la estructura de datos que vincula los nombres a los valores y potencian herramientas importantes como los espacios de nombres de paquetes. A diferencia de la mayoría de los lenguajes de programación, los entornos en R son de “primera clase”, lo que significa que puede manipularlos como cualquier otro objeto.\nEl 8  Condiciones concluye los fundamentos de R con una exploración de “condiciones”, el término genérico que se usa para describir errores, advertencias y mensajes. Seguramente los ha encontrado antes, por lo que en este capítulo aprenderá cómo señalarlos apropiadamente en sus propias funciones y cómo manejarlos cuando se les indique en otro lugar.",
    "crumbs": [
      "Fundamentos",
      "Introducción"
    ]
  },
  {
    "objectID": "Names-values.html",
    "href": "Names-values.html",
    "title": "2  Nombres y valores",
    "section": "",
    "text": "2.1 Introducción\nEn R, es importante comprender la distinción entre un objeto y su nombre. Si lo hace, le ayudará a:\nEl objetivo de este capítulo es ayudarlo a comprender la distinción entre nombres y valores, y cuándo R copiará un objeto.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#introducción",
    "href": "Names-values.html#introducción",
    "title": "2  Nombres y valores",
    "section": "",
    "text": "Predecir con mayor precisión el rendimiento y el uso de memoria de su código.\nEscribir código más rápido evitando copias accidentales, una fuente importante de código lento.\nComprender mejor las herramientas de programación funcional de R.\n\n\n\nPrueba\nResponda las siguientes preguntas para ver si puede omitir este capítulo con seguridad. Puede encontrar las respuestas al final del capítulo en la Sección 2.7.\n\nDado el siguiente data frame, ¿cómo creo una nueva columna llamada “3” que contenga la suma de 1 y 2? Solo puede usar $, no [[. ¿Qué hace que 1, 2 y 3 sean desafiantes como nombres de variables?\n\ndf &lt;- data.frame(runif(3), runif(3))\nnames(df) &lt;- c(1, 2)\n\nEn el siguiente código, ¿cuánta memoria ocupa y?\n\nx &lt;- runif(1e6)\ny &lt;- list(x, x, x)\n\n¿En qué línea se copia a en el siguiente ejemplo?\n\na &lt;- c(1, 5, 3, 2)\nb &lt;- a\nb[[1]] &lt;- 10\n\n\n\n\nEstructura\n\nLa Sección 2.2 lo introduce a la distinción entre nombres y valores, y explica cómo &lt;- crea un vínculo, o referencia, entre un nombre y un valor.\nLa Sección 2.3 describe cuándo R hace una copia: cada vez que modificas un vector, es casi seguro que estás creando un nuevo vector modificado. Aprenderá a usar tracemem() para averiguar cuándo se produce realmente una copia. Luego, explorará las implicaciones que se aplican a las llamadas a funciones, listas, data frames y vectores de caracteres.\nLa Sección 2.4 explora las implicaciones de las dos secciones anteriores sobre cuánta memoria ocupa un objeto. Dado que su intuición puede estar profundamente equivocada y dado que utils::object.size() es lamentablemente inexacto, aprenderá a usar lobstr::obj_size().\nLa Sección 2.5 describe las dos excepciones importantes para copiar al modificar: con entornos y valores con un solo nombre, los objetos se modifican en su lugar.\nLa Sección 2.6 concluye el capítulo con una discusión sobre el recolector de basura, que libera la memoria utilizada por objetos que ya no están referenciados por un nombre.\n\n\n\nRequisitos previos\nUsaremos el paquete lobstr para profundizar en la representación interna de los objetos R.\n\nlibrary(lobstr)\n\n\n\nFuentes\nLos detalles de la gestión de memoria de R no están documentados en un solo lugar. Gran parte de la información de este capítulo se obtuvo de una lectura atenta de la documentación (en particular ?Memory y ?gc), la sección perfilado de memoria de Escribiendo extensiones R (R Core Team 2018b) y SEXPs de R internals (R Core Team 2018a). El resto lo descubrí leyendo el código fuente de C, realizando pequeños experimentos y haciendo preguntas sobre R-devel. Cualquier error es enteramente mío.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#sec-binding-basics",
    "href": "Names-values.html#sec-binding-basics",
    "title": "2  Nombres y valores",
    "section": "2.2 Binding basics",
    "text": "2.2 Binding basics\n \nConsidere este código:\n\nx &lt;- c(1, 2, 3)\n\nEs fácil leerlo como: “crear un objeto llamado ‘x’, que contenga los valores 1, 2 y 3”. Desafortunadamente, esa es una simplificación que conducirá a predicciones inexactas sobre lo que R realmente está haciendo detrás de escena. Es más exacto decir que este código está haciendo dos cosas:\n\nEstá creando un objeto, un vector de valores, c(1, 2, 3).\nY vincula ese objeto a un nombre, x.\n\nEn otras palabras, el objeto, o valor, no tiene nombre; en realidad es el nombre el que tiene un valor.\nPara aclarar aún más esta distinción, dibujaré diagramas como este:\n\n\n\n\n\n\n\n\n\nEl nombre, x, se dibuja con un rectángulo redondeado. Tiene una flecha que apunta (o une o hace referencia) al valor, el vector c(1, 2, 3). La flecha apunta en dirección opuesta a la flecha de asignación: &lt;- crea un enlace desde el nombre en el lado izquierdo hasta el objeto en el lado derecho.\nPor lo tanto, puede pensar en un nombre como una referencia a un valor. Por ejemplo, si ejecuta este código, no obtiene otra copia del valor c(1, 2, 3), obtiene otro enlace al objeto existente:\n\ny &lt;- x\n\n\n\n\n\n\n\n\n\n\nEs posible que hayas notado que el valor c(1, 2, 3) tiene una etiqueta: 0x74b. Si bien el vector no tiene nombre, ocasionalmente necesitaré referirme a un objeto independiente de sus enlaces. Para que eso sea posible, etiquetaré los valores con un identificador único. Estos identificadores tienen una forma especial que se parece a la “dirección” de la memoria del objeto, es decir, la ubicación en la memoria donde se almacena el objeto. Pero debido a que las direcciones de memoria reales cambian cada vez que se ejecuta el código, usamos estos identificadores en su lugar.\nPuede acceder al identificador de un objeto con lobstr::obj_addr(). Hacerlo te permite ver que tanto x como y apuntan al mismo identificador:\n\nobj_addr(x)\n#&gt; [1] \"0x55dd7c03abc8\"\nobj_addr(y)\n#&gt; [1] \"0x55dd7c03abc8\"\n\nEstos identificadores son largos y cambian cada vez que reinicia R.\nPuede tomar algún tiempo comprender la distinción entre nombres y valores, pero comprender esto es realmente útil en la programación funcional, donde las funciones pueden tener diferentes nombres en diferentes contextos.\n\n2.2.1 Nombres no sintácticos\n \nR tiene reglas estrictas sobre lo que constituye un nombre válido. Un nombre sintáctico debe constar de letras1, dígitos, . y _ pero no puede comenzar con _ o un dígito. Además, no puede usar ninguna de las palabras reservadas como TRUE, NULL, if y function (vea la lista completa en ?Reserved). Un nombre que no sigue estas reglas es un nombre no sintáctico; si intenta usarlos, obtendrá un error:\n\n_abc &lt;- 1\n#&gt; Error: unexpected input in \"_\"\n\nif &lt;- 10\n#&gt; Error: unexpected assignment in \"if &lt;-\"\n\nEs posible anular estas reglas y usar cualquier nombre, es decir, cualquier secuencia de caracteres, rodeándolo con acentos graves:\n\n`_abc` &lt;- 1\n`_abc`\n#&gt; [1] 1\n\n`if` &lt;- 10\n`if`\n#&gt; [1] 10\n\nSi bien es poco probable que cree deliberadamente nombres tan locos, debe comprender cómo funcionan estos nombres locos porque los encontrará, más comúnmente cuando carga datos que se han creado fuera de R.\n\nPuede también crear enlaces no sintácticos usando comillas simples o dobles (por ejemplo, \"_abc\" &lt;- 1) en lugar de acentos graves, pero no debería, porque tendrá que usar una sintaxis diferente para recuperar los valores. La capacidad de usar cadenas en el lado izquierdo de la flecha de asignación es un artefacto histórico, usado antes de que R admitiera los acentos graves.\n\n\n\n2.2.2 Ejercicios\n\nExplique la relación entre a, b, c y d en el siguiente código:\n\na &lt;- 1:10\nb &lt;- a\nc &lt;- b\nd &lt;- 1:10\n\nEl siguiente código accede a la función de media de varias maneras. ¿Todos apuntan al mismo objeto de función subyacente? Verifique esto con lobstr::obj_addr().\n\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")\n\nDe forma predeterminada, las funciones de importación de datos base R, como read.csv(), convertirán automáticamente los nombres no sintácticos en sintácticos. ¿Por qué podría ser esto problemático? ¿Qué opción le permite suprimir este comportamiento?\n¿Qué reglas usa make.names() para convertir nombres no sintácticos en sintácticos?\nSimplifiqué ligeramente las reglas que rigen los nombres sintácticos. ¿Por qué .123e1 no es un nombre sintáctico? Lea ?make.names para obtener todos los detalles.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#sec-copy-on-modify",
    "href": "Names-values.html#sec-copy-on-modify",
    "title": "2  Nombres y valores",
    "section": "2.3 Copiar al modificar",
    "text": "2.3 Copiar al modificar\n\nConsidere el siguiente código. Vincula x e y al mismo valor subyacente, luego modifica y2.\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\ny[[3]] &lt;- 4\nx\n#&gt; [1] 1 2 3\n\nModificar y claramente no modificó x. Entonces, ¿qué pasó con el enlace compartido? Mientras que el valor asociado con y cambió, el objeto original no lo hizo. En su lugar, R creó un nuevo objeto, ‘0xcd2’, una copia de ‘0x74b’ con un valor cambiado, y luego rebotó ‘y’ a ese objeto.\n\n\n\n\n\n\n\n\n\nEste comportamiento se llama copiar al modificar. Comprenderlo mejorará radicalmente su intuición sobre el rendimiento del código R. Una forma relacionada de describir este comportamiento es decir que los objetos R no se pueden modificar o inmutables. Sin embargo, generalmente evitaré ese término porque hay un par de excepciones importantes para copiar al modificar que aprenderá en la Sección 2.5.\nAl explorar el comportamiento de copiar al modificar de forma interactiva, tenga en cuenta que obtendrá diferentes resultados dentro de RStudio. Esto se debe a que el panel de entorno debe hacer una referencia a cada objeto para mostrar información sobre él. Esto distorsiona su exploración interactiva pero no afecta el código dentro de las funciones y, por lo tanto, no afecta el rendimiento durante el análisis de datos. Para experimentar, recomiendo ejecutar R directamente desde la terminal o usar Quarto (como este libro).\n\n2.3.1 tracemem()\n\nPuedes ver cuándo se copia un objeto con la ayuda de base::tracemem(). Una vez que llame a esa función con un objeto, obtendrá la dirección actual del objeto:\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x7f80c0e0ffc8&gt; \n\nA partir de ese momento, cada vez que se copie ese objeto, tracemem() imprimirá un mensaje que le indicará qué objeto se copió, su nueva dirección y la secuencia de llamadas que llevaron a la copia:\n\ny &lt;- x\ny[[3]] &lt;- 4L\n#&gt; tracemem[0x7f80c0e0ffc8 -&gt; 0x7f80c4427f40]: \n\nSi modifica y de nuevo, no se copiará. Esto se debe a que el nuevo objeto ahora solo tiene un único nombre vinculado, por lo que R aplica la optimización de modificación en el lugar. Volveremos a esto en la Sección 2.5.\n\ny[[3]] &lt;- 5L\n\nuntracemem(x)\n\nuntracemem() es lo contrario de tracemem(); apaga el rastreo.\n\n\n2.3.2 Llamadas de función\nLas mismas reglas para copiar también se aplican a las llamadas a funciones. Toma este código:\n\nf &lt;- function(a) {\n  a\n}\n\nx &lt;- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x55dd7bfc1e58&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\nMientras f() se está ejecutando, a dentro de la función apunta al mismo valor que x fuera de la función:\n\n\n\n\n\n\n\n\n\nAprenderá más sobre las convenciones utilizadas en este diagrama en la Sección 7.4.4. En resumen: la función f() está representada por el objeto amarillo a la derecha. Tiene un argumento formal, a, que se convierte en un enlace (indicado por una línea negra punteada) en el entorno de ejecución (el cuadro gris) cuando se ejecuta la función.\nUna vez que f() se complete, x y z apuntarán al mismo objeto. 0x74b nunca se copia porque nunca se modifica. Si f() modificara x, R crearía una nueva copia y luego z vincularía ese objeto.\n\n\n\n\n\n\n\n\n\n\n\n2.3.3 Listas\n\n\nNo son solo los nombres (es decir, las variables) los que apuntan a los valores; los elementos de las listas también lo hacen. Considere esta lista, que es superficialmente muy similar al vector numérico anterior:\n\nl1 &lt;- list(1, 2, 3)\n\nEsta lista es más compleja porque en lugar de almacenar los valores en sí, almacena referencias a ellos:\n\n\n\n\n\n\n\n\n\nEsto es particularmente importante cuando modificamos una lista:\n\nl2 &lt;- l1\n\n\n\n\n\n\n\n\n\n\n\nl2[[3]] &lt;- 4\n\n\n\n\n\n\n\n\n\n\nAl igual que los vectores, las listas utilizan el comportamiento de copiar al modificar; la lista original no se modifica y R crea una copia modificada. Esto, sin embargo, es una copia superficial: el objeto de la lista y sus enlaces se copian, pero los valores a los que apuntan los enlaces no. Lo opuesto a una copia superficial es una copia profunda donde se copian los contenidos de cada referencia. Antes de R 3.1.0, las copias siempre eran copias profundas.\nPara ver los valores que se comparten en las listas, use lobstr::ref(). ref() imprime la dirección de memoria de cada objeto, junto con una identificación local para que pueda cruzar fácilmente los componentes compartidos.\n\nref(l1, l2)\n#&gt; █ [1:0x55dd7bd849e8] &lt;list&gt; \n#&gt; ├─[2:0x55dd79ad6238] &lt;dbl&gt; \n#&gt; ├─[3:0x55dd79ad6270] &lt;dbl&gt; \n#&gt; └─[4:0x55dd79ad62a8] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [5:0x55dd7b8cb898] &lt;list&gt; \n#&gt; ├─[2:0x55dd79ad6238] \n#&gt; ├─[3:0x55dd79ad6270] \n#&gt; └─[6:0x55dd78a94350] &lt;dbl&gt;\n\n\n\n2.3.4 Data frames\nLos data frames son listas de vectores, por lo que copiar al modificar tiene consecuencias importantes cuando modifica un data frame. Tome este data frame como un ejemplo:\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n\n\n\n\n\n\n\n\n\n\nSi modifica una columna, solo esa columna debe modificarse; los otros seguirán apuntando a sus referencias originales:\n\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\n\n\n\n\n\n\n\n\n\n\nSin embargo, si modifica una fila, se modifican todas las columnas, lo que significa que se deben copiar todas las columnas:\n\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.5 Vectores de caracteres\n\nEl último lugar donde R usa referencias es con vectores de caracteres 3. Normalmente dibujo vectores de caracteres como este:\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\n\n\n\n\n\n\n\n\n\n\nPero esto es una ficción educada. R en realidad usa un grupo de cadenas global donde cada elemento de un vector de caracteres es un puntero a una cadena única en el grupo:\n\n\n\n\n\n\n\n\n\nPuede solicitar que ref() muestre estas referencias configurando el argumento character en TRUE:\n\nref(x, character = TRUE)\n#&gt; █ [1:0x55dd7b0e4dc8] &lt;chr&gt; \n#&gt; ├─[2:0x55dd75c9ac10] &lt;string: \"a\"&gt; \n#&gt; ├─[2:0x55dd75c9ac10] \n#&gt; ├─[3:0x55dd7a498a60] &lt;string: \"abc\"&gt; \n#&gt; └─[4:0x55dd760f0ac8] &lt;string: \"d\"&gt;\n\nEsto tiene un impacto profundo en la cantidad de memoria que usa un vector de caracteres, pero por lo demás generalmente no es importante, por lo que en otras partes del libro dibujaré vectores de caracteres como si las cadenas vivieran dentro de un vector.\n\n\n2.3.6 Ejercicios\n\n¿Por qué tracemem(1:10) no es útil?\nExplique por qué tracemem() muestra dos copias cuando ejecuta este código. Sugerencia: mire cuidadosamente la diferencia entre este código y el código que se muestra en la sección anterior.\n\nx &lt;- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] &lt;- 4\n\nEsboza la relación entre los siguientes objetos:\n\na &lt;- 1:10\nb &lt;- list(a, a)\nc &lt;- list(b, a, 1:10)\n\n¿Qué sucede cuando ejecutas este código?\n\nx &lt;- list(1:10)\nx[[2]] &lt;- x\n\nDibuja una imagen.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#sec-object-size",
    "href": "Names-values.html#sec-object-size",
    "title": "2  Nombres y valores",
    "section": "2.4 Tamaño del objeto",
    "text": "2.4 Tamaño del objeto\n\nPuedes averiguar cuánta memoria ocupa un objeto con lobstr::obj_size()4:\n\nobj_size(letters)\n#&gt; 1.71 kB\nobj_size(ggplot2::diamonds)\n#&gt; 3.46 MB\n\nDado que los elementos de las listas son referencias a valores, el tamaño de una lista puede ser mucho más pequeño de lo esperado:\n\nx &lt;- runif(1e6)\nobj_size(x)\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n#&gt; 8.00 MB\n\ny es sólo 80 bytes5 mayor que x. Ese es el tamaño de una lista vacía con tres elementos:\n\nobj_size(list(NULL, NULL, NULL))\n#&gt; 80 B\n\nDel mismo modo, debido a que R usa un grupo de cadenas global, los vectores de caracteres ocupan menos memoria de lo que cabría esperar: repetir una cadena 100 veces no hace que ocupe 100 veces más memoria.\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n#&gt; 136 B\nobj_size(rep(banana, 100))\n#&gt; 928 B\n\nLas referencias también dificultan pensar en el tamaño de los objetos individuales. obj_size(x) + obj_size(y) solo será igual a obj_size(x, y) si no hay valores compartidos. Aquí, el tamaño combinado de x e y es el mismo que el tamaño de y:\n\nobj_size(x, y)\n#&gt; 8.00 MB\n\nFinalmente, R 3.5.0 y las versiones posteriores tienen una función que podría generar sorpresas: ALTREP, abreviatura de representación alternativa. Esto permite que R represente ciertos tipos de vectores de forma muy compacta. El lugar donde es más probable que vea esto es con : porque en lugar de almacenar cada número en la secuencia, R solo almacena el primer y el último número. Esto significa que cada secuencia, sin importar cuán grande sea, tiene el mismo tamaño:\n\nobj_size(1:3)\n#&gt; 680 B\nobj_size(1:1e3)\n#&gt; 680 B\nobj_size(1:1e6)\n#&gt; 680 B\nobj_size(1:1e9)\n#&gt; 680 B\n\n\n2.4.1 Ejercicios\n\nEn el siguiente ejemplo, ¿por qué object.size(y) y obj_size(y) son tan radicalmente diferentes? Consulta la documentación de object.size().\n\ny &lt;- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#&gt; 8005648 bytes\nobj_size(y)\n#&gt; 80.90 kB\n\nToma la siguiente lista. ¿Por qué su tamaño es algo engañoso?\n\nfuns &lt;- list(mean, sd, var)\nobj_size(funs)\n#&gt; 18.76 kB\n\nPrediga la salida del siguiente código:\n\na &lt;- runif(1e6)\nobj_size(a)\n\nb &lt;- list(a, a)\nobj_size(b)\nobj_size(a, b)\n\nb[[1]][[1]] &lt;- 10\nobj_size(b)\nobj_size(a, b)\n\nb[[2]][[1]] &lt;- 10\nobj_size(b)\nobj_size(a, b)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#sec-modify-in-place",
    "href": "Names-values.html#sec-modify-in-place",
    "title": "2  Nombres y valores",
    "section": "2.5 Modificar en el lugar",
    "text": "2.5 Modificar en el lugar\n\nComo hemos visto anteriormente, modificar un objeto R generalmente crea una copia. Hay dos excepciones:\n\nLos objetos con un solo enlace obtienen una optimización de rendimiento especial.\nLos entornos, un tipo especial de objeto, siempre se modifican en su lugar.\n\n\n2.5.1 Objetos con un solo enlace\n\nSi un objeto tiene un solo nombre vinculado, R lo modificará en su lugar:\n\nv &lt;- c(1, 2, 3)\n\n\n\n\n\n\n\n\n\n\n\nv[[3]] &lt;- 4\n\n\n\n\n\n\n\n\n\n\n(Tenga en cuenta los ID de objeto aquí: v continúa enlazando con el mismo objeto, 0x207).\nDos complicaciones hacen que predecir exactamente cuándo R aplica esta optimización sea un desafío:\n\nCuando se trata de enlaces, R actualmente puede 6 solo contar 0, 1 o muchos. Eso significa que si un objeto tiene dos enlaces y uno desaparece, el recuento de referencias no vuelve a 1: uno menos que muchos sigue siendo muchos. A su vez, esto significa que R hará copias cuando a veces no sea necesario.\nCada vez que llama a la gran mayoría de las funciones, hace una referencia al objeto. La única excepción son las funciones C “primitivas” especialmente escritas. Estos solo pueden ser escritos por R-core y ocurren principalmente en el paquete base.\n\nJuntas, estas dos complicaciones hacen que sea difícil predecir si se producirá o no una copia. En cambio, es mejor determinarlo empíricamente con tracemem().\n Exploremos las sutilezas con un caso de estudio usando bucles for. Los bucles for tienen la reputación de ser lentos en R, pero a menudo esa lentitud se debe a que cada iteración del bucle crea una copia. Considere el siguiente código. Resta la mediana de cada columna de un data frame grande:\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n\nEste ciclo es sorprendentemente lento porque cada iteración del ciclo copia el data frame. Puedes ver esto usando tracemem():\n\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x7f80c429e020&gt; \n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: \n#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: \n#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: \n#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: \n#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: \n#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- \n#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- \n\nuntracemem(x)\n\nDe hecho, cada iteración copia el data frame no una, ni dos, ¡sino tres veces! Se hacen dos copias con [[.data.frame, y se hace otra copia7 porque [[.data.frame es una función normal que incrementa el recuento de referencias de x.\nPodemos reducir el número de copias usando una lista en lugar de un data frame. La modificación de una lista utiliza código C interno, por lo que las referencias no se incrementan y no se realiza ninguna copia:\n\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n#&gt; &lt;0x7f80c5c3de20&gt;\n  \nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n\nSi bien no es difícil determinar cuándo se realiza una copia, es difícil evitarlo. Si se encuentra recurriendo a trucos exóticos para evitar copias, puede ser hora de reescribir su función en C++, como se describe en el Capítulo 25.\n\n\n2.5.2 Entornos\n \nAprenderá más sobre los entornos en el Capítulo 7, pero es importante mencionarlos aquí porque su comportamiento es diferente al de otros objetos: los entornos siempre se modifican en su lugar. Esta propiedad a veces se describe como semántica de referencia porque cuando modifica un entorno, todos los enlaces existentes a ese entorno continúan teniendo la misma referencia.\nTome este entorno, que vinculamos a e1 y e2:\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\n\n\n\n\n\n\n\n\n\nSi cambiamos un enlace, el entorno se modifica en su lugar:\n\ne1$c &lt;- 4\ne2$c\n#&gt; [1] 4\n\n\n\n\n\n\n\n\n\n\nEsta idea básica se puede utilizar para crear funciones que “recuerden” su estado anterior. Consulte la Sección 10.2.4 para obtener más detalles. Esta propiedad también se usa para implementar el sistema de programación orientado a objetos R6, el tema del Capítulo 14.\nUna consecuencia de esto es que los entornos pueden contenerse a sí mismos:\n\ne &lt;- rlang::env()\ne$self &lt;- e\n\nref(e)\n#&gt; █ [1:0x55dd7955c5e0] &lt;env&gt; \n#&gt; └─self = [1:0x55dd7955c5e0]\n\n\n\n\n\n\n\n\n\n\n¡Esta es una propiedad única de los entornos!\n\n\n2.5.3 Ejercicios\n\nExplique por qué el siguiente código no crea una lista circular.\n\nx &lt;- list()\nx[[1]] &lt;- x\n\nEnvuelva los dos métodos para restar medianas en dos funciones, luego use el paquete bench(Hester 2018) para comparar cuidadosamente sus velocidades. ¿Cómo cambia el rendimiento a medida que aumenta el número de columnas?\n¿Qué sucede si intenta usar tracemem() en un entorno?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#sec-gc",
    "href": "Names-values.html#sec-gc",
    "title": "2  Nombres y valores",
    "section": "2.6 Desvincular y el recolector de basura.",
    "text": "2.6 Desvincular y el recolector de basura.\n \nConsidere este código:\n\nx &lt;- 1:3\n\n\n\n\n\n\n\n\n\n\n\nx &lt;- 2:4\n\n\n\n\n\n\n\n\n\n\n\nrm(x)\n\n\n\n\n\n\n\n\n\n\nCreamos dos objetos, pero cuando finaliza el código, ninguno de los objetos está vinculado a un nombre. ¿Cómo se eliminan estos objetos? Ese es el trabajo del recolector de basura, o GC para abreviar. El GC libera memoria eliminando objetos R que ya no se usan y solicitando más memoria del sistema operativo si es necesario.\nR utiliza un GC de trazado. Esto significa que rastrea todos los objetos a los que se puede acceder desde el entorno global8 y todos los objetos a los que, a su vez, se puede acceder desde esos objetos (es decir, las referencias en listas y entornos se buscan de forma recursiva). El recolector de elementos no utilizados no utiliza el recuento de referencias de modificación en el lugar descrito anteriormente. Si bien estas dos ideas están estrechamente relacionadas, las estructuras de datos internas están optimizadas para diferentes casos de uso.\nEl recolector de basura (GC) se ejecuta automáticamente cada vez que R necesita más memoria para crear un nuevo objeto. Mirando desde el exterior, es básicamente imposible predecir cuándo se ejecutará el GC. De hecho, ni siquiera deberías intentarlo. Si desea saber cuándo se ejecuta GC, llame a gcinfo(TRUE) y GC imprimirá un mensaje en la consola cada vez que se ejecute.\n Puedes forzar la recolección de basura llamando a gc(). Pero a pesar de lo que hayas leído en otros lugares, nunca hay necesidad de llamar a gc() tú mismo. Las únicas razones por las que podría querer llamar a gc() es para pedirle a R que devuelva la memoria a su sistema operativo para que otros programas puedan usarla, o por el efecto secundario que le dice cuánta memoria se está usando actualmente:\n\ngc() \n#&gt;           used (Mb) gc trigger (Mb) max used  (Mb)\n#&gt; Ncells 1028512 55.0    2063920  110  1794039  95.9\n#&gt; Vcells 5399189 41.2   15002481  114 14995588 114.5\n\nlobstr::mem_used() es un envoltorio alrededor de gc() que imprime el número total de bytes utilizados:\n\nmem_used()\n#&gt; 100.76 MB\n\nEste número no coincidirá con la cantidad de memoria informada por su sistema operativo. Hay tres razones:\n\nIncluye objetos creados por R pero no por el intérprete de R.\nTanto R como el sistema operativo son perezosos: no reclamarán memoria hasta que realmente se necesite. R podría estar reteniendo la memoria porque el sistema operativo aún no la ha solicitado.\nR cuenta la memoria ocupada por objetos, pero puede haber espacios vacíos debido a objetos eliminados. Este problema se conoce como fragmentación de la memoria.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#sec-names-values-answers",
    "href": "Names-values.html#sec-names-values-answers",
    "title": "2  Nombres y valores",
    "section": "2.7 Respuestas de la prueba",
    "text": "2.7 Respuestas de la prueba\n\nDebe citar nombres no sintácticos con acentos graves: `: por ejemplo, las variables 1, 2 y 3.\n\ndf &lt;- data.frame(runif(3), runif(3))\nnames(df) &lt;- c(1, 2)\n\ndf$`3` &lt;- df$`1` + df$`2`\n\nOcupa unos 8 MB.\n\nx &lt;- runif(1e6)\ny &lt;- list(x, x, x)\nobj_size(y)\n#&gt; 8.00 MB\n\na se copia cuando se modifica b, b[[1]] &lt;- 10.\n\n\n\n\n\nHester, Jim. 2018. bench: high precision timing of R expressions. http://bench.r-lib.org/.\n\n\nR Core Team. 2018a. «R Internals». R Foundation for Statistical Computing. https://cran.r-project.org/doc/manuals/r-devel/R-ints.html.\n\n\n———. 2018b. «Writing R extensions». R Foundation for Statistical Computing. https://cran.r-project.org/doc/manuals/r-devel/R-exts.html.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Names-values.html#footnotes",
    "href": "Names-values.html#footnotes",
    "title": "2  Nombres y valores",
    "section": "",
    "text": "Sorprendentemente, precisamente lo que constituye una letra está determinado por su ubicación actual. Eso significa que la sintaxis del código R en realidad puede diferir de una computadora a otra, y que es posible que un archivo que funciona en una computadora ni siquiera se analice en otra. Evite este problema apegado a los caracteres ASCII (es decir, A-Z) tanto como sea posible.↩︎\nEs posible que se sorprenda al ver que [[ se usa para crear un subconjunto de un vector numérico. Volveremos a esto en la Sección 4.3, pero en resumen, creo que siempre debes usar [[ cuando obtienes o configuras un solo elemento.↩︎\nConfusamente, un vector de caracteres es un vector de cadenas, no de caracteres individuales.↩︎\nTenga cuidado con la función utils::object.size(). No tiene en cuenta correctamente las referencias compartidas y devolverá tamaños que son demasiado grandes.↩︎\nSi está ejecutando R de 32 bits, verá tamaños ligeramente diferentes.↩︎\nPara cuando lea esto, es posible que esto haya cambiado, ya que hay planes en marcha para mejorar el conteo de referencias: https://developer.r-project.org/Refcnt.html↩︎\nEstas copias son superficiales: solo copian la referencia a cada columna individual, no el contenido de las columnas. Esto significa que el rendimiento no es terrible, pero obviamente no es tan bueno como podría ser.↩︎\nY todos los entornos de la pila de llamadas actual.↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Nombres y valores</span>"
    ]
  },
  {
    "objectID": "Vectors.html",
    "href": "Vectors.html",
    "title": "3  Vectores",
    "section": "",
    "text": "3.1 Introducción\nEste capítulo analiza la familia más importante de tipos de datos en base R: vectores1. Si bien es probable que ya haya usado muchos (si no todos) de los diferentes tipos de vectores, es posible que no haya pensado profundamente en cómo están interrelacionados. En este capítulo, no cubriré los tipos de vectores individuales con demasiado detalle, pero le mostraré cómo encajan todos los tipos como un todo. Si necesita más detalles, puede encontrarlos en la documentación de R.\nLos vectores vienen en dos sabores: vectores atómicos y listas 2. Se diferencian en cuanto a los tipos de sus elementos: para los vectores atómicos, todos los elementos deben tener el mismo tipo; para las listas, los elementos pueden tener diferentes tipos. Si bien no es un vector, NULL está estrechamente relacionado con los vectores y, a menudo, cumple la función de un vector genérico de longitud cero. Este diagrama, que ampliaremos a lo largo de este capítulo, ilustra las relaciones básicas:\nCada vector también puede tener atributos, que puede considerar como una lista con nombre de metadatos arbitrarios. Dos atributos son particularmente importantes. El atributo dimensión convierte los vectores en matrices y arreglos y el atributo clase impulsa el sistema de objetos S3. Si bien aprenderá a usar S3 en el Capítulo 13, aquí aprenderá sobre algunos de los vectores S3 más importantes: factores, fecha y hora, data frames y tibbles. Y aunque las estructuras 2D como matrices y data frames no son necesariamente lo que le viene a la mente cuando piensa en vectores, también aprenderá por qué R los considera vectores.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#introducción",
    "href": "Vectors.html#introducción",
    "title": "3  Vectores",
    "section": "",
    "text": "Prueba\nResponda este breve cuestionario para determinar si necesita leer este capítulo. Si las respuestas le vienen a la mente rápidamente, puede saltarse cómodamente este capítulo. Puede comprobar sus respuestas en la Sección 3.8.\n\n¿Cuáles son los cuatro tipos comunes de vectores atómicos? ¿Cuáles son los dos tipos raros?\n¿Qué son los atributos? ¿Cómo los consigues y los configuras?\n¿En qué se diferencia una lista de un vector atómico? ¿En qué se diferencia una matriz de un data frame?\n¿Puedes tener una lista que sea una matriz? ¿Puede un data frame tener una columna que sea una matriz?\n¿En qué se diferencian los tibbles de los data frames?\n\n\n\nEstructura\n\nLa Sección 3.2 te introduce a los vectores atómicos: lógico, entero, doble y de carácter. Estas son las estructuras de datos más simples de R.\nLa Sección 3.3 toma un pequeño desvío para discutir los atributos, la especificación de metadatos flexibles de R. Los atributos más importantes son los nombres, las dimensiones y la clase.\nLa Sección 3.4 analiza los tipos de vectores importantes que se construyen combinando vectores atómicos con atributos especiales. Estos incluyen factores, fechas, fechas-horas y duraciones.\nLa Sección 3.5 se sumerge en las listas. Las listas son muy similares a los vectores atómicos, pero tienen una diferencia clave: un elemento de una lista puede ser cualquier tipo de datos, incluida otra lista. Esto los hace adecuados para representar datos jerárquicos.\nLa Sección 3.6 te enseña sobre data frames y tibbles, que se utilizan para representar datos rectangulares. Combinan el comportamiento de listas y matrices para crear una estructura ideal para las necesidades de los datos estadísticos.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#sec-atomic-vectors",
    "href": "Vectors.html#sec-atomic-vectors",
    "title": "3  Vectores",
    "section": "3.2 Vectores atómicos",
    "text": "3.2 Vectores atómicos\n \nHay cuatro tipos principales de vectores atómicos: lógico, entero, doble y carácter (que contiene cadenas). En conjunto, los vectores enteros y dobles se conocen como vectores numéricos 3. Hay dos tipos raros: complejos y crudos. No los discutiré más porque los números complejos rara vez se necesitan en las estadísticas, y los vectores sin procesar son un tipo especial que solo se necesita cuando se manejan datos binarios.\n\n\n\n\n\n\n\n\n\n\n3.2.1 Escalares\n \nCada uno de los cuatro tipos principales tiene una sintaxis especial para crear un valor individual, también conocido como escalar4:\n\nLos lógicos se pueden escribir completos (TRUE o FALSE) o abreviados (T o F).\nLos dobles se pueden especificar en formato decimal (0.1234), científico (1.23e4) o hexadecimal (0xcafe). Hay tres valores especiales únicos para los dobles: Inf, -Inf y NaN (no es un número). Estos son valores especiales definidos por el estándar de punto flotante.\nLos enteros se escriben de forma similar a los dobles, pero deben ir seguidos de L5 (1234L, 1e4L o 0xcafeL), y no pueden contener valores fraccionarios.\nLas cadenas están rodeadas por \" (\"hola\") o ' ('adiós'). Los caracteres especiales se escapan con \\; consulte ?Quotes para obtener detalles completos.\n\n\n\n3.2.2 Crear vectores más largos con c()\nPara crear vectores más largos a partir de otros más cortos, use c(), abreviatura de combinar:\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\nCuando las entradas son vectores atómicos, c() siempre crea otro vector atómico; es decir, se aplana:\n\nc(c(1, 2), c(3, 4))\n#&gt; [1] 1 2 3 4\n\nEn los diagramas, representaré los vectores como rectángulos conectados, por lo que el código anterior podría dibujarse de la siguiente manera:\n\n\n\n\n\n\n\n\n\nPuedes determinar el tipo de un vector con typeof()6 y su longitud con length().\n\ntypeof(lgl_var)\n#&gt; [1] \"logical\"\ntypeof(int_var)\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n#&gt; [1] \"double\"\ntypeof(chr_var)\n#&gt; [1] \"character\"\n\n\n\n3.2.3 Valores Faltantes\n\nR representa valores faltantes o desconocidos, con un valor centinela especial: NA (abreviatura de no aplicable). Los valores faltantes tienden a ser infecciosos: la mayoría de los cálculos que involucran un valor faltante devolverán otro valor faltante.\n\nNA &gt; 5\n#&gt; [1] NA\n10 * NA\n#&gt; [1] NA\n!NA\n#&gt; [1] NA\n\nSólo hay unas pocas excepciones a esta regla. Estos ocurren cuando alguna identidad se mantiene para todas las entradas posibles:\n\nNA ^ 0\n#&gt; [1] 1\nNA | TRUE\n#&gt; [1] TRUE\nNA & FALSE\n#&gt; [1] FALSE\n\nLa propagación de faltantes conduce a un error común al determinar qué valores faltan en un vector:\n\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n#&gt; [1] NA NA NA NA\n\nEste resultado es correcto (aunque un poco sorprendente) porque no hay motivo para creer que un valor faltante tiene el mismo valor que otro. En su lugar, use is.na() para probar la presencia de ausencias:\n\nis.na(x)\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\nNB: Técnicamente, hay cuatro valores faltantes7, uno para cada uno de los tipos atómicos: NA (lógico), NA_integer_ (entero), NA_real_ (doble) y NA_character_ (carácter). Esta distinción generalmente no es importante porque ‘NA’ será forzado automáticamente al tipo correcto cuando sea necesario.\n\n\n3.2.4 Pruebas y coerción\n \nEn general, puede probar si un vector es de un tipo dado con una función is.*(), pero estas funciones deben usarse con cuidado. is.logical(), is.integer(), is.double() y is.character() hacen lo que cabría esperar: prueban si un vector es un carácter, doble, entero o lógico. Evite is.vector(), is.atomic() y is.numeric(): no comprueban si tiene un vector, un vector atómico o un vector numérico; deberá leer detenidamente la documentación para descubrir qué es lo que realmente hacen.\nPara los vectores atómicos, el tipo es una propiedad de todo el vector: todos los elementos deben ser del mismo tipo. Cuando intente combinar diferentes tipos, se coaccionarán en un orden fijo: carácter → doble → entero → lógico. Por ejemplo, la combinación de un carácter y un número entero produce un carácter:\n\nstr(c(\"a\", 1))\n#&gt;  chr [1:2] \"a\" \"1\"\n\nLa coerción a menudo ocurre automáticamente. La mayoría de las funciones matemáticas (+, log, abs, etc.) se convertirán en numéricas. Esta coerción es particularmente útil para vectores lógicos porque TRUE se convierte en 1 y FALSE se convierte en 0.\n\nx &lt;- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n#&gt; [1] 0 0 1\n\n# Número total de VERDADEROS\nsum(x)\n#&gt; [1] 1\n\n# Proporción que son VERDADERAS\nmean(x)\n#&gt; [1] 0.333\n\nEn general, puede forzar deliberadamente usando una función as.*(), como as.logical(), as.integer(), as.double() o as.character(). La coerción fallida de cadenas genera una advertencia y un valor faltante:\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\n3.2.5 Ejercicios\n\n¿Cómo se crean escalares crudos y complejos? (Ver ?raw y ?complex.)\nPon a prueba tu conocimiento de las reglas de coerción de vectores prediciendo el resultado de los siguientes usos de c():\n\nc(1, FALSE)\nc(\"a\", 1)\nc(TRUE, 1L)\n\n¿Por qué 1 == \"1\" es verdadero? ¿Por qué -1 &lt; FALSE es verdadero? ¿Por qué \"one\" &lt; 2 es falso?\n¿Por qué el valor faltante predeterminado, NA, es un vector lógico? ¿Qué tienen de especial los vectores lógicos? (Pista: piensa en c(FALSE, NA_character_).)\nPrecisamente, ¿qué prueban is.atomic(), is.numeric() y is.vector()?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#sec-attributes",
    "href": "Vectors.html#sec-attributes",
    "title": "3  Vectores",
    "section": "3.3 Atributos",
    "text": "3.3 Atributos\n\nEs posible que haya notado que el conjunto de vectores atómicos no incluye una serie de estructuras de datos importantes como matrices, arreglos, factores o fechas y horas. Estos tipos se construyen sobre vectores atómicos agregando atributos. En esta sección, aprenderá los conceptos básicos de los atributos y cómo el atributo dim crea matrices y arreglos. En la siguiente sección, aprenderá cómo se usa el atributo de clase para crear vectores de S3, incluidos factores, fechas y fechas y horas.\n\n3.3.1 Conseguir y configurar\n\n \nPuede pensar en los atributos como pares de nombre-valor 8 que adjuntan metadatos a un objeto. Los atributos individuales pueden recuperarse y modificarse con attr(), o recuperarse en masa con attributes(), y establecerse en masa con structure().\n\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n\n\n\n\n\n\n\n\nEn general, los atributos deben considerarse efímeros. Por ejemplo, la mayoría de los atributos se pierden en la mayoría de las operaciones:\n\nattributes(a[1])\n#&gt; NULL\nattributes(sum(a))\n#&gt; NULL\n\nSolo hay dos atributos que se conservan de forma rutinaria:\n\nnames, un vector de caracteres que da a cada elemento un nombre.\ndim, abreviatura de dimensiones, un vector entero, que se utiliza para convertir vectores en matrices o arreglos.\n\nPara conservar otros atributos, deberá crear su propia clase S3, el tema del Capítulo 13.\n\n\n3.3.2 Nombres\n \nPuede nombrar un vector de tres maneras:\n\n# Cuando lo crea: \nx &lt;- c(a = 1, b = 2, c = 3)\n\n# Al asignar un vector de caracteres a names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# En línea con setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\nEvite usar attr(x, \"names\") ya que requiere escribir más y es menos legible que names(x). Puede eliminar nombres de un vector usando x &lt;- unname(x) o names(x) &lt;- NULL.\nPara ser técnicamente correcto, al dibujar el vector nombrado x, debería dibujarlo así:\n\n\n\n\n\n\n\n\n\nSin embargo, los nombres son tan especiales e importantes que, a menos que intente llamar la atención específicamente sobre la estructura de datos de los atributos, los usaré para etiquetar el vector directamente:\n\n\n\n\n\n\n\n\n\nPara que sea útil con subconjuntos de caracteres (p. ej., la Sección 4.5.1), los nombres deben ser únicos y no faltantes, pero R no impone esto. Dependiendo de cómo se establezcan los nombres, los nombres faltantes pueden ser \"\" o NA_character_. Si faltan todos los nombres, names() devolverá NULL.\n\n\n3.3.3 Dimensiones\n \nAgregar un atributo dim a un vector le permite comportarse como una matriz bidimensional o una matriz multidimensional. Las matrices y los arreglos son principalmente herramientas matemáticas y estadísticas, no herramientas de programación, por lo que se usarán con poca frecuencia y solo se tratarán brevemente en este libro. Su característica más importante es el subconjunto multidimensional, que se trata en la Sección 4.2.3.\nPuede crear matrices y arreglos con matrix() y array(), o usando el formulario de asignación de dim():\n\n# Dos argumentos escalares especifican tamaños de fila y columna\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n# Un argumento vectorial para describir todas las dimensiones\ny &lt;- array(1:12, c(2, 3, 2))\ny\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# También puede modificar un objeto en su lugar configurando dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\nMuchas de las funciones para trabajar con vectores tienen generalizaciones para matrices y arreglos:\n\n\n\nVector\nMatriz\nArreglo\n\n\n\n\nnames()\nrownames(), colnames()\ndimnames()\n\n\nlength()\nnrow(), ncol()\ndim()\n\n\nc()\nrbind(), cbind()\nabind::abind()\n\n\n—\nt()\naperm()\n\n\nis.null(dim(x))\nis.matrix()\nis.array()\n\n\n\nUn vector sin un conjunto de atributos “dim” a menudo se considera unidimensional, pero en realidad tiene dimensiones NULL. También puede tener matrices con una sola fila o una sola columna, o arreglos con una sola dimensión. Pueden imprimir de manera similar, pero se comportarán de manera diferente. Las diferencias no son demasiado importantes, pero es útil saber que existen en caso de que obtenga un resultado extraño de una función (tapply() es un infractor frecuente). Como siempre, usa str() para revelar las diferencias.\n\nstr(1:3)                   # 1d vector\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\n3.3.4 Ejercicios\n\n¿Cómo se implementa setNames()? ¿Cómo se implementa unname()? Lee el código fuente.\n¿Qué devuelve dim() cuando se aplica a un vector unidimensional? ¿Cuándo podría usar NROW() o NCOL()?\n¿Cómo describirías los siguientes tres objetos? ¿Qué los hace diferentes de 1:5?\n\nx1 &lt;- array(1:5, c(1, 1, 5))\nx2 &lt;- array(1:5, c(1, 5, 1))\nx3 &lt;- array(1:5, c(5, 1, 1))\n\nUn borrador inicial usó este código para ilustrar structure():\n\nstructure(1:5, comment = \"my attribute\")\n#&gt; [1] 1 2 3 4 5\n\nPero cuando imprime ese objeto, no ve el atributo de comentario. ¿Por qué? ¿Falta el atributo o hay algo más especial en él? (Sugerencia: intente usar la ayuda).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#sec-s3-atomic-vectors",
    "href": "Vectors.html#sec-s3-atomic-vectors",
    "title": "3  Vectores",
    "section": "3.4 Vectores atómicos S3",
    "text": "3.4 Vectores atómicos S3\n \nUno de los atributos vectoriales más importantes es la clase, que subyace en el sistema de objetos S3. Tener un atributo de clase convierte un objeto en un objeto S3, lo que significa que se comportará de manera diferente a un vector regular cuando se pasa a una función genérica. Cada objeto de S3 se crea sobre un tipo base y, a menudo, almacena información adicional en otros atributos. Aprenderá los detalles del sistema de objetos de S3 y cómo crear sus propias clases de S3 en el Capítulo 13.\nEn esta sección, analizaremos cuatro vectores S3 importantes que se utilizan en la base R:\n\nDatos categóricos, donde los valores provienen de un conjunto fijo de niveles registrados en vectores de factores.\nFechas (con resolución de día), que se registran en vectores Fecha.\nFechas-horas (con resolución de segundos o subsegundos), que se almacenan en vectores POSIXct.\nDuraciones, que se almacenan en vectores difftime.\n\n\n\n\n\n\n\n\n\n\n\n3.4.1 Factores\nUn factor es un vector que solo puede contener valores predefinidos. Se utiliza para almacenar datos categóricos. Los factores se construyen sobre un vector entero con dos atributos: una class, “factor”, que hace que se comporte de manera diferente a los vectores enteros normales, y levels, que define el conjunto de valores permitidos.\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n#&gt; [1] \"integer\"\nattributes(x)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n\n\n\n\n\n\n\n\n\nLos factores son útiles cuando conoce el conjunto de valores posibles, pero no todos están presentes en un conjunto de datos determinado. A diferencia de un vector de caracteres, cuando tabula un factor obtendrá recuentos de todas las categorías, incluso las no observadas:\n\nsex_char &lt;- c(\"m\", \"m\", \"m\")\nsex_factor &lt;- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n#&gt; sex_char\n#&gt; m \n#&gt; 3\ntable(sex_factor)\n#&gt; sex_factor\n#&gt; m f \n#&gt; 3 0\n\nLos factores ordenados son una variación menor de los factores. En general, se comportan como factores regulares, pero el orden de los niveles es significativo (bajo, medio, alto) (una propiedad que algunas funciones de modelado y visualización aprovechan automáticamente).\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nEn base R9, tiende a encontrar factores con mucha frecuencia porque muchas funciones de base R (como read.csv() y data.frame()) convierten automáticamente los vectores de caracteres en factores. Esto es subóptimo porque no hay forma de que esas funciones conozcan el conjunto de todos los niveles posibles o su orden correcto: los niveles son una propiedad de la teoría o el diseño experimental, no de los datos. En su lugar, utilice el argumento stringsAsFactors = FALSE para suprimir este comportamiento y luego convierta manualmente los vectores de caracteres en factores usando su conocimiento de los datos “teóricos”. Para conocer el contexto histórico de este comportamiento, recomiendo stringsAsFactors: Una biografía no autorizada de Roger Peng, y stringsAsFactors = &lt;sigh&gt; de Thomas Lumley.\nSi bien los factores se ven (y a menudo se comportan como) vectores de caracteres, se construyen sobre números enteros. Así que tenga cuidado al tratarlos como cadenas. Algunos métodos de cadena (como gsub() y grepl()) forzarán automáticamente los factores a cadenas, otros (como nchar()) generarán un error y otros (como c()) usarán los valores enteros subyacentes. Por esta razón, normalmente es mejor convertir explícitamente los factores en vectores de caracteres si necesita un comportamiento similar al de una cadena.\n\n\n3.4.2 Fechas\n\nLos vectores de fecha se construyen sobre vectores dobles. Tienen clase “Date” y ningún otro atributo:\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n#&gt; [1] \"double\"\nattributes(today)\n#&gt; $class\n#&gt; [1] \"Date\"\n\nEl valor del doble (que se puede ver quitando la clase), representa el número de días desde 1970-01-0110:\n\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n#&gt; [1] 31\n\n\n\n3.4.3 Fecha-Hora\n \nBase R11 proporciona dos formas de almacenar información de fecha y hora, POSIXct y POSIXlt. Estos son nombres ciertamente extraños: “POSIX” es la abreviatura de Portable Operating System Interface, que es una familia de estándares multiplataforma. “ct” representa la hora del calendario (el tipo time_t en C), y “lt” la hora local (el tipo struct tm en C). Aquí nos centraremos en POSIXct, porque es el más simple, está construido sobre un vector atómico y es más apropiado para usar en tramas de datos. Los vectores POSIXct se construyen sobre vectores dobles, donde el valor representa la cantidad de segundos desde 1970-01-01.\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n#&gt; [1] \"double\"\nattributes(now_ct)\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\nEl atributo tzone controla solo cómo se formatea la fecha y la hora; no controla el instante de tiempo representado por el vector. Tenga en cuenta que la hora no se imprime si es medianoche.\n\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n#&gt; [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n#&gt; [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n#&gt; [1] \"2018-08-02 CEST\"\n\n\n\n3.4.4 Duraciones\n \nLas duraciones, que representan la cantidad de tiempo entre pares de fechas o fechas-horas, se almacenan en difftimes. Los tiempos de diferencia se construyen sobre los dobles y tienen un atributo de unidades que determina cómo se debe interpretar el número entero:\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n#&gt; [1] \"double\"\nattributes(one_week_1)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n#&gt; [1] \"double\"\nattributes(one_week_2)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\n3.4.5 Ejercicios\n\n¿Qué tipo de objeto devuelve table()? ¿Cuál es su tipo? ¿Qué atributos tiene? ¿Cómo cambia la dimensionalidad a medida que tabula más variables?\n¿Qué le sucede a un factor cuando modificas sus niveles?\n\nf1 &lt;- factor(letters)\nlevels(f1) &lt;- rev(levels(f1))\n\n¿Qué hace este código? ¿En qué se diferencian f2 y f3 de f1?\n\nf2 &lt;- rev(factor(letters))\n\nf3 &lt;- factor(letters, levels = rev(letters))",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#sec-lists",
    "href": "Vectors.html#sec-lists",
    "title": "3  Vectores",
    "section": "3.5 Listas",
    "text": "3.5 Listas\n \nLas listas son un paso más en complejidad que los vectores atómicos: cada elemento puede ser de cualquier tipo, no solo vectores. Técnicamente hablando, cada elemento de una lista es en realidad del mismo tipo porque, como viste en la Sección 2.3.3, cada elemento es realmente una referencia a otro objeto, que puede ser de cualquier tipo.\n\n3.5.1 Creando\n\nConstruyes listas con list():\n\nl1 &lt;- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n#&gt; [1] \"list\"\n\nstr(l1)\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\nDado que los elementos de una lista son referencias, crear una lista no implica copiar los componentes en la lista. Por esta razón, el tamaño total de una lista puede ser más pequeño de lo esperado.\n\nlobstr::obj_size(mtcars)\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n#&gt; 7.29 kB\n\nLas listas pueden contener objetos complejos, por lo que no es posible elegir un único estilo visual que funcione para todas las listas. En general, dibujaré listas como vectores, usando colores para recordarle la jerarquía.\n\n\n\n\n\n\n\n\n\nLas listas a veces se denominan vectores recursivos porque una lista puede contener otras listas. Esto los hace fundamentalmente diferentes de los vectores atómicos.\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\n\n\n\n\n\n\n\n\n\nc() combinará varias listas en una sola. Si se le da una combinación de vectores atómicos y listas, c() convertirá los vectores en listas antes de combinarlos. Compara los resultados de list() y c():\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\n\n\n\n\n\n\n\n\n\n\n\n3.5.2 Pruebas y coerción\nEl typeof() una lista es list. Puede probar una lista con is.list() y obligar a una lista con as.list().\n\nlist(1:3)\n#&gt; [[1]]\n#&gt; [1] 1 2 3\nas.list(1:3)\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\nPuedes convertir una lista en un vector atómico con unlist(). Las reglas para el tipo resultante son complejas, no están bien documentadas y no siempre son equivalentes a lo que obtendría con c().\n\n\n3.5.3 Matrices y arreglos\n \nCon vectores atómicos, el atributo de dimensión se usa comúnmente para crear matrices. Con las listas, el atributo de dimensión se puede usar para crear matrices de listas o arreglos de listas:\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n#&gt; [1] 1 2 3\n\nEstas estructuras de datos son relativamente esotéricas, pero pueden ser útiles si desea organizar objetos en una estructura similar a una cuadrícula. Por ejemplo, si está ejecutando modelos en una cuadrícula espacio-temporal, podría ser más intuitivo almacenar los modelos en una matriz 3D que coincida con la estructura de la cuadrícula.\n\n\n3.5.4 Ejercicios\n\nEnumere todas las formas en que una lista difiere de un vector atómico.\n¿Por qué necesita usar unlist() para convertir una lista en un vector atómico? ¿Por qué no funciona as.vector()?\nCompare y contraste c() y unlist() al combinar una fecha y una fecha y hora en un solo vector.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#sec-tibble",
    "href": "Vectors.html#sec-tibble",
    "title": "3  Vectores",
    "section": "3.6 Data frames y tibbles",
    "text": "3.6 Data frames y tibbles\n \nLos dos vectores S3 más importantes construidos sobre las listas son los data frames y los tibbles.\n\n\n\n\n\n\n\n\n\nSi realiza análisis de datos en R, utilizará data frames. Un data frame es una lista con nombre de vectores con atributos para (columna) nombres, fila.nombres 12, y su clase, “data.frame”:\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n#&gt; [1] \"list\"\n\nattributes(df1)\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nA diferencia de una lista regular, un data frame tiene una restricción adicional: la longitud de cada uno de sus vectores debe ser la misma. Esto le da a los data frames su estructura rectangular y explica por qué comparten las propiedades de las matrices y las listas:\n\nUn data frame tiene rownames()13 y colnames(). Los names() de un data frame son los nombres de las columnas.\nUn data frame tiene filas nrow() y columnas ncol(). La longitud() de un data frame da el número de columnas.\n\nLos data frames son una de las ideas más grandes e importantes de R, y una de las cosas que diferencian a R de otros lenguajes de programación. Sin embargo, en los más de 20 años desde su creación, las formas en que las personas usan R han cambiado y algunas de las decisiones de diseño que tenían sentido en el momento en que se crearon los data frames ahora causan frustración.\nEsta frustración condujo a la creación del tibble (Müller y Wickham 2018), una reinvención moderna del data frame. Los Tibbles están diseñados para ser (en la medida de lo posible) reemplazos directos de los data frames que solucionan esas frustraciones. Una forma concisa y divertida de resumir las principales diferencias es que los tibbles son vagos y hoscos: hacen menos y se quejan más. Verá lo que eso significa a medida que avance en esta sección.\nLos tibbles son proporcionados por el paquete tibble y comparten la misma estructura que los data frames. La única diferencia es que el vector de clase es más largo e incluye tbl_df. Esto permite que los tibbles se comporten de manera diferente en las formas clave que discutiremos a continuación.\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#&gt; [1] \"list\"\n\nattributes(df2)\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\n\n3.6.1 Creando\n\n\nCreas un data frame proporcionando pares de vector de nombre a data.frame():\n\ndf &lt;- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nSi está utilizando una versión de R anterior a la 4.0.0, tenga cuidado con la conversión predeterminada de cadenas a factores. Use stringsAsFactors = FALSE para suprimir esto y mantener los vectores de caracteres como vectores de caracteres:\n\ndf1 &lt;- data.frame(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\nstr(df1)\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\nCrear un tibble es similar a crear un data frame. La diferencia entre los dos es que los tibbles nunca coaccionan su entrada (esta es una característica que los hace perezosos):\n\ndf2 &lt;- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\nAdemás, mientras que los data frames transforman automáticamente los nombres no sintácticos (a menos que check.names = FALSE), los tibbles no lo hacen (aunque sí imprimen nombres no sintácticos rodeados por `).\n\nnames(data.frame(`1` = 1))\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n#&gt; [1] \"1\"\n\nSi bien cada elemento de un data frame (o tibble) debe tener la misma longitud, tanto data.frame() como tibble() reciclarán entradas más cortas. Sin embargo, mientras que los data frames reciclan automáticamente las columnas que son múltiplos enteros de la columna más larga, los tibbles solo reciclan vectores de longitud uno.\n\ndata.frame(x = 1:4, y = 1:2)\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\ndata.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\ntibble(x = 1:4, y = 1:2)\n#&gt; Error in `tibble()`:\n#&gt; ! Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\nHay una última diferencia: tibble() te permite referirte a las variables creadas durante la construcción:\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\n(Las entradas se evalúan de izquierda a derecha).\nAl dibujar data frames y tibbles, en lugar de centrarse en los detalles de implementación, es decir, los atributos:\n\n\n\n\n\n\n\n\n\nLos dibujaré de la misma manera que una lista con nombre, pero los ordenaré para enfatizar su estructura en columnas.\n\n\n\n\n\n\n\n\n\n\n\n3.6.2 Nombres de filas\n\nLos data frames le permiten etiquetar cada fila con un nombre, un vector de caracteres que contiene solo valores únicos:\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\nPuede obtener y establecer nombres de fila con rownames(), y puede usarlos para crear subconjuntos de filas:\n\nrownames(df3)\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\nLos nombres de las filas surgen naturalmente si piensa en los data frames como estructuras 2D como matrices: las columnas (variables) tienen nombres, por lo que las filas (observaciones) también deberían tenerlos. La mayoría de las matrices son numéricas, por lo que es importante tener un lugar para almacenar etiquetas de caracteres. Pero esta analogía con las matrices es engañosa porque las matrices poseen una propiedad importante que los data frames no tienen: son transponibles. En las matrices, las filas y las columnas son intercambiables, y la transposición de una matriz da como resultado otra matriz (la transposición nuevamente da como resultado la matriz original). Sin embargo, con los data frames, las filas y las columnas no son intercambiables: la transposición de un data frame no es un data frame.\nHay tres razones por las que los nombres de las filas no son deseables:\n\nLos metadatos son datos, por lo que almacenarlos de manera diferente al resto de los datos es fundamentalmente una mala idea. También significa que necesita aprender un nuevo conjunto de herramientas para trabajar con nombres de fila; no puede usar lo que ya sabe sobre la manipulación de columnas.\nLos nombres de fila son una abstracción deficiente para etiquetar filas porque solo funcionan cuando una fila se puede identificar con una sola cadena. Esto falla en muchos casos, por ejemplo, cuando desea identificar una fila por un vector que no es un carácter (por ejemplo, un punto de tiempo), o con múltiples vectores (por ejemplo, posición, codificado por latitud y longitud).\nLos nombres de las filas deben ser únicos, por lo que cualquier duplicación de filas (por ejemplo, de arranque) creará nuevos nombres de fila. Si desea hacer coincidir las filas de antes y después de la transformación, deberá realizar una complicada cirugía de hilo.\n\ndf3[c(1, 1, 1), ]\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Bob.1  35 blond\n#&gt; Bob.2  35 blond\n\n\nPor estas razones, los tibbles no admiten nombres de fila. En cambio, el paquete tibble proporciona herramientas para convertir fácilmente los nombres de las filas en una columna regular con rownames_to_column(), o el argumento rownames en as_tibble():\n\nas_tibble(df3, rownames = \"name\")\n#&gt; # A tibble: 3 × 3\n#&gt;   name    age hair \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bob      35 blond\n#&gt; 2 Susan    27 brown\n#&gt; 3 Sam      18 black\n\n\n\n3.6.3 Imprimir\nUna de las diferencias más obvias entre tibbles y data frames es cómo se imprimen. Supongo que ya está familiarizado con la forma en que se imprimen los data frames, por lo que aquí resaltaré algunas de las mayores diferencias utilizando un conjunto de datos de ejemplo incluido en el paquete dplyr:\n\ndplyr::starwars\n#&gt; # A tibble: 87 × 14\n#&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender\n#&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n#&gt;  1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…\n#&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu…\n#&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl… red             33   none  mascu…\n#&gt;  4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…\n#&gt;  5 Leia Or…    150    49 brown      light      brown           19   fema… femin…\n#&gt;  6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…\n#&gt;  7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…\n#&gt;  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu…\n#&gt;  9 Biggs D…    183    84 black      light      brown           24   male  mascu…\n#&gt; 10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…\n#&gt; # ℹ 77 more rows\n#&gt; # ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\nTibbles solo muestra las primeras 10 filas y todas las columnas que caben en la pantalla. Las columnas adicionales se muestran en la parte inferior.\nCada columna está etiquetada con su tipo, abreviado en tres o cuatro letras.\nLas columnas anchas se truncan para evitar que una sola cadena larga ocupe una fila completa. (Esto todavía es un trabajo en progreso: es un compromiso complicado entre mostrar tantas columnas como sea posible y mostrar las columnas en su totalidad).\nCuando se usa en entornos de consola que lo admiten, el color se usa juiciosamente para resaltar información importante y restar énfasis a los detalles complementarios.\n\n\n\n3.6.4 Subconjunto\nComo aprenderá en el Capítulo 4, puede crear un subconjunto de un data frame o un tibble como una estructura 1D (donde se comporta como una lista), o una estructura 2D (donde se comporta como una matriz).\nEn mi opinión, los data frames tienen dos comportamientos de subconjunto no deseados:\n\nCuando crea subconjuntos de columnas con df[, vars], obtendrá un vector si vars selecciona una variable; de lo contrario, obtendrá un data frame. Esta es una fuente frecuente de errores cuando se usa [ en una función, a menos que siempre recuerde usar df[, vars, drop = FALSE].\nCuando intenta extraer una sola columna con df$x y no hay ninguna columna x, un data frame seleccionará cualquier variable que comience con x. Si ninguna variable comienza con x, df$x devolverá NULL. Esto facilita seleccionar la variable incorrecta o seleccionar una variable que no existe14.\n\nTibbles modifica estos comportamientos para que un [ siempre devuelva un tibble, y un $ no haga coincidencias parciales y advierta si no puede encontrar una variable (esto es lo que hace que Tibbles sea hosco).\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n#&gt;  chr \"a\"\nstr(df2$x)\n#&gt; Warning: Unknown or uninitialised column: `x`.\n#&gt;  NULL\n\nLa insistencia de un tibble en devolver un data frame de [ puede causar problemas con el código heredado, que a menudo usa df[, \"col\"] para extraer una sola columna. Si desea una sola columna, le recomiendo usar df[[\"col\"]]. Esto comunica claramente su intención y funciona tanto con data frames como con tibbles.\n\n\n3.6.5 Pruebas y coacción\nPara verificar si un objeto es un data frame o tibble, use is.data.frame():\n\nis.data.frame(df1)\n#&gt; [1] TRUE\nis.data.frame(df2)\n#&gt; [1] TRUE\n\nPor lo general, no debería importar si tiene un tibble o un data frame, pero si necesita estar seguro, use is_tibble():\n\nis_tibble(df1)\n#&gt; [1] FALSE\nis_tibble(df2)\n#&gt; [1] TRUE\n\nPuede convertir un objeto en un data frame con as.data.frame() o en un tibble con as_tibble().\n\n\n3.6.6 Columnas de lista\n \nDado que un data frame es una lista de vectores, es posible que un data frame tenga una columna que sea una lista. Esto es muy útil porque una lista puede contener cualquier otro objeto: esto significa que puede colocar cualquier objeto en un data frame. Esto le permite mantener los objetos relacionados juntos en una fila, sin importar cuán complejos sean los objetos individuales. Puede ver una aplicación de esto en el capítulo “Muchos modelos” de R para la Ciencia de Datos, http://r4ds.had.co.nz/many-models.html.\nLas columnas de lista están permitidas en data frames, pero debe hacer un poco de trabajo adicional agregando la columna de lista después de la creación o envolviendo la lista en I()15.\n\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\n\n\n\n\n\n\n\n\n\nLas columnas de lista son más fáciles de usar con tibbles porque se pueden incluir directamente dentro de tibble() y se imprimirán ordenadamente:\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\n\n\n3.6.7 Columnas de matriz y data frame\n\nSiempre que el número de filas coincida con el data frame, también es posible tener una matriz o arreglo como columna de un data frame. (Esto requiere una ligera extensión a nuestra definición de data frame: no es la longitud, length(), de cada columna lo que debe ser igual, sino el NROW().) En cuanto a las columnas de lista, debe agregarlas después de la creación o envolverlas en I().\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n\n\n\n\n\n\n\n\nLas columnas de matrices y data frames requieren un poco de precaución. Muchas funciones que trabajan con data frames asumen que todas las columnas son vectores. Además, la pantalla impresa puede resultar confusa.\n\ndfm[1, ]\n#&gt;    x y.1 y.2 y.3 z.a z.b\n#&gt; 1 10   1   4   7   3   a\n\n\n\n3.6.8 Ejercicios\n\n¿Puede tener un data frame con cero filas? ¿Qué pasa con las columnas cero?\n¿Qué sucede si intenta establecer nombres de fila que no son únicos?\nSi df es un data frame, ¿qué puede decir acerca de t(df) y t(t(df))? Realice algunos experimentos, asegurándose de probar diferentes tipos de columnas.\n¿Qué hace as.matrix() cuando se aplica a un data frame con columnas de diferentes tipos? ¿En qué se diferencia de data.matrix()?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#null",
    "href": "Vectors.html#null",
    "title": "3  Vectores",
    "section": "3.7 NULL",
    "text": "3.7 NULL\n\nPara terminar este capítulo, quiero hablar sobre una última estructura de datos importante que está estrechamente relacionada con los vectores: NULL. NULL es especial porque tiene un tipo único, siempre tiene una longitud cero y no puede tener ningún atributo:\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n#&gt; [1] 0\n\nx &lt;- NULL\nattr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL\n\nPuedes probar NULLs con is.null():\n\nis.null(NULL)\n#&gt; [1] TRUE\n\nHay dos usos comunes de NULL:\n\nRepresentar un vector vacío (un vector de longitud cero) de tipo arbitrario. Por ejemplo, si usas c() pero no incluyes ningún argumento, obtienes NULL, y concatenar NULL a un vector lo dejará sin cambios:\n\nc()\n#&gt; NULL\n\nPara representar un vector ausente. Por ejemplo, NULL a menudo se usa como argumento de función predeterminado, cuando el argumento es opcional pero el valor predeterminado requiere algún cálculo (consulte la Sección 6.5.3 para obtener más información al respecto). Contraste esto con NA que se usa para indicar que un elemento de un vector está ausente.\n\nSi está familiarizado con SQL, conocerá el NULL relacional y puede esperar que sea igual que el de R. Sin embargo, la base de datos NULL es en realidad equivalente a NA de R.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#sec-data-structure-answers",
    "href": "Vectors.html#sec-data-structure-answers",
    "title": "3  Vectores",
    "section": "3.8 Respuestas de la prueba",
    "text": "3.8 Respuestas de la prueba\n\nLos cuatro tipos comunes de vectores atómicos son lógicos, enteros, dobles y de carácter. Los dos tipos más raros son complejos y crudos.\nLos atributos le permiten asociar metadatos adicionales arbitrarios a cualquier objeto. Puede obtener y establecer atributos individuales con attr(x, \"y\") y attr(x, \"y\") &lt;- value; o puede obtener y establecer todos los atributos a la vez con attributes().\nLos elementos de una lista pueden ser de cualquier tipo (incluso una lista); los elementos de un vector atómico son todos del mismo tipo. De manera similar, todos los elementos de una matriz deben ser del mismo tipo; en un data frame, diferentes columnas pueden tener diferentes tipos.\nPuede crear una matriz de lista asignando dimensiones a una lista. Puede convertir una matriz en una columna de un data frame con df$x &lt;- matrix(), o usando I() al crear un nuevo data frame data.frame(x = I(matrix())).\nLos Tibbles tienen un método de impresión mejorado, nunca obligan a las cadenas a factores y proporcionan métodos de subconjunto más estrictos.\n\n\n\n\n\nGrolemund, Garrett, y Hadley Wickham. 2011. «Dates and Times Made Easy with lubridate». Journal of Statistical Software 40 (3): 1-25. http://www.jstatsoft.org/v40/i03/.\n\n\nMüller, Kirill, y Hadley Wickham. 2018. tibble: simple data frames. http://tibble.tidyverse.org/.\n\n\nWickham, Hadley. 2018. forcats: tools for working with categorical variables. http://forcats.tidyverse.org.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Vectors.html#footnotes",
    "href": "Vectors.html#footnotes",
    "title": "3  Vectores",
    "section": "",
    "text": "En conjunto, todos los demás tipos de datos se conocen como tipos de “nodo”, que incluyen cosas como funciones y entornos. Lo más probable es que te encuentres con este término altamente técnico cuando uses gc(): la “N” en Ncells significa nodos y la “V” en Vcells significa vectores.↩︎\nAlgunos lugares en la documentación de R llaman a listas de vectores genéricos para enfatizar su diferencia con los vectores atómicos.↩︎\nEsta es una ligera simplificación ya que R no usa “numérico” de manera consistente, a lo que volveremos en la Sección 12.3.1.↩︎\nTécnicamente, el lenguaje R no posee escalares. Todo lo que parece un escalar es en realidad un vector de longitud uno. Esta es principalmente una distinción teórica, pero significa que expresiones como 1[1] funcionan.↩︎\nL no es intuitivo, y puede que te preguntes de dónde viene. En el momento en que se agregó L a R, el tipo de entero de R era equivalente a un entero largo en C, y el código C podía usar un sufijo de l o L para obligar a un número a ser un entero largo. Se decidió que l era demasiado similar visualmente a i (usado para números complejos en R), dejando L.↩︎\nEs posible que haya oído hablar de las funciones mode() y storage.mode() relacionadas. No los uses: existen solo por compatibilidad con S.↩︎\nBueno, técnicamente, cinco si incluimos NA_complex_, pero ignoramos este tipo “raro”, como se mencionó anteriormente.↩︎\nLos atributos se comportan como listas con nombre, pero en realidad son listas de pares. Las listas de pares son funcionalmente indistinguibles de las listas, pero son profundamente diferentes bajo el capó. Aprenderá más sobre ellos en la Sección 18.6.1.↩︎\nEl tidyverse nunca fuerza automáticamente a los personajes a factores, y proporciona el paquete forcats (Wickham 2018) específicamente para trabajar con factores.↩︎\nEsta fecha especial se conoce como la Época Unix.↩︎\ntidyverse proporciona el paquete lubridate (Grolemund y Wickham 2011) para trabajar con fechas y horas. Proporciona una serie de útiles ayudantes que funcionan con el tipo POSIXct base.↩︎\nLos nombres de fila son una de las estructuras de datos más sorprendentemente complejas en R. También han sido una fuente persistente de problemas de rendimiento a lo largo de los años. La implementación más sencilla es un vector de caracteres o entero, con un elemento para cada fila. Pero también hay una representación compacta para nombres de fila “automáticos” (enteros consecutivos), creada por .set_row_names(). R 3.5 tiene una forma especial de diferir la conversión de enteros a caracteres que está diseñada específicamente para acelerar lm(); consulte https://svn.r-project.org/R/branches/ALTREP/ALTREP.html#deferred_string_conversions para obtener detalles.↩︎\ntécnicamente, se recomienda usar row.names(), no rownames() con data frames, pero esta distinción rara vez es importante.↩︎\nPodemos hacer que R advierta sobre este comportamiento (llamado coincidencia parcial) configurando options(warnPartialMatchDollar = TRUE).↩︎\nI() es la abreviatura de identidad y se usa a menudo para indicar que una entrada debe dejarse como está y no transformarse automáticamente.↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectores</span>"
    ]
  },
  {
    "objectID": "Subsetting.html",
    "href": "Subsetting.html",
    "title": "4  Subconjunto",
    "section": "",
    "text": "4.1 Introducción\nLos operadores de subconjuntos de R son rápidos y potentes. Dominarlos le permite realizar operaciones complejas de manera sucinta de una manera que pocos otros idiomas pueden igualar. La creación de subconjuntos en R es fácil de aprender pero difícil de dominar porque necesita interiorizar una serie de conceptos interrelacionados:\nLa creación de subconjuntos es un complemento natural de str(). Mientras que str() le muestra todas las piezas de cualquier objeto (su estructura), la creación de subconjuntos le permite extraer las piezas que le interesan. Para objetos grandes y complejos, recomiendo usar el RStudio Viewer interactivo, que puedes activar con View(my_object).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#introducción",
    "href": "Subsetting.html#introducción",
    "title": "4  Subconjunto",
    "section": "",
    "text": "Hay seis formas de crear subconjuntos de vectores atómicos.\nHay tres operadores de subconjuntos, [[, [ y $.\nLos operadores de creación de subconjuntos interactúan de manera diferente con diferentes tipos de vectores (por ejemplo, vectores atómicos, listas, factores, matrices y data frames).\nLa creación de subconjuntos se puede combinar con la asignación.\n\n\n\nPrueba\nResponda este breve cuestionario para determinar si necesita leer este capítulo. Si las respuestas le vienen a la mente rápidamente, puede saltarse cómodamente este capítulo. Comprueba tus respuestas en la Sección 4.6.\n\n¿Cuál es el resultado de subdividir un vector con enteros positivos, enteros negativos, un vector lógico o un vector de caracteres?\n¿Cuál es la diferencia entre [, [[ y $ cuando se aplica a una lista?\n¿Cuándo debería usar drop = FALSE?\nSi x es una matriz, ¿qué hace x[] &lt;- 0? ¿En qué se diferencia de x &lt;- 0?\n¿Cómo puede usar un vector con nombre para volver a etiquetar variables categóricas?\n\n\n\nEstructura\n\nLa Sección 4.2 comienza enseñándote acerca de [. Aprenderá las seis formas de crear subconjuntos de vectores atómicos. Luego aprenderá cómo actúan esas seis formas cuando se usan para crear subconjuntos de listas, matrices y data frames.\nLa Sección 4.3 amplía su conocimiento de los operadores de subconjuntos para incluir [[ y $ y se centra en los principios importantes de simplificar frente a preservar.\nLa Sección 4.4 aprenderá el arte de la subasignación, que combina subconjuntos y asignación para modificar partes de un objeto.\nLa Sección 4.5 llo guía a través de ocho aplicaciones importantes, pero no obvias, de subconjuntos para resolver problemas que a menudo encuentra en el análisis de datos.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#sec-subset-multiple",
    "href": "Subsetting.html#sec-subset-multiple",
    "title": "4  Subconjunto",
    "section": "4.2 Selección de varios elementos",
    "text": "4.2 Selección de varios elementos\n\nUtilice [ para seleccionar cualquier número de elementos de un vector. Para ilustrar, aplicaré [ a vectores atómicos 1D, y luego mostraré cómo esto se generaliza a objetos más complejos y más dimensiones.\n\n4.2.1 Vectores atómicos\n \nExploremos los diferentes tipos de subconjuntos con un vector simple, x.\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\nTenga en cuenta que el número después del punto decimal representa la posición original en el vector.\nHay seis cosas que puede usar para crear subconjuntos de un vector:\n\nLos enteros positivos devuelven elementos en las posiciones especificadas:\n\nx[c(3, 1)]\n#&gt; [1] 3.3 2.1\nx[order(x)]\n#&gt; [1] 2.1 3.3 4.2 5.4\n\n# Los índices duplicados duplicarán los valores\nx[c(1, 1)]\n#&gt; [1] 2.1 2.1\n\n# Los números reales se truncan silenciosamente a enteros\nx[c(2.1, 2.9)]\n#&gt; [1] 4.2 4.2\n\nLos enteros negativos excluyen elementos en las posiciones especificadas:\n\nx[-c(3, 1)]\n#&gt; [1] 4.2 5.4\n\nTenga en cuenta que no puede mezclar números enteros positivos y negativos en un solo subconjunto:\n\nx[c(-1, 2)]\n#&gt; Error in x[c(-1, 2)]: only 0's may be mixed with negative subscripts\n\nLos vectores lógicos seleccionan elementos donde el valor lógico correspondiente es TRUE. Este es probablemente el tipo de subconjunto más útil porque puede escribir una expresión que usa un vector lógico:\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n#&gt; [1] 4.2 3.3 5.4\n\n En x[y], ¿qué sucede si x e y tienen longitudes diferentes? El comportamiento está controlado por las reglas de reciclaje, donde el más corto de los dos se recicla al largo del más largo. Esto es conveniente y fácil de entender cuando uno de x e y tiene la longitud uno, pero recomiendo evitar el reciclaje para otras longitudes porque las reglas se aplican de manera inconsistente en la base R.\n\nx[c(TRUE, FALSE)]\n#&gt; [1] 2.1 3.3\n# Equivalent to\nx[c(TRUE, FALSE, TRUE, FALSE)]\n#&gt; [1] 2.1 3.3\n\nTenga en cuenta que un valor faltante en el índice siempre produce un valor faltante en la salida:\n\nx[c(TRUE, TRUE, NA, FALSE)]\n#&gt; [1] 2.1 4.2  NA\n\nNada devuelve el vector original. Esto no es útil para vectores 1D, pero, como verá en breve, es muy útil para matrices, data frames y arreglos. También puede ser útil junto con la asignación.\n\nx[]\n#&gt; [1] 2.1 4.2 3.3 5.4\n\nZero devuelve un vector de longitud cero. Esto no es algo que normalmente haga a propósito, pero puede ser útil para generar datos de prueba.\n\nx[0]\n#&gt; numeric(0)\n\nSi el vector tiene nombre, también puede usar vectores de caracteres para devolver elementos con nombres coincidentes.\n\n(y &lt;- setNames(x, letters[1:4]))\n#&gt;   a   b   c   d \n#&gt; 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n#&gt;   d   c   a \n#&gt; 5.4 3.3 2.1\n\n# Al igual que los índices enteros, puede repetir índices\ny[c(\"a\", \"a\", \"a\")]\n#&gt;   a   a   a \n#&gt; 2.1 2.1 2.1\n\n# Al crear un subconjunto con [, los nombres siempre coinciden exactamente\nz &lt;- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA\n\n\nNB: Los factores no se tratan de manera especial cuando se subdividen. Esto significa que la creación de subconjuntos utilizará el vector entero subyacente, no los niveles de caracteres. Esto suele ser inesperado, por lo que debe evitar subconjuntos con factores:\n\ny[factor(\"b\")]\n#&gt;   a \n#&gt; 2.1\n\n\n\n4.2.2 Listas\n \nLa creación de subconjuntos de una lista funciona de la misma manera que la creación de subconjuntos de un vector atómico. Usar [ siempre devuelve una lista; [[ y $, como se describe en la Sección 4.3, le permiten extraer elementos de una lista.\n\n\n4.2.3 Matrices y arreglos\n \nPuede crear subconjuntos de estructuras de dimensiones superiores de tres maneras:\n\nCon múltiples vectores.\nCon un solo vector.\nCon una matriz.\n\nLa forma más común de crear subconjuntos de matrices (2D) y arreglos (&gt;2D) es una generalización simple de subconjuntos 1D: proporcione un índice 1D para cada dimensión, separados por una coma. El subconjunto en blanco ahora es útil porque le permite mantener todas las filas o todas las columnas.\n\na &lt;- matrix(1:9, nrow = 3)\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[1:2, ]\n#&gt;      A B C\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 6 3\na[0, -2]\n#&gt;      A C\n\nPor defecto, [ simplifica los resultados a la dimensionalidad más baja posible. Por ejemplo, las dos expresiones siguientes devuelven vectores 1D. Aprenderá cómo evitar “reducir” el número de dimensiones en la Sección 4.2.5:\n\na[1, ]\n#&gt; A B C \n#&gt; 1 4 7\na[1, 1]\n#&gt; A \n#&gt; 1\n\nDebido a que tanto las matrices como los arreglos son solo vectores con atributos especiales, puede crear subconjuntos con un solo vector, como si fueran un vector 1D. Tenga en cuenta que las matrices en R se almacenan en orden de columna principal:\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n#&gt; [1] \"4,1\" \"5,3\"\n\nTambién puede crear subconjuntos de estructuras de datos de mayor dimensión con una matriz de enteros (o, si se nombra, una matriz de caracteres). Cada fila de la matriz especifica la ubicación de un valor y cada columna corresponde a una dimensión de la matriz. Esto significa que puede usar una matriz de 2 columnas para crear un subconjunto de una matriz, una matriz de 3 columnas para crear un subconjunto de una matriz 3D, etc. El resultado es un vector de valores:\n\nselect &lt;- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nvals[select]\n#&gt; [1] \"1,1\" \"3,1\" \"2,4\"\n\n\n\n4.2.4 Data frames y tibbles\n \nData frames tienen las características tanto de listas como de matrices:\n\nCuando se subdividen con un solo índice, se comportan como listas e indexan las columnas, por lo que df[1:2] selecciona las dos primeras columnas.\nAl crear subconjuntos con dos índices, se comportan como matrices, por lo que df[1:3, ] selecciona las primeras tres filas (y todas las columnas)1.\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n#&gt;   x y z\n#&gt; 2 2 2 b\ndf[c(1, 3), ]\n#&gt;   x y z\n#&gt; 1 1 3 a\n#&gt; 3 3 1 c\n\n# Hay dos formas de seleccionar columnas de un data frame\n# Como una lista\ndf[c(\"x\", \"z\")]\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n# Como una matriz\ndf[, c(\"x\", \"z\")]\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n# Hay una diferencia importante si selecciona una sola \n# columna: el subconjunto de la matriz se simplifica de forma predeterminada, el \n# subconjunto de la lista no\nstr(df[\"x\"])\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\nstr(df[, \"x\"])\n#&gt;  int [1:3] 1 2 3\n\nSubdividir un tibble con [ siempre devuelve un tibble:\n\ndf &lt;- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(df[\"x\"])\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\nstr(df[, \"x\"])\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n\n\n\n4.2.5 Preservando la dimensionalidad\n\n \nDe forma predeterminada, subdividir una matriz o data frame con un solo número, un solo nombre o un vector lógico que contenga un solo TRUE simplificará la salida devuelta, es decir, devolverá un objeto con menor dimensionalidad. Para conservar la dimensionalidad original, debe usar drop = FALSE.\n\nPara matrices y arreglos, se eliminarán todas las dimensiones con longitud 1:\n\na &lt;- matrix(1:4, nrow = 2)\nstr(a[1, ])\n#&gt;  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n#&gt;  int [1, 1:2] 1 3\n\nData frames con una sola columna devolverán solo el contenido de esa columna:\n\ndf &lt;- data.frame(a = 1:2, b = 1:2)\nstr(df[, \"a\"])\n#&gt;  int [1:2] 1 2\n\nstr(df[, \"a\", drop = FALSE])\n#&gt; 'data.frame':    2 obs. of  1 variable:\n#&gt;  $ a: int  1 2\n\n\nEl comportamiento predeterminado drop = TRUE es una fuente común de errores en las funciones: verifica su código con un data frame o matriz con varias columnas, y funciona. Seis meses después, usted (u otra persona) lo usa con un data frame de una sola columna y falla con un error desconcertante. Al escribir funciones, acostúmbrese a usar siempre drop = FALSE al subdividir un objeto 2D. Por esta razón, los tibbles tienen por defecto drop = FALSE, y [ siempre devuelve otro tibble.\nEl subconjunto de factores también tiene un argumento drop, pero su significado es bastante diferente. Controla si se conservan o no los niveles (en lugar de las dimensiones), y su valor predeterminado es FALSE. Si encuentra que está usando drop = TRUE mucho, a menudo es una señal de que debería estar usando un vector de caracteres en lugar de un factor.\n\nz &lt;- factor(c(\"a\", \"b\"))\nz[1]\n#&gt; [1] a\n#&gt; Levels: a b\nz[1, drop = TRUE]\n#&gt; [1] a\n#&gt; Levels: a\n\n\n\n4.2.6 Ejercicios\n\nSolucione cada uno de los siguientes errores comunes de creación de subconjuntos de data frames:\n\nmtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl &lt;= 5]\nmtcars[mtcars$cyl == 4 | 6, ]\n\n¿Por qué el siguiente código arroja cinco valores faltantes? (Pista: ¿por qué es diferente de x[NA_real_]?)\n\nx &lt;- 1:5\nx[NA]\n#&gt; [1] NA NA NA NA NA\n\n¿Qué devuelve upper.tri()? ¿Cómo funciona el subconjunto de una matriz con él? ¿Necesitamos reglas adicionales de creación de subconjuntos para describir su comportamiento?\n\nx &lt;- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]\n\n¿Por qué mtcars[1:20] devuelve un error? ¿En qué se diferencia de los mtcars[1:20, ] similares?\nImplemente su propia función que extraiga las entradas diagonales de una matriz (debería comportarse como diag(x) donde x es una matriz).\n¿Qué hace df[is.na(df)] &lt;- 0? ¿Como funciona?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#sec-subset-single",
    "href": "Subsetting.html#sec-subset-single",
    "title": "4  Subconjunto",
    "section": "4.3 Selección de un solo elemento",
    "text": "4.3 Selección de un solo elemento\n \nHay otros dos operadores de subconjuntos: [[ y $. [[ se usa para extraer elementos individuales, mientras que x$y es una abreviatura útil para x[[\"y\"]].\n\n4.3.1 [[\n\n[[ es más importante cuando se trabaja con listas porque subdividir una lista con [ siempre devuelve una lista más pequeña. Para ayudar a que esto sea más fácil de entender, podemos usar una metáfora:\n\nSi la lista x es un tren que transporta objetos, entonces x[[5]] es el objeto en el vagón 5; x[4:6] es un tren de vagones 4-6.\n— @RLangTip, https://twitter.com/RLangTip/status/268375867468681216\n\nUsemos esta metáfora para hacer una lista simple:\n\nx &lt;- list(1:3, \"a\", 4:6)\n\n\n\n\n\n\n\n\n\n\nAl extraer un solo elemento, tiene dos opciones: puede crear un tren más pequeño, es decir, menos vagones, o puede extraer el contenido de un vagón en particular. Esta es la diferencia entre [ y [[:\n\n\n\n\n\n\n\n\n\nAl extraer elementos múltiples (¡o incluso cero!), debe hacer un tren más pequeño:\n\n\n\n\n\n\n\n\n\nDebido a que [[ solo puede devolver un solo elemento, debe usarlo con un solo entero positivo o una sola cadena. Si usa un vector con [[, se subdividirá recursivamente, es decir, x[[c(1, 2)]] es equivalente a x[[1]][[2]]. Esta es una característica peculiar que pocos conocen, así que recomiendo evitarla en favor de purrr::pluck(), sobre la cual aprenderá en la Sección 4.3.3.\nSi bien debe usar [[ cuando trabaja con listas, también recomendaría usarlo con vectores atómicos siempre que desee extraer un solo valor. Por ejemplo, en lugar de escribir:\n\nfor (i in 2:length(x)) {\n  out[i] &lt;- fun(x[i], out[i - 1])\n}\n\nEs mejor escribir:\n\nfor (i in 2:length(x)) {\n  out[[i]] &lt;- fun(x[[i]], out[[i - 1]])\n}\n\nSi lo hace, refuerza la expectativa de que está recibiendo y estableciendo valores individuales.\n\n\n4.3.2 $\n\n$ es un operador abreviado: x$y es aproximadamente equivalente a x[[\"y\", exact = FALSE]]. A menudo se usa para acceder a variables en un data frame, como en mtcars$cyl o diamonds$carat. Un error común con $ es usarlo cuando tienes el nombre de una columna almacenada en una variable:\n\nvar &lt;- \"cyl\"\n# No funciona - mtcars$var traducido a mtcars[[\"var\"]]\nmtcars$var\n#&gt; NULL\n\n# En su lugar use [[\nmtcars[[var]]\n#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n\nLa única diferencia importante entre $ y [[ es que $ automáticamente hace (de izquierda a derecha) coincidencias parciales sin previo aviso:\n\nx &lt;- list(abc = 1)\nx$a\n#&gt; [1] 1\nx[[\"a\"]]\n#&gt; NULL\n\n Para ayudar a evitar este comportamiento, recomiendo configurar la opción global warnPartialMatchDollar en TRUE:\n\noptions(warnPartialMatchDollar = TRUE)\nx$a\n#&gt; Warning in x$a: partial match of 'a' to 'abc'\n#&gt; [1] 1\n\n(Para data frames, también puede evitar este problema usando tibbles, que nunca hacen coincidencias parciales.)\n\n\n4.3.3 Índices faltantes y fuera de los límites\n \nEs útil comprender lo que sucede con [[ cuando usa un índice “no válido”. La siguiente tabla resume lo que sucede cuando crea un subconjunto de un vector lógico, una lista y un NULL con un objeto de longitud cero (como NULL o logical()), valores fuera de los límites (OOB) o un valor faltante (por ejemplo, NA_integer_) con [[. Cada celda muestra el resultado de dividir la estructura de datos nombrada en la fila por el tipo de índice descrito en la columna. Solo he mostrado los resultados para vectores lógicos, pero otros vectores atómicos se comportan de manera similar, devolviendo elementos del mismo tipo (NB: int = entero; chr = carácter).\n\n\n\nrow[[col]]\nLongitud cero\nOOB (int)\nOOB (chr)\nFaltante\n\n\n\n\nAtómico\nError\nError\nError\nError\n\n\nLista\nError\nError\nNULL\nNULL\n\n\nNULL\nNULL\nNULL\nNULL\nNULL\n\n\n\nSi se nombra el vector que se indexa, los nombres de los componentes OOB, faltantes o NULL serán &lt;NA&gt;.\nLas inconsistencias en la tabla anterior llevaron al desarrollo de purrr::pluck() y purrr::chuck(). Cuando falta el elemento, pluck() siempre devuelve NULL (o el valor del argumento .default) y chuck() siempre arroja un error. El comportamiento de pluck() lo hace ideal para la indexación en estructuras de datos profundamente anidadas donde el componente que desea puede no existir (como es común cuando se trabaja con datos JSON de API web). pluck() también te permite mezclar índices enteros y de caracteres, y proporciona un valor predeterminado alternativo si un elemento no existe:\n\nx &lt;- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n#&gt; [1] 1\n\npurrr::pluck(x, \"c\", 1)\n#&gt; NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n#&gt; [1] NA\n\n\n\n4.3.4 @ y slot()\nHay dos operadores de subconjuntos adicionales, que son necesarios para los objetos de S4: @ (equivalente a $) y slot() (equivalente a [[). @ es más restrictivo que $ ya que devolverá un error si la ranura no existe. Estos se describen con más detalle en el Capítulo 15.\n\n\n4.3.5 Ejercicios\n\nPiense en tantas formas como sea posible para extraer el tercer valor de la variable cyl en el conjunto de datos mtcars.\nDado un modelo lineal, por ejemplo, mod &lt;- lm(mpg ~ wt, data = mtcars), extraiga los grados de libertad residuales. Luego extraiga la R al cuadrado del resumen del modelo (summary (mod))",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#sec-subassignment",
    "href": "Subsetting.html#sec-subassignment",
    "title": "4  Subconjunto",
    "section": "4.4 Subconjunto y asignación",
    "text": "4.4 Subconjunto y asignación\n \nTodos los operadores de subconjunto se pueden combinar con la asignación para modificar los valores seleccionados de un vector de entrada: esto se denomina subasignación. La forma básica es x[i] &lt;- valor:\n\nx &lt;- 1:5\nx[c(1, 2)] &lt;- c(101, 102)\nx\n#&gt; [1] 101 102   3   4   5\n\nTe recomiendo que te asegures de que length(valor) sea lo mismo que length(x[i]), y que i sea único. Esto se debe a que, si bien R reciclará si es necesario, esas reglas son complejas (particularmente si i contiene valores faltantes o duplicados) y pueden causar problemas.\nCon las listas, puede usar x[[i]] &lt;- NULL para eliminar un componente. Para agregar un literal NULL, use x[i] &lt;- list(NULL):\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nstr(x)\n#&gt; List of 1\n#&gt;  $ a: num 1\n\ny &lt;- list(a = 1, b = 2)\ny[\"b\"] &lt;- list(NULL)\nstr(y)\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: NULL\n\nLa creación de subconjuntos sin nada puede ser útil con la asignación porque conserva la estructura del objeto original. Compara las siguientes dos expresiones. En el primero, mtcars sigue siendo un data frame porque solo está cambiando el contenido de mtcars, no mtcars en sí. En el segundo, mtcars se convierte en una lista porque está cambiando el objeto al que está vinculado.\n\nmtcars[] &lt;- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#&gt; [1] TRUE\n\nmtcars &lt;- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#&gt; [1] FALSE",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#sec-applications",
    "href": "Subsetting.html#sec-applications",
    "title": "4  Subconjunto",
    "section": "4.5 Aplicaciones",
    "text": "4.5 Aplicaciones\nLos principios descritos anteriormente tienen una amplia variedad de aplicaciones útiles. A continuación se describen algunos de los más importantes. Si bien muchos de los principios básicos de creación de subconjuntos ya se han incorporado en funciones como subset(), merge() y dplyr::arrange(), será valioso comprender mejor cómo se han implementado esos principios. cuando se encuentra con situaciones en las que las funciones que necesita no existen.\n\n4.5.1 Tablas de búsqueda (subconjunto de caracteres)\n\nLa coincidencia de caracteres es una forma poderosa de crear tablas de búsqueda. Digamos que quieres convertir abreviaturas:\n\nx &lt;- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup &lt;- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n#&gt;        m        f        u        f        f        m        m \n#&gt;   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\nTenga en cuenta que si no quiere nombres en el resultado, use unname() para eliminarlos.\n\nunname(lookup[x])\n#&gt; [1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"\n\n\n\n4.5.2 Coincidencia y fusión a mano (subconjunto de enteros)\n \nTambién puede tener tablas de búsqueda más complicadas con múltiples columnas de información. Por ejemplo, supongamos que tenemos un vector de grados enteros y una tabla que describe sus propiedades:\n\ngrades &lt;- c(1, 2, 2, 3, 1)\n\ninfo &lt;- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nEntonces, digamos que queremos duplicar la tabla info para que tengamos una fila para cada valor en grade. Una forma elegante de hacer esto es combinando match() y un subconjunto de enteros (match(aguja, pajar) devuelve la posición donde se encuentra cada aguja en el pajar).\n\nid &lt;- match(grades, info$grade)\nid\n#&gt; [1] 3 2 2 1 3\ninfo[id, ]\n#&gt;     grade      desc  fail\n#&gt; 3       1      Poor  TRUE\n#&gt; 2       2      Good FALSE\n#&gt; 2.1     2      Good FALSE\n#&gt; 1       3 Excellent FALSE\n#&gt; 3.1     1      Poor  TRUE\n\nSi está haciendo coincidir varias columnas, primero deberá colapsarlas en una sola columna (con, por ejemplo, interaction ()). Sin embargo, normalmente es mejor cambiar a una función diseñada específicamente para unir varias tablas como merge() o dplyr::left_join().\n\n\n4.5.3 Muestras aleatorias y bootstraps (subconjunto de enteros)\n \nPuede usar índices enteros para muestrear o arrancar aleatoriamente un vector o un data frame. Simplemente use sample(n) para generar una permutación aleatoria de 1:n, y luego use los resultados para dividir los valores:\n\ndf &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Reordenar aleatoriamente\ndf[sample(nrow(df)), ]\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 3 3 3 c\n#&gt; 4 1 2 d\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n\n# Seleccionar aleatoriamente 3 filas\ndf[sample(nrow(df), 3), ]\n#&gt;   x y z\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 1 1 5 a\n\n# Seleccione 6 réplicas de arranque\ndf[sample(nrow(df), 6, replace = TRUE), ]\n#&gt;     x y z\n#&gt; 5   2 1 e\n#&gt; 5.1 2 1 e\n#&gt; 5.2 2 1 e\n#&gt; 2   2 4 b\n#&gt; 3   3 3 c\n#&gt; 3.1 3 3 c\n\nLos argumentos de sample() controlan el número de muestras a extraer, y también si el muestreo se realiza con o sin reemplazo.\n\n\n4.5.4 Ordenación (subconjunto de enteros)\n\n\norder() toma un vector como entrada y devuelve un vector entero que describe cómo ordenar el vector dividido en subconjuntos2:\n\nx &lt;- c(\"b\", \"c\", \"a\")\norder(x)\n#&gt; [1] 3 1 2\nx[order(x)]\n#&gt; [1] \"a\" \"b\" \"c\"\n\nPara desempatar, puede proporcionar variables adicionales a order(). También puede cambiar el orden de ascendente a descendente utilizando decreasing = TRUE. De forma predeterminada, cualquier valor que falte se colocará al final del vector; sin embargo, puede eliminarlos con na.last = NA o ponerlos al frente con na.last = FALSE.\nPara dos o más dimensiones, order() y el subconjunto de enteros facilita el orden de las filas o las columnas de un objeto:\n\n# Reordenar al azar df\ndf2 &lt;- df[sample(nrow(df)), 3:1]\ndf2\n#&gt;   z y x\n#&gt; 5 e 1 2\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n\ndf2[order(df2$x), ]\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 5 e 1 2\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\ndf2[, order(names(df2))]\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 1 1 5 a\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\nPuede ordenar los vectores directamente con sort(), o de manera similar dplyr::arrange(), para ordenar un data frame.\n\n\n4.5.5 Expansión de recuentos agregados (subconjunto de enteros)\nA veces obtiene un data frame donde filas idénticas se han colapsado en una y se ha agregado una columna de conteo. rep() y el subconjunto de enteros hacen que sea fácil de descomprimir, porque podemos aprovechar la vectorización de rep(): rep(x, y) repite x[i] y[i] veces .\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1\n\n\n\n4.5.6 Eliminar columnas de data frames (caracteres )\nHay dos formas de eliminar columnas de un data frame. Puede establecer columnas individuales para NULL:\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z &lt;- NULL\n\nO puede extraer un subconjunto para devolver solo las columnas que desea:\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\nSi solo conoce las columnas que no desea, use las operaciones de configuración para determinar qué columnas conservar:\n\ndf[setdiff(names(df), \"z\")]\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\n\n\n4.5.7 Selección de filas en función de una condición (subconjunto lógico)\n \nDebido a que el subconjunto lógico le permite combinar fácilmente condiciones de varias columnas, es probablemente la técnica más utilizada para extraer filas de un data frame.\n\nmtcars[mtcars$gear == 5, ]\n#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6\n#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n\nRecuerde utilizar los operadores booleanos vectoriales & y |, no los operadores escalares de cortocircuito && y ||, que son más útiles dentro de las sentencias if. Y no olvide las leyes de De Morgan, que pueden ser útiles para simplificar las negaciones:\n\n!(X & Y) es lo mismo que !X | !Y\n!(X | Y) es lo mismo que !X & !Y\n\nPor ejemplo, !(X & !(Y | Z)) se simplifica en !X | !!(Y|Z), y luego a !X | Y | Z.\n\n\n4.5.8 Álgebra booleana versus conjuntos (lógicos y enteros )\n \nEs útil ser consciente de la equivalencia natural entre las operaciones con conjuntos (subconjuntos enteros) y el álgebra booleana (subconjuntos lógicos). El uso de operaciones de conjuntos es más efectivo cuando:\n\nQuieres encontrar el primero (o el último) TRUE.\nTienes muy pocos TRUE y muchos FALSE; una representación establecida puede ser más rápida y requerir menos almacenamiento.\n\nwhich() le permite convertir una representación booleana en una representación entera. No hay una operación inversa en la base R, pero podemos crear una fácilmente:\n\nx &lt;- sample(10) &lt; 4\nwhich(x)\n#&gt; [1] 2 3 4\n\nunwhich &lt;- function(x, n) {\n  out &lt;- rep_len(FALSE, n)\n  out[x] &lt;- TRUE\n  out\n}\nunwhich(which(x), 10)\n#&gt;  [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\nCreemos dos vectores lógicos y sus equivalentes enteros, y luego exploremos la relación entre las operaciones booleanas y de conjuntos.\n\n(x1 &lt;- 1:10 %% 2 == 0)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n#&gt; [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0)\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n#&gt; [1]  5 10\n\n# X & Y &lt;-&gt; intersect(x, y)\nx1 & y1\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n#&gt; [1] 10\n\n# X | Y &lt;-&gt; union(x, y)\nx1 | y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n#&gt; [1]  2  4  6  8 10  5\n\n# X & !Y &lt;-&gt; setdiff(x, y)\nx1 & !y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n#&gt; [1] 2 4 6 8\n\n# xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n#&gt; [1] 2 4 6 8 5\n\nAl aprender subconjuntos por primera vez, un error común es usar x[which(y)] en lugar de x[y]. Aquí, which() no logra nada: cambia de subconjunto lógico a entero, pero el resultado es exactamente el mismo. En casos más generales, hay dos diferencias importantes.\n\nCuando el vector lógico contiene NA, el subconjunto lógico reemplaza estos valores con NA mientras que which() simplemente elimina estos valores. No es raro usar which() para este efecto secundario, pero no lo recomiendo: nada sobre el nombre “cuál” implica la eliminación de valores faltantes.\nx[-which(y)] no es equivalente a x[!y]: si y es todo FALSO, which(y) será integer(0) y -integer(0) sigue siendo integer(0), por lo que no obtendrá valores, en lugar de todos los valores.\n\nEn general, evite cambiar de subconjunto lógico a entero a menos que desee, por ejemplo, el primer o último valor TRUE.\n\n\n4.5.9 Ejercicios\n\n¿Cómo permutarías aleatoriamente las columnas de un data frame? (Esta es una técnica importante en los bosques aleatorios). ¿Puede permutar simultáneamente las filas y las columnas en un solo paso?\n¿Cómo seleccionaría una muestra aleatoria de m filas de un data frame? ¿Qué pasaría si la muestra tuviera que ser contigua (es decir, con una fila inicial, una fila final y todas las filas intermedias)?\n¿Cómo podría poner las columnas en un data frame en orden alfabético?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#sec-subsetting-answers",
    "href": "Subsetting.html#sec-subsetting-answers",
    "title": "4  Subconjunto",
    "section": "4.6 Respuestas de la",
    "text": "4.6 Respuestas de la\n\nLos enteros positivos seleccionan elementos en posiciones específicas, los enteros negativos descartan elementos; los vectores lógicos mantienen los elementos en las posiciones correspondientes a TRUE; los vectores de caracteres seleccionan elementos con nombres coincidentes.\n[ selecciona sub-listas: siempre devuelve una lista. Si lo usa con un solo entero positivo, devuelve una lista de longitud uno. [[ selecciona un elemento dentro de una lista. $ es una abreviatura conveniente: x$y es equivalente a x[[\"y\"]].\nUse drop = FALSE si está creando subconjuntos de una matriz, un arreglo o un data frame y desea conservar las dimensiones originales. Casi siempre deberías usarlo cuando hagas subconjuntos dentro de una función.\nSi x es una matriz, x[] &lt;- 0 reemplazará cada elemento con 0, manteniendo el mismo número de filas y columnas. Por el contrario, x &lt;- 0 reemplaza completamente la matriz con el valor 0.\nUn vector de caracteres con nombre puede actuar como una tabla de búsqueda simple: c(x = 1, y = 2, z = 3)[c(\"y\", \"z\", \"x\")]",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Subsetting.html#footnotes",
    "href": "Subsetting.html#footnotes",
    "title": "4  Subconjunto",
    "section": "",
    "text": "Si viene de Python, es probable que esto sea confuso, ya que probablemente esperaría que df[1:3, 1:2] seleccione tres columnas y dos filas. Generalmente, R “piensa” en las dimensiones en términos de filas y columnas, mientras que Python lo hace en términos de columnas y filas.↩︎\nEstos son índices de “extracción”, es decir, order(x)[i] es un índice de dónde se encuentra cada x[i]. No es un índice de dónde debe enviarse x[i].↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Subconjunto</span>"
    ]
  },
  {
    "objectID": "Control-flow.html",
    "href": "Control-flow.html",
    "title": "5  Flujo de control",
    "section": "",
    "text": "5.1 Introducción\nHay dos herramientas principales de flujo de control: opciones y bucles. Las opciones, como declaraciones if y llamadas switch(), le permiten ejecutar código diferente dependiendo de la entrada. Los bucles, como for y while, le permiten ejecutar código repetidamente, normalmente con opciones cambiantes. Espero que ya esté familiarizado con los conceptos básicos de estas funciones, por lo que cubriré brevemente algunos detalles técnicos y luego presentaré algunas características útiles, pero menos conocidas.\nEl sistema de condiciones (mensajes, advertencias y errores), del que aprenderá en el Capítulo 8, también proporciona un flujo de control no local.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Flujo de control</span>"
    ]
  },
  {
    "objectID": "Control-flow.html#introducción",
    "href": "Control-flow.html#introducción",
    "title": "5  Flujo de control",
    "section": "",
    "text": "Prueba\n¿Quieres saltarte este capítulo? Anímate, si puedes responder las siguientes preguntas. Encuentre las respuestas al final del capítulo en la Sección 5.4.\n\n¿Cuál es la diferencia entre if y ifelse()?\nEn el siguiente código, ¿cuál será el valor de y si x es TRUE? ¿Qué pasa si x es FALSE? ¿Qué pasa si x es NA?\n\ny &lt;- if (x) 3\n\n¿Qué devuelve switch(\"x\", x = , y = 2, z = 3)?\n\n\n\nEstructura\n\nLa Sección 5.2 se sumerge en los detalles de if, luego analiza los parientes cercanos ifelse() y switch().\nLa Sección 5.3 comienza recordándole la estructura básica del bucle for en R, analiza algunos errores comunes y luego habla sobre las declaraciones while y repeat relacionadas.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Flujo de control</span>"
    ]
  },
  {
    "objectID": "Control-flow.html#sec-choices",
    "href": "Control-flow.html#sec-choices",
    "title": "5  Flujo de control",
    "section": "5.2 Opciones",
    "text": "5.2 Opciones\n\nLa forma básica de una sentencia if en R es la siguiente:\n\nif (condition) true_action\nif (condition) true_action else false_action\n\nSi conditionn es TRUE, se evalúa true_action; si condition es FALSE, se evalúa la false_action opcional.\nPor lo general, las acciones son declaraciones compuestas contenidas dentro de {:\n\ngrade &lt;- function(x) {\n  if (x &gt; 90) {\n    \"A\"\n  } else if (x &gt; 80) {\n    \"B\"\n  } else if (x &gt; 50) {\n    \"C\"\n  } else {\n    \"F\"\n  }\n}\n\nif devuelve un valor para que pueda asignar los resultados:\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n#&gt; [1] 1 2\n\n(Recomiendo asignar los resultados de una declaración if solo cuando la expresión completa cabe en una línea; de lo contrario, tiende a ser difícil de leer.)\nCuando usa la forma de argumento único sin una declaración else, if invisiblemente (Sección 6.7.2) devuelve NULL si la condición es FALSE. Dado que funciones como c() y paste() descartan entradas NULL, esto permite una expresión compacta de ciertos modismos:\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n\n5.2.1 Entradas inválidas\nLa condición debe evaluarse como un solo TRUE o FALSE. La mayoría de las otras entradas generarán un error:\n\nif (\"x\") 1\n#&gt; Error in if (\"x\") 1: argument is not interpretable as logical\nif (logical()) 1\n#&gt; Error in if (logical()) 1: argument is of length zero\nif (NA) 1\n#&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\nif (c(TRUE, FALSE)) 1\n#&gt; Error in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1\n\n\n\n5.2.2 if vectorizado\n\nDado que if solo funciona con un solo TRUE o FALSE, es posible que se pregunte qué hacer si tiene un vector de valores lógicos. Manejar vectores de valores es el trabajo de ifelse(): una función vectorizada con vectores test, sí y no (que se reciclarán a la misma longitud):\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\nTenga en cuenta que los valores faltantes se propagarán a la salida.\nRecomiendo usar ifelse() solo cuando los vectores sí y no son del mismo tipo, ya que de otro modo es difícil predecir el tipo de salida. Ver https://vctrs.r-lib.org/articles/stability.html#ifelse para una discusión adicional.\nOtro equivalente vectorizado es el más general dplyr::case_when(). Utiliza una sintaxis especial para permitir cualquier número de pares de vectores de condición:\n\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n#&gt;  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n\n\n\n5.2.3 declaración switch()\n\nEstrechamente relacionada con if está la sentencia switch(). Es un equivalente compacto de propósito especial que le permite reemplazar código como:\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\ncon la más sucinta:\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\n\nEl último componente de un switch() siempre debería arrojar un error; de lo contrario, las entradas no coincidentes devolverán invisiblemente NULL:\n\n(switch(\"c\", a = 1, b = 2))\n#&gt; NULL\n\nSi varias entradas tienen la misma salida, puede dejar el lado derecho de = vacío y la entrada “caerá” al siguiente valor. Esto imita el comportamiento de la sentencia switch de C:\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n#&gt; [1] 4\nlegs(\"dog\")\n#&gt; [1] 4\n\nTambién es posible usar switch() con una x numérica, pero es más difícil de leer y tiene modos de falla no deseados si x no es un número entero. Recomiendo usar switch() solo con entradas de caracteres.\n\n\n5.2.4 Ejercicios\n\n¿Qué tipo de vector devuelve cada una de las siguientes llamadas a ifelse()?\n\nifelse(TRUE, 1, \"no\")\nifelse(FALSE, 1, \"no\")\nifelse(NA, 1, \"no\")\n\nLee la documentación y escribe las reglas con tus propias palabras.\n¿Por qué funciona el siguiente código?\n\nx &lt;- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n#&gt; [1] \"not empty\"\n\nx &lt;- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n#&gt; [1] \"empty\"",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Flujo de control</span>"
    ]
  },
  {
    "objectID": "Control-flow.html#sec-loops",
    "href": "Control-flow.html#sec-loops",
    "title": "5  Flujo de control",
    "section": "5.3 Bucles",
    "text": "5.3 Bucles\n \nfor los bucles se utilizan para iterar sobre los elementos de un vector. Tienen la siguiente forma básica:\n\nfor (item in vector) perform_action\n\nPara cada elemento en vector, perform_action se llama una vez; actualizando el valor de item cada vez.\n\nfor (i in 1:3) {\n  print(i)\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n\n(Al iterar sobre un vector de índices, es convencional usar nombres de variables muy cortos como i, j, or k.)\nN.B.: for asigna el item al entorno actual, sobrescribiendo cualquier variable existente con el mismo nombre:\n\ni &lt;- 100\nfor (i in 1:3) {}\ni\n#&gt; [1] 3\n\nHay dos formas de terminar un bucle for antes de tiempo:\n\nnext sale de la iteración actual.\nbreak sale de todo el bucle for.\n\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\n\n5.3.1 Errores comunes\n\nHay tres errores comunes a tener en cuenta al usar for. Primero, si está generando datos, asegúrese de asignar previamente el contenedor de salida. De lo contrario, el ciclo será muy lento; consulte las Secciones Sección 23.2.2 y Sección 24.6 para obtener más detalles. La función vector() es útil aquí.\n\nmeans &lt;- c(1, 50, 20)\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\nA continuación, tenga cuidado con la iteración sobre 1:length(x), que fallará de manera inútil si x tiene una longitud de 0:\n\nmeans &lt;- c()\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n#&gt; Error in rnorm(10, means[[i]]): invalid arguments\n\nEsto ocurre porque : funciona tanto con secuencias crecientes como decrecientes:\n\n1:length(means)\n#&gt; [1] 1 0\n\nUtilice seq_along(x) en su lugar. Siempre devuelve un valor de la misma longitud que x:\n\nseq_along(means)\n#&gt; integer(0)\n\nout &lt;- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\nFinalmente, es posible que encuentre problemas al iterar sobre los vectores de S3, ya que los bucles normalmente eliminan los atributos:\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n#&gt; [1] 18262\n#&gt; [1] 14610\n\nSolucione esto llamando a [[ usted mismo:\n\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\"\n\n\n\n5.3.2 Herramientas relacionadas\nLos bucles for son útiles si conoce de antemano el conjunto de valores que desea iterar. Si no lo sabe, hay dos herramientas relacionadas con especificaciones más flexibles:\n\nwhile(condition) action: ejecuta action mientras condition sea TRUE.\nrepeat(action): repite action siempre (i.e. hasta que encuentre break).\n\nR no tiene un equivalente a la sintaxis do {acción} while (condition) que se encuentra en otros idiomas.\nPuede reescribir cualquier bucle for para usar while en su lugar, y puede reescribir cualquier bucle while para usar repeat, pero lo contrario no es cierto. Eso significa que while es más flexible que for, y repeat es más flexible que while. Sin embargo, es una buena práctica usar la solución menos flexible a un problema, por lo que debe usar for siempre que sea posible.\nEn términos generales, no debería necesitar usar bucles for para tareas de análisis de datos, ya que map() y apply() ya brindan soluciones menos flexibles para la mayoría de los problemas. Aprenderá más en el Capítulo 9.\n\n\n5.3.3 Ejercicios\n\n¿Por qué este código tiene éxito sin errores ni advertencias?\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] &lt;- x[i] ^ 2\n}\nout\n\nCuando se evalúa el siguiente código, ¿qué puede decir sobre el vector que se itera?\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n#&gt; [1] 1 2 3 2 4 6\n\n¿Qué le dice el siguiente código acerca de cuándo se actualiza el índice?\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i) \n}\n#&gt; [1] 2\n#&gt; [1] 4\n#&gt; [1] 6",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Flujo de control</span>"
    ]
  },
  {
    "objectID": "Control-flow.html#sec-control-flow-answers",
    "href": "Control-flow.html#sec-control-flow-answers",
    "title": "5  Flujo de control",
    "section": "5.4 Respuestas de la prueba",
    "text": "5.4 Respuestas de la prueba\n\nif trabaja con escalares; ifelse() trabaja con vectores.\nCuando x es TRUE, y será 3; cuando FALSE, y será NULL; cuando NA, la declaración if arrojará un error.\nEsta instrucción switch() hace uso de fallas, por lo que devolverá 2. Consulte los detalles en la Sección 5.2.3.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Flujo de control</span>"
    ]
  },
  {
    "objectID": "Functions.html",
    "href": "Functions.html",
    "title": "6  Funciones",
    "section": "",
    "text": "6.1 Introducción\nSi está leyendo este libro, probablemente ya haya creado muchas funciones R y sepa cómo usarlas para reducir la duplicación en su código. En este capítulo, aprenderá cómo convertir ese conocimiento práctico e informal en una comprensión teórica más rigurosa. Y aunque verá algunos trucos y técnicas interesantes a lo largo del camino, tenga en cuenta que lo que aprenderá aquí será importante para comprender los temas más avanzados que se tratan más adelante en el libro.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#introducción",
    "href": "Functions.html#introducción",
    "title": "6  Funciones",
    "section": "",
    "text": "Prueba\nResponda las siguientes preguntas para ver si puede omitir este capítulo con seguridad. Puede encontrar las respuestas en la Sección 6.9.\n\n¿Cuáles son los tres componentes de una función?\n¿Qué devuelve el siguiente código?\n\nx &lt;- 10\nf1 &lt;- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()\n\n¿Cómo escribirías normalmente este código?\n\n`+`(1, `*`(2, 3))\n\n¿Cómo podría hacer que esta llamada sea más fácil de leer?\n\nmean(, TRUE, x = c(1:10, NA))\n\n¿El siguiente código arroja un error cuando se ejecuta? ¿Por qué o por qué no?\n\nf2 &lt;- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n\n¿Qué es una función infija? ¿Cómo lo escribes? ¿Qué es una función de reemplazo? ¿Cómo lo escribes?\n¿Cómo se asegura de que se produzca una acción de limpieza independientemente de cómo finalice una función?\n\n\n\nEstructura\n\nLa Sección 6.2 describe los aspectos básicos de la creación de una función, los tres componentes principales de una función y la excepción a muchas reglas de funciones: funciones primitivas (que se implementan en C, no en R).\nLa Sección 6.3 analiza las fortalezas y debilidades de las tres formas de composición de funciones comúnmente utilizadas en el código R.\nLa Sección 6.4 le muestra cómo R encuentra el valor asociado con un nombre dado, es decir, las reglas del alcance léxico.\nLa Sección 6.5 está dedicada a una propiedad importante de los argumentos de función: solo se evalúan cuando se usan por primera vez.\nLa Sección 6.6 analiza el argumento especial ..., que le permite pasar argumentos adicionales a otra función.\nLa Sección 6.7 analiza las dos formas principales en que una función puede salir y cómo definir un controlador de salida, código que se ejecuta al salir, independientemente de lo que lo active.\nLa Sección 6.8 le muestra las diversas formas en que R disfraza las llamadas a funciones ordinarias y cómo puede usar la forma de prefijo estándar para comprender mejor lo que está sucediendo.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-function-fundamentals",
    "href": "Functions.html#sec-function-fundamentals",
    "title": "6  Funciones",
    "section": "6.2 Fundamentos de funciones",
    "text": "6.2 Fundamentos de funciones\nPara entender las funciones en R necesitas internalizar dos ideas importantes:\n\nLas funciones se pueden dividir en tres componentes: argumentos, cuerpo y entorno.\n\nHay excepciones a cada regla y, en este caso, hay una pequeña selección de funciones base “primitivas” que se implementan únicamente en C.\n\nLas funciones son objetos, al igual que los vectores son objetos.\n\n\n6.2.1 Componentes de una función\n \nUna función tiene tres partes.:\n\nLos formularios, formals(), la lista de argumentos que controlan cómo llamas a la función.\nEl cuerpo, body(), el código dentro de la función.\nEl entorno, environment(), la estructura de datos que determina cómo la función encuentra los valores asociados con los nombres.\n\nMientras que los formularios y el cuerpo se especifican explícitamente cuando crea una función, el entorno se especifica implícitamente, en función de dónde definió la función. El entorno de la función siempre existe, pero solo se imprime cuando la función no está definida en el entorno global.\n\nf02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\n\nbody(f02)\n#&gt; {\n#&gt;     x + y\n#&gt; }\n\nenvironment(f02)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nDibujaré funciones como en el siguiente diagrama. El punto negro de la izquierda es el entorno. Los dos bloques a la derecha son los argumentos de la función. No dibujaré el cuerpo, porque generalmente es grande y no te ayuda a entender la forma de la función.\n\n\n\n\n\n\n\n\n\nComo todos los objetos en R, las funciones también pueden poseer cualquier cantidad de atributos, attributes(), adicionales. Un atributo utilizado por la base R es srcref, abreviatura de fuente de referencia. Apunta al código fuente utilizado para crear la función. El srcref se usa para imprimir porque, a diferencia de body(), contiene comentarios de código y otros formatos.\n\nattr(f02, \"srcref\")\n#&gt; function(x, y) {\n#&gt;   # A comment\n#&gt;   x + y\n#&gt; }\n\n\n\n6.2.2 Funciones primitivas\n \nHay una excepción a la regla de que una función tiene tres componentes. Las funciones primitivas, como sum() y [, llaman directamente al código C.\n\nsum\n#&gt; function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n#&gt; .Primitive(\"[\")\n\nEllas tienen el tipo builtin o tipospecial.\n\ntypeof(sum)\n#&gt; [1] \"builtin\"\ntypeof(`[`)\n#&gt; [1] \"special\"\n\nEstas funciones existen principalmente en C, no en R, por lo que sus formals(), body() y environment() son todos NULL:\n\nformals(sum)\n#&gt; NULL\nbody(sum)\n#&gt; NULL\nenvironment(sum)\n#&gt; NULL\n\nLas funciones primitivas solo se encuentran en el paquete base. Si bien tienen ciertas ventajas de rendimiento, este beneficio tiene un precio: son más difíciles de escribir. Por esta razón, R-core generalmente evita crearlos a menos que no haya otra opción.\n\n\n\n6.2.3 Funciones de primera clase\n \nEs muy importante comprender que las funciones de R son objetos por derecho propio, una propiedad del lenguaje a menudo denominada “funciones de primera clase”. A diferencia de muchos otros lenguajes, no existe una sintaxis especial para definir y nombrar una función: simplemente crea un objeto de función (con funtion) y lo vincula a un nombre con &lt;-:\n\nf01 &lt;- function(x) {\n  sin(1 / x ^ 2)\n}\n\n\n\n\n\n\n\n\n\n\nSi bien casi siempre crea una función y luego la vincula a un nombre, el paso de vinculación no es obligatorio. Si elige no dar un nombre a una función, obtendrá una función anónima. Esto es útil cuando no vale la pena el esfuerzo de averiguar un nombre:\n\nlapply(mtcars, function(x) length(unique(x)))\nFilter(function(x) !is.numeric(x), mtcars)\nintegrate(function(x) sin(x) ^ 2, 0, pi)\n\nUna última opción es poner funciones en una lista:\n\nfuns &lt;- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n#&gt; [1] 20\n\nEn R, a menudo verá funciones llamadas cierres closures. Este nombre refleja el hecho de que las funciones de R capturan o encierran sus entornos, sobre los que aprenderá más en la Sección 7.4.2.\n\n\n6.2.4 Invocando una función\n\nNormalmente llamas a una función colocando sus argumentos, entre paréntesis, después de su nombre: mean(1:10, na.rm = TRUE). Pero, ¿qué sucede si ya tiene los argumentos en una estructura de datos?\n\nargs &lt;- list(1:10, na.rm = TRUE)\n\nEn su lugar, puede usar do.call(): tiene dos argumentos. La función a llamar y una lista que contiene los argumentos de la función:\n\ndo.call(mean, args)\n#&gt; [1] 5.5\n\nVolveremos a esta idea en la Sección 19.6.\n\n\n6.2.5 Ejercicios\n\nDado un nombre, como \"mean\", match.fun() te permite encontrar una función. Dada una función, ¿puedes encontrar su nombre? ¿Por qué eso no tiene sentido en R?\nEs posible (aunque normalmente no es útil) llamar a una función anónima. ¿Cuál de los dos enfoques siguientes es el correcto? ¿Por qué?\n\nfunction(x) 3()\n#&gt; function(x) 3()\n(function(x) 3)()\n#&gt; [1] 3\n\nUna buena regla general es que una función anónima debería caber en una línea y no debería necesitar usar {}. Revisa tu código. ¿Dónde podría haber usado una función anónima en lugar de una función con nombre? ¿Dónde debería haber usado una función con nombre en lugar de una función anónima?\n¿Qué función te permite saber si un objeto es una función? ¿Qué función te permite saber si una función es una función primitiva?\nEste código hace una lista de todas las funciones en el paquete base.\n\nobjs &lt;- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns &lt;- Filter(is.function, objs)\n\nÚsalo para responder las siguientes preguntas:\n\n¿Qué función base tiene más argumentos?\n¿Cuántas funciones base no tienen argumentos? ¿Qué tienen de especial esas funciones?\n¿Cómo podrías adaptar el código para encontrar todas las funciones primitivas?\n\n¿Cuáles son los tres componentes importantes de una función?\n¿Cuándo la impresión de una función no muestra el entorno en el que se creó?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-function-composition",
    "href": "Functions.html#sec-function-composition",
    "title": "6  Funciones",
    "section": "6.3 Composición de funciones",
    "text": "6.3 Composición de funciones\n \nBase R proporciona dos formas de componer múltiples llamadas a funciones. Por ejemplo, imagina que quieres calcular la desviación estándar de la población usando sqrt() y mean() como bloques de construcción:\n\nsquare &lt;- function(x) x^2\ndeviation &lt;- function(x) x - mean(x)\n\nO anida las llamadas de función:\n\nx &lt;- runif(100)\n\nsqrt(mean(square(deviation(x))))\n#&gt; [1] 0.274\n\nO guarda los resultados intermedios como variables:\n\nout &lt;- deviation(x)\nout &lt;- square(out)\nout &lt;- mean(out)\nout &lt;- sqrt(out)\nout\n#&gt; [1] 0.274\n\nTanto el paquete magrittr (Bache y Wickham 2014) y R base (a partir de la versión 4.1.0) proporcionan una tercera opción: el operador binario ‘%&gt;%’ y ‘|&gt;’ respectivamente, que se llama canalización y se pronuncia como “y luego”.\n\nlibrary(magrittr)\n\nx %&gt;%\n  deviation() %&gt;%\n  square() %&gt;%\n  mean() %&gt;%\n  sqrt()\n#&gt; [1] 0.274\n\nO\n\nx |&gt;\n  deviation() |&gt;\n  square() |&gt;\n  mean() |&gt;\n  sqrt()\n#&gt; [1] 0.274\n\nx |&gt; f() es equivalente a f(x); x |&gt; f(y) es equivalente a f(x, y). La canalización le permite concentrarse en la composición de funciones de alto nivel en lugar del flujo de datos de bajo nivel; el foco está en lo que se está haciendo (los verbos), más que en lo que se está modificando (los sustantivos). Este estilo es común en Haskell y F#, la principal inspiración para magrittr, y es el estilo predeterminado en lenguajes de programación basados en pilas como Forth y Factor. Para conocer más sobre las canalizaciones o pipe le recomiendo consultar la Sección 5.3 de R para la Ciencia de Datos\nCada una de las tres opciones tiene sus propias fortalezas y debilidades:\n\nEl anidamiento, f(g(x)), es conciso y muy adecuado para secuencias cortas. Pero las secuencias más largas son difíciles de leer porque se leen al revés y de derecha a izquierda. Como resultado, los argumentos pueden extenderse a largas distancias creando el problema Dagwood sandwich.\nObjetos intermedios, y &lt;- f(x); g(y), requiere que nombres objetos intermedios. Esta es una fortaleza cuando los objetos son importantes, pero una debilidad cuando los valores son realmente intermedios.\nLa canalización, x |&gt; f() |&gt; g(), le permite leer el código de manera directa de izquierda a derecha y no requiere que nombre objetos intermedios. Pero solo puede usarlo con secuencias lineales de transformaciones de un solo objeto. Asume que el lector entiende las canalizaciones.\n\nLa mayoría del código utilizará una combinación de los tres estilos. Las canalizaciones son más comunes en el código de análisis de datos, ya que gran parte de un análisis consiste en una secuencia de transformaciones de un objeto (como un marco de datos o un gráfico). Tiendo a usar canalizaciones con poca frecuencia en los paquetes; no porque sea una mala idea, sino porque a menudo es un ajuste menos natural.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-lexical-scoping",
    "href": "Functions.html#sec-lexical-scoping",
    "title": "6  Funciones",
    "section": "6.4 Scooping léxico",
    "text": "6.4 Scooping léxico\n\nEn el Capítulo 2, discutimos la asignación, el acto de vincular un nombre a un valor. Aquí hablaremos de scoping, el acto de encontrar el valor asociado con un nombre.\nLas reglas básicas del scoping son bastante intuitivas y probablemente ya las haya internalizado, incluso si nunca las estudió explícitamente. Por ejemplo, ¿qué devolverá el siguiente código, 10 o 20?1\n\nx &lt;- 10\ng01 &lt;- function() {\n  x &lt;- 20\n  x\n}\n\ng01()\n\nEn esta sección, aprenderá las reglas formales del alcance, así como algunos de sus detalles más sutiles. Una comprensión más profunda del alcance lo ayudará a usar herramientas de programación funcional más avanzadas y, eventualmente, incluso a escribir herramientas que traduzcan el código R a otros lenguajes.\nR usa scooping léxico2: busca los valores de los nombres según cómo se define una función, no cómo se llama. “Léxico” o lexical, en inglés, es un término técnico de CS (Computer Science) que nos dice que las reglas de scooping utilizan un tiempo de análisis, en lugar de una estructura de tiempo de ejecución.\nEl scoopin léxico de R sigue 4 reglas principales:\n\nEnmascaramiento de nombres\nFunciones versus variables\nUn nuevo comienzo\nBúsqueda dinámica\n\n\n6.4.1 Enmascaramiento de nombres\n\nEl principio básico del alcance léxico es que los nombres definidos dentro de una función enmascaran los nombres definidos fuera de una función. Esto se ilustra en el siguiente ejemplo.\n\nx &lt;- 10\ny &lt;- 20\ng02 &lt;- function() {\n  x &lt;- 1\n  y &lt;- 2\n  c(x, y)\n}\ng02()\n#&gt; [1] 1 2\n\nSi un nombre no está definido dentro de una función, R busca un nivel superior.\n\nx &lt;- 2\ng03 &lt;- function() {\n  y &lt;- 1\n  c(x, y)\n}\ng03()\n#&gt; [1] 2 1\n\n# And this doesn't change the previous value of y\ny\n#&gt; [1] 20\n\nLas mismas reglas se aplican si una función se define dentro de otra función. Primero, R mira dentro de la función actual. Luego, busca dónde se definió esa función (y así sucesivamente, hasta llegar al entorno global). Finalmente, busca en otros paquetes cargados.\nEjecute el siguiente código en su cabeza, luego confirme el resultado ejecutando el código.3\n\nx &lt;- 1\ng04 &lt;- function() {\n  y &lt;- 2\n  i &lt;- function() {\n    z &lt;- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()\n\nLas mismas reglas también se aplican a las funciones creadas por otras funciones, a las que llamo fabricas de funciones, el tema del Capítulo 10.\n\n\n6.4.2 Funciones versus variables\nEn R, las funciones son objetos ordinarios. Esto significa que las reglas de alcance descritas anteriormente también se aplican a las funciones:\n\ng07 &lt;- function(x) x + 1\ng08 &lt;- function() {\n  g07 &lt;- function(x) x + 100\n  g07(10)\n}\ng08()\n#&gt; [1] 110\n\nSin embargo, cuando una función y una no función comparten el mismo nombre (por supuesto, deben residir en diferentes entornos), la aplicación de estas reglas se vuelve un poco más complicada. Cuando usa un nombre en una llamada de función, R ignora los objetos que no son funciones cuando busca ese valor. Por ejemplo, en el siguiente código, g09 toma dos valores diferentes:\n\ng09 &lt;- function(x) x + 100\ng10 &lt;- function() {\n  g09 &lt;- 10\n  g09(g09)\n}\ng10()\n#&gt; [1] 110\n\nPara que conste, usar el mismo nombre para diferentes cosas es confuso y ¡es mejor evitarlo!\n\n\n6.4.3 Un nuevo comienzo\n¿Qué sucede con los valores entre invocaciones de una función? Considere el siguiente ejemplo. ¿Qué sucederá la primera vez que ejecute esta función? ¿Qué pasará la segunda vez?4 (Si no ha visto exists() antes, devuelve TRUE si hay una variable con ese nombre y devuelve FALSE si no.)\n\ng11 &lt;- function() {\n  if (!exists(\"a\")) {\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\ng11()\ng11()\n\nPuede que te sorprenda que g11() siempre devuelve el mismo valor. Esto sucede porque cada vez que se llama a una función, se crea un nuevo entorno para albergar su ejecución. Esto significa que una función no tiene forma de saber qué sucedió la última vez que se ejecutó; cada invocación es completamente independiente. Veremos algunas formas de evitar esto en la Sección 10.2.4.\n\n\n6.4.4 Búsqueda dinámica\n\nEl scooping léxico determina dónde, pero no cuándo buscar valores. R busca valores cuando se ejecuta la función, no cuando se crea la función. Juntas, estas dos propiedades nos dicen que la salida de una función puede diferir dependiendo de los objetos fuera del entorno de la función:\n\ng12 &lt;- function() x + 1\nx &lt;- 15\ng12()\n#&gt; [1] 16\n\nx &lt;- 20\ng12()\n#&gt; [1] 21\n\nEste comportamiento puede ser bastante molesto. Si comete un error ortográfico en su código, no recibirá un mensaje de error cuando cree la función. Y dependiendo de las variables definidas en el entorno global, es posible que ni siquiera reciba un mensaje de error cuando ejecute la función.\nPara detectar este problema, utilice codetools::findGlobals(). Esta función enumera todas las dependencias externas (símbolos independientes) dentro de una función:\n\ncodetools::findGlobals(g12)\n#&gt; [1] \"+\" \"x\"\n\nPara resolver este problema, puede cambiar manualmente el entorno de la función a emptyenv(), un entorno que no contiene nada:\n\nenvironment(g12) &lt;- emptyenv()\ng12()\n#&gt; Error in x + 1: could not find function \"+\"\n\nEl problema y su solución revelan por qué existe este comportamiento aparentemente indeseable: R se basa en el scooping léxico para encontrar todo, desde lo obvio, como mean(), hasta lo menos obvio, como + o incluso {. Esto le da a las reglas de scooping de R una hermosa simplicidad.\n\n\n6.4.5 Ejercicios\n\n¿Qué devuelve el siguiente código? ¿Por qué? Describa cómo se interpreta cada una de las tres c.\n\nc &lt;- 10\nc(c = c)\n\n¿Cuáles son los cuatro principios que rigen cómo R busca valores?\n¿Qué devuelve la siguiente función? Haga una predicción antes de ejecutar el código usted mismo.\n\nf &lt;- function(x) {\n  f &lt;- function(x) {\n    f &lt;- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-lazy-evaluation",
    "href": "Functions.html#sec-lazy-evaluation",
    "title": "6  Funciones",
    "section": "6.5 Evaluación perezosa",
    "text": "6.5 Evaluación perezosa\n \nEn R, los argumentos de función se evalúan perezosamente: solo se evalúan si se accede a ellos. Por ejemplo, este código no genera un error porque x nunca se usa:\n\nh01 &lt;- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n#&gt; [1] 10\n\nEsta es una característica importante porque le permite hacer cosas como incluir cálculos potencialmente costosos en los argumentos de la función que solo se evaluarán si es necesario.\n\n6.5.1 Promesas\n \nLa evaluación perezosa está impulsada por una estructura de datos llamada promesa o (menos comúnmente) un thunk. Es una de las características que hace de R un lenguaje de programación tan interesante (volveremos a las promesas en la Sección 20.3).\nUna promesa tiene tres componentes:\n\nUna expresión, como x + y, que da lugar al cálculo retrasado.\nUn entorno donde se debe evaluar la expresión, es decir, el entorno donde se llama a la función. Esto asegura que la siguiente función devuelva 11, no 101:\n\ny &lt;- 10\nh02 &lt;- function(x) {\n  y &lt;- 100\n  x + 1\n}\n\nh02(y)\n#&gt; [1] 11\n\nEsto también significa que cuando realiza una asignación dentro de una llamada a una función, la variable se vincula fuera de la función, no dentro de ella.\n\nh02(y &lt;- 1000)\n#&gt; [1] 1001\ny\n#&gt; [1] 1000\n\nUn valor, que se calcula y almacena en caché la primera vez que se accede a una promesa cuando la expresión se evalúa en el entorno especificado. Esto asegura que la promesa se evalúe como máximo una vez, y es por eso que solo ve “Calculando…” impreso una vez en el siguiente ejemplo.\n\ndouble &lt;- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 &lt;- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#&gt; Calculating...\n#&gt; [1] 40 40\n\n\nNo puede manipular promesas con código R. Las promesas son como un estado cuántico: cualquier intento de inspeccionarlas con código R forzará una evaluación inmediata, haciendo que la promesa desaparezca. Más adelante, en la Sección 20.3, aprenderá sobre las quosures, que convierten las promesas en un objeto R donde puede inspeccionar fácilmente la expresión y el entorno.\n\n\n6.5.2 Argumentos por defecto\n\nGracias a la evaluación perezosa, los valores predeterminados se pueden definir en términos de otros argumentos, o incluso en términos de variables definidas más adelante en la función:\n\nh04 &lt;- function(x = 1, y = x * 2, z = a + b) {\n  a &lt;- 10\n  b &lt;- 100\n  \n  c(x, y, z)\n}\n\nh04()\n#&gt; [1]   1   2 110\n\nMuchas funciones base de R usan esta técnica, pero no la recomiendo. Hace que el código sea más difícil de entender: para predecir qué se devolverá, necesita saber el orden exacto en el que se evalúan los argumentos predeterminados.\nEl entorno de evaluación es ligeramente diferente para los argumentos predeterminados y proporcionados por el usuario, ya que los argumentos predeterminados se evalúan dentro de la función. Esto significa que llamadas aparentemente idénticas pueden producir resultados diferentes. Es más fácil ver esto con un ejemplo extremo:\n\nh05 &lt;- function(x = ls()) {\n  a &lt;- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n#&gt; [1] \"a\" \"x\"\n\n# ls() evaluated in global environment:\nh05(ls())\n#&gt; [1] \"h05\"\n\n\n\n6.5.3 Argumentos faltantes\n \nPara determinar si el valor de un argumento proviene del usuario o de un valor predeterminado, puede usar missing():\n\nh06 &lt;- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n#&gt; List of 2\n#&gt;  $ : logi TRUE\n#&gt;  $ : num 10\nstr(h06(10))\n#&gt; List of 2\n#&gt;  $ : logi FALSE\n#&gt;  $ : num 10\n\nmissing() sin embargo, es mejor usarlo con moderación. Tome sample(), como ejemplo. ¿Cuántos argumentos se requieren?\n\nargs(sample)\n#&gt; function (x, size, replace = FALSE, prob = NULL) \n#&gt; NULL\n\nParece que tanto x como size son necesarios, pero si no se proporciona size, sample() usa missing() para proporcionar un valor predeterminado. Si tuviera que volver a escribir la muestra, usaría un NULL explícito para indicar que no se requiere size pero se puede proporcionar:\n\nsample &lt;- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  if (is.null(size)) {\n    size &lt;- length(x)\n  }\n  \n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}\n\nCon el patrón binario creado por la función infija %||%, que usa el lado izquierdo si no es NULL y el lado derecho en caso contrario, podemos simplificar aún más sample(): \n\n`%||%` &lt;- function(lhs, rhs) {\n  if (!is.null(lhs)) {\n    lhs\n  } else {\n    rhs\n  }\n}\n\nsample &lt;- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  size &lt;- size %||% length(x)\n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}\n\nDebido a la evaluación perezosa, no necesita preocuparse por cálculos innecesarios: el lado derecho de %||% solo se evaluará si el lado izquierdo es NULL.\n\n\n6.5.4 Ejercicios\n\n¿Qué propiedad importante de && hace que x_ok() funcione?\n\nx_ok &lt;- function(x) {\n  !is.null(x) && length(x) == 1 && x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; [1] FALSE\nx_ok(1)\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE\n\n¿Qué es diferente con este código? ¿Por qué este comportamiento es indeseable aquí?\n\nx_ok &lt;- function(x) {\n  !is.null(x) & length(x) == 1 & x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; logical(0)\nx_ok(1)\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE FALSE FALSE\n\n¿Qué devuelve esta función? ¿Por qué? ¿Qué principio ilustra?\n\nf2 &lt;- function(x = z) {\n  z &lt;- 100\n  x\n}\nf2()\n\n¿Qué devuelve esta función? ¿Por qué? ¿Qué principio ilustra?\n\ny &lt;- 10\nf1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) {\n  c(x, y)\n}\nf1()\ny\n\nEn hist(), el valor predeterminado de xlim es range(breaks), el valor predeterminado de breaks es \"Sturges\", y\n\nrange(\"Sturges\")\n#&gt; [1] \"Sturges\" \"Sturges\"\n\nExplique cómo funciona hist() para obtener un valor xlim correcto.\nExplique por qué funciona esta función. ¿Por qué es confuso?\n\nshow_time &lt;- function(x = stop(\"Error!\")) {\n  stop &lt;- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#&gt; [1] \"2024-06-07 16:26:46 UTC\"\n\n¿Cuántos argumentos se requieren al llamar a library()?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-fun-dot-dot-dot",
    "href": "Functions.html#sec-fun-dot-dot-dot",
    "title": "6  Funciones",
    "section": "6.6 ... (punto-punto-punto)",
    "text": "6.6 ... (punto-punto-punto)\n\n \nLas funciones pueden tener un argumento especial ... (pronunciado punto-punto-punto). Con él, una función puede tomar cualquier número de argumentos adicionales. En otros lenguajes de programación, este tipo de argumento a menudo se llama varargs (abreviatura de argumentos variables), y una función que lo usa se dice que es variable.\nTambién puede usar ... para pasar esos argumentos adicionales a otra función.\n\ni01 &lt;- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 &lt;- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\nUsando una forma especial, ..N, es posible (pero rara vez útil) referirse a elementos de ... por posición:\n\ni03 &lt;- function(...) {\n  list(first = ..1, third = ..3)\n}\nstr(i03(1, 2, 3))\n#&gt; List of 2\n#&gt;  $ first: num 1\n#&gt;  $ third: num 3\n\nMás útil es list(...), que evalúa los argumentos y los almacena en una lista:\n\ni04 &lt;- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: num 2\n\n(Consulte también rlang::list2() para admitir el empalme e ignorar silenciosamente las comas finales, y rlang::enquos() para capturar argumentos no evaluados, el tema de [cuasicotización].)\nHay dos usos principales de ..., a los cuales volveremos más adelante en el libro:\n\nSi su función toma una función como argumento, querrá alguna forma de pasar argumentos adicionales a esa función. En este ejemplo, lapply() usa ... para pasar na.rm a mean():\n\nx &lt;- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#&gt; List of 2\n#&gt;  $ : num 2\n#&gt;  $ : num 5\n\nVolveremos a esta técnica en la Sección 9.2.3.\nSi su función es genérica de S3, necesita alguna forma de permitir que los métodos tomen argumentos adicionales arbitrarios. Por ejemplo, tome la función print(). Debido a que existen diferentes opciones para imprimir según el tipo de objeto, no hay forma de especificar previamente todos los argumentos posibles y ... permite que los métodos individuales tengan diferentes argumentos:\n\nprint(factor(letters), max.levels = 4)\n\nprint(y ~ x, showEnv = TRUE)\n\nVolveremos a este uso de ... en la Sección 13.4.3.\n\nUsar ... tiene dos desventajas:\n\nCuando lo usa para pasar argumentos a otra función, debe explicar cuidadosamente al usuario dónde van esos argumentos. Esto hace que sea difícil entender lo que puedes hacer con funciones como lapply() y plot().\nUn argumento mal escrito no generará un error. Esto facilita que los errores tipográficos pasen desapercibidos:\n\nsum(1, 2, NA, na_rm = TRUE)\n#&gt; [1] NA\n\n\n\n6.6.1 Ejercicios\n\nExplique los siguientes resultados:\n\nsum(1, 2, 3)\n#&gt; [1] 6\nmean(1, 2, 3)\n#&gt; [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#&gt; [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#&gt; [1] 1\n\nExplique cómo encontrar la documentación para los argumentos con nombre en la siguiente llamada de función:\n\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\n\n\n\n\n\n\n\n\n¿Por qué plot(1:10, col = \"red\") solo colorea los puntos, no los ejes ni las etiquetas? Lea el código fuente de plot.default() para averiguarlo.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-exiting-a-function",
    "href": "Functions.html#sec-exiting-a-function",
    "title": "6  Funciones",
    "section": "6.7 Salir de una función",
    "text": "6.7 Salir de una función\nLa mayoría de las funciones salen de una de dos maneras5: o devuelven un valor, lo que indica el éxito, o arrojan un error, lo que indica el fracaso. Esta sección describe los valores devueltos (implícitos frente a explícitos; visibles frente a invisibles), analiza brevemente los errores y presenta los controladores de salida, que le permiten ejecutar código cuando una función sale.\n\n6.7.1 Rendimientos implícitos versus explícitos\n \nHay dos formas en que una función puede devolver un valor:\n\nImplícitamente, donde la última expresión evaluada es el valor de retorno:\n\nj01 &lt;- function(x) {\n  if (x &lt; 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#&gt; [1] 0\nj01(15)\n#&gt; [1] 10\n\nExplícitamente, llamando return():\n\nj02 &lt;- function(x) {\n  if (x &lt; 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\n\n\n\n\n6.7.2 Valores invisibles\n\n \nLa mayoría de las funciones regresan visiblemente: llamar a la función en un contexto interactivo imprime el resultado.\n\nj03 &lt;- function() 1\nj03()\n#&gt; [1] 1\n\nSin embargo, puede evitar la impresión automática aplicando invisible() al último valor:\n\nj04 &lt;- function() invisible(1)\nj04()\n\nPara verificar que este valor existe, puede imprimirlo explícitamente o envolverlo entre paréntesis:\n\nprint(j04())\n#&gt; [1] 1\n\n(j04())\n#&gt; [1] 1\n\nAlternativamente, puedes usar withVisible() para devolver el valor y un indicador de visibilidad:\n\nstr(withVisible(j04()))\n#&gt; List of 2\n#&gt;  $ value  : num 1\n#&gt;  $ visible: logi FALSE\n\nLa función más común que regresa invisiblemente es &lt;-:\n\na &lt;- 2\n(a &lt;- 2)\n#&gt; [1] 2\n\nEsto es lo que hace posible encadenar asignaciones:\n\na &lt;- b &lt;- c &lt;- d &lt;- 2\n\nEn general, cualquier función llamada principalmente por un efecto secundario (como &lt;-, print() o plot()) debería devolver un valor invisible (normalmente el valor del primer argumento).\n\n\n6.7.3 Errores\n\n\nSi una función no puede completar su tarea asignada, debería arrojar un error con stop(), que finaliza inmediatamente la ejecución de la función.\n\nj05 &lt;- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n#&gt; Error in j05(): I'm an error\n\nUn error indica que algo salió mal y obliga al usuario a solucionar el problema. Algunos lenguajes (como C, Go y Rust) se basan en valores de retorno especiales para indicar problemas, pero en R siempre debe arrojar un error. Aprenderá más sobre los errores y cómo manejarlos en el Capítulo 8.\n\n\n6.7.4 Controladores de salida\n\n\nA veces, una función necesita realizar cambios temporales en el estado global. Pero tener que limpiar esos cambios puede ser doloroso (¿qué sucede si hay un error?). Para asegurarse de que estos cambios se deshagan y que el estado global se restablezca sin importar cómo salga una función, use on.exit() para configurar un controlador de salida. El siguiente ejemplo simple muestra que el controlador de salida se ejecuta independientemente de si la función sale normalmente o con un error.\n\nj06 &lt;- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE)\n  \n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n\nj06(TRUE)\n#&gt; Hello\n#&gt; Goodbye!\n#&gt; [1] 10\n\nj06(FALSE)\n#&gt; Hello\n#&gt; Error in j06(FALSE): Error\n#&gt; Goodbye!\n\n\nEstablezca siempre add = TRUE cuando use on.exit(). Si no lo hace, cada llamada a on.exit() sobrescribirá el controlador de salida anterior. Incluso cuando solo se registra un único controlador, es una buena práctica configurar add = TRUE para que no se lleve sorpresas desagradables si luego agrega más controladores de salida.\n\non.exit() es útil porque le permite colocar el código de limpieza directamente al lado del código que requiere limpieza:\n\ncleanup &lt;- function(dir, code) {\n  old_dir &lt;- setwd(dir)\n  on.exit(setwd(old_dir), add = TRUE)\n  \n  old_opt &lt;- options(stringsAsFactors = FALSE)\n  on.exit(options(old_opt), add = TRUE)\n}\n\nJunto con la evaluación perezosa, esto crea un patrón muy útil para ejecutar un bloque de código en un entorno alterado:\n\nwith_dir &lt;- function(dir, code) {\n  old &lt;- setwd(dir)\n  on.exit(setwd(old), add = TRUE)\n\n  force(code)\n}\n\ngetwd()\n#&gt; [1] \"/home/runner/work/adv-res/adv-res\"\nwith_dir(\"~\", getwd())\n#&gt; [1] \"/home/runner\"\n\nEl uso de force() no es estrictamente necesario aquí ya que simplemente referirse al código forzará su evaluación. Sin embargo, usar force() deja muy claro que estamos forzando deliberadamente la ejecución. Aprenderá otros usos de force() en el Capítulo 10.\nEl paquete withr (Hester et al. 2018) proporciona una colección de otras funciones para configurar un estado temporal.\nEn R 3.4 y versiones anteriores, las expresiones on.exit() siempre se ejecutan en orden de creación:\n\nj08 &lt;- function() {\n  on.exit(message(\"a\"), add = TRUE)\n  on.exit(message(\"b\"), add = TRUE)\n}\nj08()\n#&gt; a\n#&gt; b\n\nEsto puede dificultar un poco la limpieza si es necesario realizar algunas acciones en un orden específico; por lo general, desea que se ejecute primero la expresión añadida más reciente. En R 3.5 y versiones posteriores, puede controlar esto configurando after = FALSE:\n\nj09 &lt;- function() {\n  on.exit(message(\"a\"), add = TRUE, after = FALSE)\n  on.exit(message(\"b\"), add = TRUE, after = FALSE)\n}\nj09()\n#&gt; b\n#&gt; a\n\n\n\n6.7.5 Ejercicios\n\n¿Qué devuelve load()? ¿Por qué normalmente no ves estos valores?\n¿Qué devuelve write.table()? ¿Qué sería más útil?\n¿Cómo se compara el parámetro chdir de source() con with_dir()? ¿Por qué preferirías uno a otro?\nEscriba una función que abra un dispositivo de gráficos, ejecute el código proporcionado y cierre el dispositivo de gráficos (siempre, independientemente de si el código de trazado funciona o no).\nPodemos usar on.exit() para implementar una versión simple de capture.output().\n\ncapture.output2 &lt;- function(code) {\n  temp &lt;- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n#&gt; [1] \"a\" \"b\" \"c\"\n\nCompara capture.output() con capture.output2(). ¿Cómo difieren las funciones? ¿Qué características he eliminado para que las ideas clave sean más fáciles de ver? ¿Cómo he reescrito las ideas clave para que sean más fáciles de entender?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-function-forms",
    "href": "Functions.html#sec-function-forms",
    "title": "6  Funciones",
    "section": "6.8 Formas de función",
    "text": "6.8 Formas de función\n\nPara comprender los cálculos en R, dos lemas son útiles:\n\nTodo lo que existe es un objeto.\nTodo lo que sucede es una llamada de función.\n\n— John Chambers\n\nSi bien todo lo que sucede en R es el resultado de una llamada de función, no todas las llamadas tienen el mismo aspecto. Las llamadas a funciones vienen en cuatro variedades:\n\nprefija: el nombre de la función viene antes de sus argumentos, como foofy(a, b, c). Estos constituyen la mayoría de las llamadas a funciones en R.\ninfija: el nombre de la función viene entre sus argumentos, como x + y. Las formas infijas se utilizan para muchos operadores matemáticos y para funciones definidas por el usuario que comienzan y terminan con %.\nreemplazo: funciones que reemplazan valores por asignación, como names(df) &lt;- c(\"a\", \"b\", \"c\"). En realidad, parecen funciones de prefijo.\nespecial: funciones como [[, if y for. Si bien no tienen una estructura consistente, juegan papeles importantes en la sintaxis de R.\n\nSi bien hay cuatro formas, en realidad solo necesita una porque cualquier llamada se puede escribir en forma de prefijo. Demostraré esta propiedad y luego aprenderá sobre cada una de las formas.\n\n6.8.1 Reescritura en forma de prefijo\n \nUna propiedad interesante de R es que cada infijo, reemplazo o forma especial se puede reescribir en forma de prefijo. Hacerlo es útil porque lo ayuda a comprender mejor la estructura del lenguaje, le brinda el nombre real de cada función y le permite modificar esas funciones para divertirse y obtener ganancias.\nEl siguiente ejemplo muestra tres pares de llamadas equivalentes, reescribiendo una forma de infijo, una forma de reemplazo y una forma especial en forma de prefijo.\n\nx + y\n`+`(x, y)\n\nnames(df) &lt;- c(\"x\", \"y\", \"z\")\n`names&lt;-`(df, c(\"x\", \"y\", \"z\"))\n\nfor(i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n\n¡Sorprendentemente, en R, for se puede llamar como una función normal! Lo mismo es cierto básicamente para todas las operaciones en R, lo que significa que conocer el nombre de la función de una función sin prefijo le permite anular su comportamiento. Por ejemplo, si alguna vez te sientes particularmente mal, ejecuta el siguiente código mientras un amigo no está en su computadora. Introducirá un error divertido: el 10% de las veces, agregará 1 a cualquier cálculo numérico dentro de los paréntesis.\n\n`(` &lt;- function(e1) {\n  if (is.numeric(e1) && runif(1) &lt; 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n#&gt;  [1] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n#&gt; [39] 4 3 4 3 3 3 3 4 3 3 3 3\nrm(\"(\")\n\nPor supuesto, anular funciones integradas como esta es una mala idea, pero, como aprenderá en la Sección 21.2.5, es posible aplicarlo solo a bloques de código seleccionados. Esto proporciona un enfoque limpio y elegante para escribir idiomas específicos de dominio y traductores a otros idiomas.\nUna aplicación más útil surge cuando se utilizan herramientas de programación funcional. Por ejemplo, podría usar lapply() para agregar 3 a cada elemento de una lista definiendo primero una función add():\n\nadd &lt;- function(x, y) x + y\nlapply(list(1:3, 4:5), add, 3)\n#&gt; [[1]]\n#&gt; [1] 4 5 6\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 7 8\n\nPero también podemos obtener el mismo resultado simplemente confiando en la función + existente:\n\nlapply(list(1:3, 4:5), `+`, 3)\n#&gt; [[1]]\n#&gt; [1] 4 5 6\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 7 8\n\nExploraremos esta idea en detalle en la Capítulo 9.\n\n\n6.8.2 Forma de prefijo\n \nLa forma de prefijo es la forma más común en el código R y, de hecho, en la mayoría de los lenguajes de programación. Las llamadas de prefijo en R son un poco especiales porque puede especificar argumentos de tres maneras:\n\nPor posición, como help(mean).\nUsando coincidencias parciales, como help(top = mean).\nPor nombre, como help(topic = mean).\n\nComo se ilustra en el siguiente fragmento, los argumentos se comparan por nombre exacto, luego con prefijos únicos y finalmente por posición.\n\nk01 &lt;- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(1, 2, 3))\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\nstr(k01(2, 3, abcdef = 1))\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\n\n# Puede abreviar nombres de argumentos largos:\nstr(k01(2, 3, a = 1))\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\n\n# Pero esto no funciona porque la abreviatura es ambigua.\nstr(k01(1, 3, b = 1))\n#&gt; Error in k01(1, 3, b = 1): argument 3 matches multiple formal arguments\n\nEn general, use la coincidencia posicional solo para los primeros uno o dos argumentos; serán los más utilizados y la mayoría de los lectores sabrán cuáles son. Evite el uso de coincidencias posicionales para argumentos que se usan con menos frecuencia y nunca use coincidencias parciales. Desafortunadamente, no puede deshabilitar la coincidencia parcial, pero puede convertirla en una advertencia con la opción warnPartialMatchArgs: \n\noptions(warnPartialMatchArgs = TRUE)\nx &lt;- k01(a = 1, 2, 3)\n#&gt; Warning in k01(a = 1, 2, 3): partial argument match of 'a' to 'abcdef'\n\n\n\n6.8.3 Funciones infijas\n \nLas funciones infijas obtienen su nombre del hecho de que el nombre de la función se encuentra entre sus argumentos y, por lo tanto, tienen dos argumentos. R viene con una serie de operadores infijos incorporados: :, ::, :::, $, @, ^, *, /, +, -, &gt;, &gt;=, &lt;, &lt;=, ==, !=, !, &, &&, |, ||, ~, &lt;-, y &lt;&lt;-. También puede crear sus propias funciones infijas que comiencen y terminen con %. Base R usa este patrón para definir %%, %*%, %/%, %in%, %o%, y %x%.\nDefinir su propia función de infijo es simple. Creas una función de dos argumentos y la vinculas a un nombre que comienza y termina con %:\n\n`%+%` &lt;- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n#&gt; [1] \"new string\"\n\nLos nombres de las funciones infijas son más flexibles que las funciones regulares de R: pueden contener cualquier secuencia de caracteres excepto %. Deberá escapar cualquier carácter especial en la cadena utilizada para definir la función, pero no cuando la llame:\n\n`% %` &lt;- function(a, b) paste(a, b)\n`%/\\\\%` &lt;- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n#&gt; [1] \"a b\"\n\"a\" %/\\% \"b\"\n#&gt; [1] \"a b\"\n\nLas reglas de precedencia predeterminadas de R significan que los operadores infijos se componen de izquierda a derecha:\n\n`%-%` &lt;- function(a, b) paste0(\"(\", a, \" %-% \", b, \")\")\n\"a\" %-% \"b\" %-% \"c\"\n#&gt; [1] \"((a %-% b) %-% c)\"\n\nHay dos funciones infijas especiales que se pueden llamar con un solo argumento: + y -.\n\n-1\n#&gt; [1] -1\n+10\n#&gt; [1] 10\n\n\n\n6.8.4 Funciones de reemplazo\n \nLas funciones de reemplazo actúan como si modificaran sus argumentos en su lugar y tienen el nombre especial xxx&lt;-. Deben tener argumentos llamados x y value, y deben devolver el objeto modificado. Por ejemplo, la siguiente función modifica el segundo elemento de un vector:\n\n`second&lt;-` &lt;- function(x, value) {\n  x[2] &lt;- value\n  x\n}\n\nLas funciones de reemplazo se utilizan colocando la llamada de función en el lado izquierdo de &lt;-:\n\nx &lt;- 1:10\nsecond(x) &lt;- 5L\nx\n#&gt;  [1]  1  5  3  4  5  6  7  8  9 10\n\nDigo que actúan como si modificaran sus argumentos en el lugar porque, como se explica en la Sección 2.5, en realidad crean una copia modificada. Podemos ver eso usando tracemem():\n\nx &lt;- 1:10\ntracemem(x)\n#&gt; &lt;0x7ffae71bd880&gt;\n\nsecond(x) &lt;- 6L\n#&gt; tracemem[0x7ffae71bd880 -&gt; 0x7ffae61b5480]: \n#&gt; tracemem[0x7ffae61b5480 -&gt; 0x7ffae73f0408]: second&lt;- \n\nSi su función de reemplazo necesita argumentos adicionales, colóquelos entre x y value, y llame a la función de reemplazo con argumentos adicionales a la izquierda:\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\nmodify(x, 1) &lt;- 10\nx\n#&gt;  [1] 10  5  3  4  5  6  7  8  9 10\n\nCuando escribe modify(x, 1) &lt;- 10, detrás de escena R lo convierte en:\n\nx &lt;- `modify&lt;-`(x, 1, 10)\n\nLa combinación de reemplazo con otras funciones requiere una traducción más compleja. Por ejemplo:\n\nx &lt;- c(a = 1, b = 2, c = 3)\nnames(x)\n#&gt; [1] \"a\" \"b\" \"c\"\n\nnames(x)[2] &lt;- \"two\"\nnames(x)\n#&gt; [1] \"a\"   \"two\" \"c\"\n\nse traduce en:\n\n`*tmp*` &lt;- x\nx &lt;- `names&lt;-`(`*tmp*`, `[&lt;-`(names(`*tmp*`), 2, \"two\"))\nrm(`*tmp*`)\n\n(Sí, realmente crea una variable local llamada *tmp*, que se elimina después.)\n\n\n6.8.5 Formas especiales\n \nFinalmente, hay un montón de características del lenguaje que normalmente se escriben de formas especiales, pero que también tienen formas de prefijo. Estos incluyen paréntesis:\n\n(x) (`(`(x))\n{x} (`{`(x)).\n\nLos operadores de subconjuntos:\n\nx[i] (`[`(x, i))\nx[[i]] (`[[`(x, i))\n\nY las herramientas de control de flujo:\n\nif (cond) true (`if`(cond, true))\nif (cond) true else false (`if`(cond, true, false))\nfor(var in seq) action (`for`(var, seq, action))\nwhile(cond) action (`while`(cond, action))\nrepeat expr (`repeat`(expr))\nnext (`next`())\nbreak (`break`())\n\nFinalmente, la más compleja es la función function:\n\nfunction(arg1, arg2) {body} (`function`(alist(arg1, arg2), body, env))\n\nConocer el nombre de la función que subyace en una forma especial es útil para obtener documentación: ?( es un error de sintaxis; ?`(` le dará la documentación para los paréntesis.\nTodas las formas especiales se implementan como funciones primitivas (es decir, en C); esto significa que imprimir estas funciones no es informativo:\n\n`for`\n#&gt; .Primitive(\"for\")\n\n\n\n6.8.6 Ejercicios\n\nReescriba los siguientes fragmentos de código en forma de prefijo:\n\n1 + 2 + 3\n\n1 + (2 + 3)\n\nif (length(x) &lt;= 5) x[[5]] else x[[n]]\n\nAclare la siguiente lista de llamadas a funciones impares:\n\nx &lt;- sample(replace = TRUE, 20, x = c(1:10, NA))\ny &lt;- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\n\nExplique por qué falla el siguiente código:\n\nmodify(get(\"x\"), 1) &lt;- 10\n#&gt; Error: target of assignment expands to non-language object\n\nCree una función de reemplazo que modifique una ubicación aleatoria en un vector.\nEscriba su propia versión de + que pegue sus entradas juntas si son vectores de caracteres, pero se comporte como de costumbre en caso contrario. En otras palabras, haz que este código funcione:\n\n1 + 2\n#&gt; [1] 3\n\n\"a\" + \"b\"\n#&gt; [1] \"ab\"\n\nCree una lista de todas las funciones de reemplazo que se encuentran en el paquete base. ¿Cuáles son funciones primitivas? (Sugerencia: utilice apropos().)\n¿Cuáles son los nombres válidos para las funciones infijas creadas por el usuario?\nCree un operador infijo xor().\nCree versiones infijas de las funciones de conjunto intersect(), union() y setdiff(). Puede llamarlos %n%, %u% y %/% para que coincidan con las convenciones de las matemáticas.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#sec-function-answers",
    "href": "Functions.html#sec-function-answers",
    "title": "6  Funciones",
    "section": "6.9 Respuestas de la Prueba",
    "text": "6.9 Respuestas de la Prueba\n\nLos tres componentes de una función son su cuerpo, argumentos y entorno.\nf1(1)() devuelve 11.\nNormalmente lo escribirías en estilo infijo: 1 + (2 * 3).\nReescribiendo la llamada a mean(c(1:10, NA), na.rm = TRUE) es más fácil de entender.\nNo, no arroja un error porque el segundo argumento nunca se usa, por lo que nunca se evalúa.\nVea Secciones Sección 6.8.3 y Sección 6.8.4.\nUsas on.exit(); vea la Sección 6.7.4 para más detalles.\n\n\n\n\n\nBache, Stefan Milton, y Hadley Wickham. 2014. magrittr: A forward-pipe operator for R. http://magrittr.tidyverse.org/.\n\n\nHester, Jim, Kirill Müller, Kevin Ushey, Hadley Wickham, y Winston Chang. 2018. withr: Run code with temporarily modified global state. http://withr.r-lib.org.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Functions.html#footnotes",
    "href": "Functions.html#footnotes",
    "title": "6  Funciones",
    "section": "",
    "text": "Voy a “esconder” las respuestas a estos desafíos en las notas al pie. Intenta resolverlos antes de mirar la respuesta; esto le ayudará a recordar mejor la respuesta correcta. En este caso, g01() devolverá 20.↩︎\nLas funciones que citan automáticamente uno o más argumentos pueden anular las reglas de alcance predeterminadas para implementar otras variedades de alcance. Aprenderá más sobre eso en el Capítulo 20.↩︎\ng04() resulta en c(1, 2, 3).↩︎\ng11() devuelve 1 cada vez que se llama.↩︎\nLas funciones pueden salir de otras formas más esotéricas, como señalar una condición detectada por un controlador de salida, invocar un reinicio o presionar “Q” en un navegador interactivo.↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funciones</span>"
    ]
  },
  {
    "objectID": "Environments.html",
    "href": "Environments.html",
    "title": "7  Entornos",
    "section": "",
    "text": "7.1 Introduction\nEl entorno es la estructura de datos que impulsa el alcance. Este capítulo profundiza en los entornos, describe su estructura en profundidad y los usa para mejorar su comprensión de las cuatro reglas de scoping descritas en la Sección 6.4. Comprender los entornos no es necesario para el uso diario de R. Pero es importante comprenderlos porque impulsan muchas funciones importantes de R, como el scoping léxico, los espacios de nombres y las clases R6, e interactúan con la evaluación para brindarle herramientas poderosas para crear dominios. lenguajes específicos, como dplyr y ggplot2.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#introduction",
    "href": "Environments.html#introduction",
    "title": "7  Entornos",
    "section": "",
    "text": "Prueba\nSi puede responder correctamente las siguientes preguntas, ya conoce los temas más importantes de este capítulo. Puede encontrar las respuestas al final del capítulo en la Sección 7.7.\n\nEnumere al menos tres formas en que un entorno difiere de una lista.\n¿Cuál es el padre del medio ambiente global? ¿Cuál es el único entorno que no tiene un padre?\n¿Qué es el entorno envolvente de una función? ¿Por qué es importante?\n¿Cómo determina el entorno desde el que se llamó a una función?\n¿En qué se diferencian &lt;- y &lt;&lt;-?\n\n\n\nEstructura\n\nLa Sección 7.2 le presenta las propiedades básicas de un entorno y le muestra cómo crear el suyo propio.\nLa Sección 7.3 proporciona una plantilla de funciones para computar con entornos, ilustrando la idea con una función útil.\nLa Sección 7.4 describe entornos utilizados para fines especiales: para paquetes, dentro de funciones, para espacios de nombres y para la ejecución de funciones.\nLa Sección 7.5 explica el último entorno importante: el entorno de la persona que llama. Esto requiere que aprenda sobre la pila de llamadas, que describe cómo se llamó a una función. Habrás visto la pila de llamadas si alguna vez llamaste a traceback() para ayudar en la depuración.\nLa Sección 7.6 analiza brevemente tres lugares donde los entornos son estructuras de datos útiles para resolver otros problemas.\n\n\n\nRequisitos previos\nEste capítulo utilizará las funciones rlang para trabajar con entornos, ya que nos permite centrarnos en la esencia de los entornos, en lugar de los detalles secundarios.\n\nlibrary(rlang)\n\nLas funciones env_ en rlang están diseñadas para trabajar con la canalización: todas toman un entorno como primer argumento, y muchas también devuelven un entorno. No usaré la canalización en este capítulo con el fin de mantener el código lo más simple posible, pero debería considerarlo para su propio código.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#sec-env-basics",
    "href": "Environments.html#sec-env-basics",
    "title": "7  Entornos",
    "section": "7.2 Conceptos básicos de entornos",
    "text": "7.2 Conceptos básicos de entornos\nEn general, un entorno es similar a una lista con nombre, con cuatro excepciones importantes:\n\nCada nombre debe ser único.\nLos nombres de un entorno no están ordenados.\nUn entorno tiene un padre.\nLos entornos no se copian cuando se modifican.\n\nExploremos estas ideas con código e imágenes.\n\n7.2.1 Lo esencial\n \nPara crear un entorno, utilice rlang::env(). Funciona como list(), tomando un conjunto de pares nombre-valor:\n\ne1 &lt;- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n\n\nUtilice new.env() para crear un nuevo entorno. Ignora los parámetros hash y size; no son necesarios. No puede crear y definir valores simultáneamente; use $&lt;-, como se muestra a continuación.\n\nEl trabajo de un entorno es asociar, o vincular, un conjunto de nombres a un conjunto de valores. Puede pensar en un entorno como una bolsa de nombres, sin orden implícito (es decir, no tiene sentido preguntar cuál es el primer elemento en un entorno). Por esa razón, dibujaremos el entorno así:\n\n\n\n\n\n\n\n\n\nComo se discutió en la Sección 2.5.2, los entornos tienen una semántica de referencia: a diferencia de la mayoría de los objetos R, cuando los modifica, los modifica en su lugar y no crea una copia. Una implicación importante es que los entornos pueden contenerse a sí mismos.\n\ne1$d &lt;- e1\n\n\n\n\n\n\n\n\n\n\nImprimir un entorno solo muestra su dirección de memoria, lo que no es muy útil:\n\ne1\n#&gt; &lt;environment: 0x5600b63e79a0&gt;\n\nEn su lugar, usaremos env_print() que nos brinda un poco más de información:\n\nenv_print(e1)\n#&gt; &lt;environment: 0x5600b63e79a0&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;lgl&gt;\n#&gt; • b: &lt;chr&gt;\n#&gt; • c: &lt;dbl&gt;\n#&gt; • d: &lt;env&gt;\n\nPuede usar env_names() para obtener un vector de caracteres que proporcione los enlaces actuales\n\nenv_names(e1)\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n\n\nEn R 3.2.0 y versiones posteriores, use names() para enumerar los enlaces en un entorno. Si su código necesita funcionar con R 3.1.0 o anterior, use ls(), pero tenga en cuenta que deberá configurar all.names = TRUE para mostrar todos los enlaces.\n\n\n\n7.2.2 Entornos importantes\n \nHablaremos en detalle sobre entornos especiales en Sección 7.4, pero por ahora necesitamos mencionar dos. El entorno actual, o current_env() es el entorno en el que el código se está ejecutando actualmente. Cuando estás experimentando de forma interactiva, ese suele ser el entorno global, o global_env(). El entorno global a veces se llama su “área de trabajo”, ya que es donde se lleva a cabo todo el cálculo interactivo (es decir, fuera de una función).\nPara comparar entornos, debe usar identical() y no ==. Esto se debe a que == es un operador vectorizado y los entornos no son vectores.\n\nidentical(global_env(), current_env())\n#&gt; [1] TRUE\n\nglobal_env() == current_env()\n#&gt; Error in global_env() == current_env(): comparison (==) is possible only for atomic and list types\n\n\nAccede al entorno global con globalenv() y al entorno actual con environment(). El entorno global se imprime como R_GlobalEnv y .GlobalEnv.\n\n\n\n7.2.3 Padres\n \nCada entorno tiene un padre, otro entorno. En los diagramas, el padre se muestra como un pequeño círculo azul pálido y una flecha que apunta a otro entorno. El padre es lo que se usa para implementar el scoping léxico: si un nombre no se encuentra en un entorno, entonces R buscará en su padre (y así sucesivamente). Puede configurar el entorno principal proporcionando un argumento sin nombre a env(). Si no lo proporciona, el valor predeterminado es el entorno actual. En el siguiente código, e2a es el padre de e2b.\n\ne2a &lt;- env(d = 4, e = 5)\ne2b &lt;- env(e2a, a = 1, b = 2, c = 3)\n\n\n\n\n\n\n\n\n\n\nPara ahorrar espacio, normalmente no dibujaré a todos los antepasados; solo recuerda que cada vez que veas un círculo azul pálido, hay un entorno principal en alguna parte.\nPuedes encontrar el padre de un entorno con env_parent():\n\nenv_parent(e2b)\n#&gt; &lt;environment: 0x5600b7868fd0&gt;\nenv_parent(e2a)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nSolo un entorno no tiene un padre: el entorno vacío. Dibujo el entorno vacío con un entorno principal vacío y, cuando el espacio lo permita, lo etiquetaré con R_EmptyEnv, el nombre que usa R.\n\ne2c &lt;- env(empty_env(), d = 4, e = 5)\ne2d &lt;- env(e2c, a = 1, b = 2, c = 3)\n\n\n\n\n\n\n\n\n\n\nLos ancestros de cada ambiente eventualmente terminan con el ambiente vacío. Puedes ver todos los ancestros con env_parents():\n\nenv_parents(e2b)\n#&gt; [[1]]   &lt;env: 0x5600b7868fd0&gt;\n#&gt; [[2]] $ &lt;env: global&gt;\nenv_parents(e2d)\n#&gt; [[1]]   &lt;env: 0x5600b4fc68c0&gt;\n#&gt; [[2]] $ &lt;env: empty&gt;\n\nPor defecto, env_parents() se detiene cuando llega al entorno global. Esto es útil porque los ancestros del entorno global incluyen todos los paquetes adjuntos, que puede ver si anula el comportamiento predeterminado como se muestra a continuación. Volveremos a estos entornos en la Sección 7.4.1.\n\nenv_parents(e2b, last = empty_env())\n#&gt;  [[1]]   &lt;env: 0x5600b7868fd0&gt;\n#&gt;  [[2]] $ &lt;env: global&gt;\n#&gt;  [[3]] $ &lt;env: package:rlang&gt;\n#&gt;  [[4]] $ &lt;env: package:stats&gt;\n#&gt;  [[5]] $ &lt;env: package:graphics&gt;\n#&gt;  [[6]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[7]] $ &lt;env: package:datasets&gt;\n#&gt;  [[8]] $ &lt;env: renv:shims&gt;\n#&gt;  [[9]] $ &lt;env: package:utils&gt;\n#&gt; [[10]] $ &lt;env: package:methods&gt;\n#&gt; [[11]] $ &lt;env: Autoloads&gt;\n#&gt; [[12]] $ &lt;env: package:base&gt;\n#&gt; [[13]] $ &lt;env: empty&gt;\n\n\nUse parent.env() para encontrar el padre de un entorno. Ninguna función base devuelve todos los ancestros.\n\n\n\n7.2.4 Asignación superior, &lt;&lt;-\n\n \nLos ancestros de un entorno tienen una relación importante con &lt;&lt;-. La asignación regular, &lt;-, siempre crea una variable en el entorno actual. La súper asignación, &lt;&lt;-, nunca crea una variable en el entorno actual, sino que modifica una variable existente que se encuentra en un entorno principal.\n\nx &lt;- 0\nf &lt;- function() {\n  x &lt;&lt;- 1\n}\nf()\nx\n#&gt; [1] 1\n\nSi &lt;&lt;- no encuentra una variable existente, creará una en el entorno global. Esto generalmente no es deseable, porque las variables globales introducen dependencias no obvias entre funciones. &lt;&lt;- se usa más a menudo junto con una fábrica de funciones, como se describe en la Sección 10.2.4.\n\n\n7.2.5 Conseguir y configurar\n \nPuede obtener y establecer elementos de un entorno con $ y [[ de la misma manera que una lista:\n\ne3 &lt;- env(x = 1, y = 2)\ne3$x\n#&gt; [1] 1\ne3$z &lt;- 3\ne3[[\"z\"]]\n#&gt; [1] 3\n\nPero no puedes usar [[ con índices numéricos, y no puedes usar [:\n\ne3[[1]]\n#&gt; Error in e3[[1]]: wrong arguments for subsetting an environment\n\ne3[c(\"x\", \"y\")]\n#&gt; Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\n\n$ y [[ devolverán NULL si el enlace no existe. Usa env_get() si quieres un error:\n\ne3$xyz\n#&gt; NULL\n\nenv_get(e3, \"xyz\")\n#&gt; Error in `env_get()`:\n#&gt; ! Can't find `xyz` in environment.\n\nSi desea usar un valor predeterminado si el enlace no existe, puede usar el argumento default.\n\nenv_get(e3, \"xyz\", default = NA)\n#&gt; [1] NA\n\nHay otras dos formas de agregar enlaces a un entorno:\n\nenv_poke()1 toma un nombre (como cadena) y un valor:\n\nenv_poke(e3, \"a\", 100)\ne3$a\n#&gt; [1] 100\n\nenv_bind() le permite vincular múltiples valores:\n\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n#&gt; [1] \"x\" \"y\" \"z\" \"a\" \"b\"\n\n\nPuede determinar si un entorno tiene un enlace con env_has():\n\nenv_has(e3, \"a\")\n#&gt;    a \n#&gt; TRUE\n\nA diferencia de las listas, establecer un elemento en NULL no lo elimina, porque a veces desea un nombre que se refiera a NULL. En su lugar, usa env_unbind():\n\ne3$a &lt;- NULL\nenv_has(e3, \"a\")\n#&gt;    a \n#&gt; TRUE\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n#&gt;     a \n#&gt; FALSE\n\nDesvincular un nombre no elimina el objeto. Ese es el trabajo del recolector de basura, que elimina automáticamente los objetos sin nombres vinculados a ellos. Este proceso se describe con más detalle en la Sección 2.6.\n\n Consulte get(), assign(), exists() y rm(). Estos están diseñados de forma interactiva para su uso con el entorno actual, por lo que trabajar con otros entornos es un poco complicado. También tenga cuidado con el argumento inherits: por defecto es TRUE, lo que significa que los equivalentes base inspeccionarán el entorno suministrado y todos sus ancestros.\n\n\n\n7.2.6 Enlaces avanzados\n \nHay dos variantes más exóticas de env_bind():\n\nenv_bind_lazy() crea enlaces retrasados, que se evalúan la primera vez que se accede a ellos. Detrás de escena, los enlaces retrasados crean promesas, por lo que se comportan de la misma manera que los argumentos de función.\n\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;   0.001   0.000   1.001\nsystem.time(print(b))\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       0\n\nEl uso principal de los enlaces retrasados es autoload(), que permite que los paquetes de R proporcionen conjuntos de datos que se comportan como si estuvieran cargados en la memoria, aunque solo se cargan desde el disco cuando es necesario.\nenv_bind_active() crea enlaces activos que se vuelven a calcular cada vez que se accede a ellos:\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#&gt; [1] 0.0808\nz1\n#&gt; [1] 0.834\n\nLos enlaces activos se utilizan para implementar los campos activos de R6, sobre los que aprenderá en la Sección 14.3.2.\n\n\nConsulte ?delayedAssign() y ?makeActiveBinding().\n\n\n\n7.2.7 Ejercicios\n\nEnumera tres formas en las que un entorno difiere de una lista.\nCree un entorno como el que se ilustra en esta imagen.\n\n\n\n\n\n\n\n\n\nCree un par de ambientes como se ilustra en esta imagen.\n\n\n\n\n\n\n\n\n\nExplique por qué e[[1]] y e[c(\"a\", \"b\")] no tienen sentido cuando e es un entorno.\nCree una versión de env_poke() que solo vinculará nombres nuevos, nunca volverá a vincular nombres antiguos. Algunos lenguajes de programación solo hacen esto y se conocen como [lenguajes de asignación única] (http://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment).\n¿Qué hace esta función? ¿En qué se diferencia de &lt;&lt;- y por qué podría preferirlo?\n\nrebind &lt;- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"a\", 10)\n#&gt; Error: Can't find `a`\na &lt;- 5\nrebind(\"a\", 10)\na\n#&gt; [1] 10",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#sec-env-recursion",
    "href": "Environments.html#sec-env-recursion",
    "title": "7  Entornos",
    "section": "7.3 Recursing sobre entornos",
    "text": "7.3 Recursing sobre entornos\n\nSi desea operar en todos los ancestros de un entorno, a menudo es conveniente escribir una función recursiva. Esta sección le muestra cómo, aplicando su nuevo conocimiento de entornos para escribir una función que, dado un nombre, encuentra el entorno where() está definido ese nombre, utilizando las reglas de alcance habituales de R.\nLa definición de where() es sencilla. Tiene dos argumentos: el nombre a buscar (como una cadena) y el entorno en el que iniciar la búsqueda. (Aprenderemos por qué caller_env() es un buen valor predeterminado en la Sección 7.5.)\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # caso base\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # caso de exitoso\n    env\n  } else {\n    # caso recursivo\n    where(name, env_parent(env))\n  }\n}\n\nHay tres casos:\n\nEl caso base: hemos llegado al entorno vacío y no hemos encontrado el enlace. No podemos ir más lejos, por lo que lanzamos un error.\nEl caso exitoso: el nombre existe en este entorno, por lo que devolvemos el entorno.\nEl caso recursivo: el nombre no se encontró en este entorno, así que pruebe con el padre.\n\nEstos tres casos se ilustran con estos tres ejemplos:\n\nwhere(\"yyy\")\n#&gt; Error: Can't find yyy\n\nx &lt;- 5\nwhere(\"x\")\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nwhere(\"mean\")\n#&gt; &lt;environment: base&gt;\n\nPodría ayudar ver una imagen. Imagine que tiene dos entornos, como en el siguiente código y diagrama:\n\ne4a &lt;- env(empty_env(), a = 1, b = 2)\ne4b &lt;- env(e4a, x = 10, a = 11)\n\n\n\n\n\n\n\n\n\n\n\nwhere(\"a\", e4b) encontrará a en e4b.\nwhere(\"b\", e4b) no encuentra b en e4b, así que busca en su padre, e4a, y lo encuentra ahí.\nwhere(\"c\", e4b) busca en e4b, entonces e4a, luego llega al entorno vacío y arroja un error.\n\nEs natural trabajar con entornos recursivamente, por lo que where() proporciona una plantilla útil. Eliminar los detalles de where() muestra la estructura más claramente:\n\nf &lt;- function(..., env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # caso base\n  } else if (success) {\n    # caso exitoso\n  } else {\n    # caso recursivo\n    f(..., env = env_parent(env))\n  }\n}\n\n\nIteración versus recursividad\nEs posible usar un bucle en lugar de recursividad. Creo que es más difícil de entender que la versión recursiva, pero la incluyo porque puede resultarle más fácil ver lo que sucede si no ha escrito muchas funciones recursivas.\n\nf2 &lt;- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # caso exitoso\n      return()\n    }\n    # inspeccionar padre\n    env &lt;- env_parent(env)\n  }\n\n  # caso base\n}\n\n\n\n7.3.1 Ejercicios\n\nModifique where() para devolver todos los entornos que contienen un enlace para name. Piensa detenidamente qué tipo de objeto necesitará devolver la función.\nEscribe una función llamada fget() que encuentre solo objetos de función. Debe tener dos argumentos, name y env, y debe obedecer las reglas regulares de alcance de las funciones: si hay un objeto con un nombre coincidente que no es una función, busque en el padre. Para un desafío adicional, agregue también un argumento inherits que controle si la función recurre a los padres o solo busca en un entorno.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#sec-special-environments",
    "href": "Environments.html#sec-special-environments",
    "title": "7  Entornos",
    "section": "7.4 Entornos especiales",
    "text": "7.4 Entornos especiales\nLa mayoría de los entornos no los crea usted (por ejemplo, con env()), sino que los crea R. En esta sección, aprenderá sobre los entornos más importantes, comenzando con los entornos de paquete. Luego, aprenderá sobre el entorno de la función vinculado a la función cuando se crea y el entorno de ejecución (generalmente) efímero que se crea cada vez que se llama a la función. Finalmente, verá cómo los entornos de funciones y paquetes interactúan para admitir espacios de nombres, lo que garantiza que un paquete siempre se comporte de la misma manera, independientemente de qué otros paquetes haya cargado el usuario.\n\n7.4.1 Entornos de paquetes y la ruta de búsqueda\n\n \nCada paquete adjunto por library() o require() se convierte en uno de los padres del entorno global. El padre inmediato del entorno global es el último paquete que adjuntó 2, el padre de ese paquete es el penúltimo paquete que adjuntó, …\n\n\n\n\n\n\n\n\n\nSi sigue a todos los padres hacia atrás, verá el orden en que se adjuntó cada paquete. Esto se conoce como ruta de búsqueda porque todos los objetos en estos entornos se pueden encontrar desde el espacio de trabajo interactivo de nivel superior. Puede ver los nombres de estos entornos con base::search(), o los propios entornos con rlang::search_envs():\n\nsearch()\n#&gt;  [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n#&gt;  [4] \"package:graphics\"  \"package:grDevices\" \"package:datasets\" \n#&gt;  [7] \"renv:shims\"        \"package:utils\"     \"package:methods\"  \n#&gt; [10] \"Autoloads\"         \"package:base\"\n\nsearch_envs()\n#&gt;  [[1]] $ &lt;env: global&gt;\n#&gt;  [[2]] $ &lt;env: package:rlang&gt;\n#&gt;  [[3]] $ &lt;env: package:stats&gt;\n#&gt;  [[4]] $ &lt;env: package:graphics&gt;\n#&gt;  [[5]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[6]] $ &lt;env: package:datasets&gt;\n#&gt;  [[7]] $ &lt;env: renv:shims&gt;\n#&gt;  [[8]] $ &lt;env: package:utils&gt;\n#&gt;  [[9]] $ &lt;env: package:methods&gt;\n#&gt; [[10]] $ &lt;env: Autoloads&gt;\n#&gt; [[11]] $ &lt;env: package:base&gt;\n\nLos dos últimos entornos en la ruta de búsqueda son siempre los mismos:\n\nEl entorno Autoloads utiliza enlaces retrasados para ahorrar memoria al cargar solo objetos del paquete (como grandes conjuntos de datos) cuando es necesario.\nEl entorno base, package: base o, a veces, simplemente base, es el entorno del paquete base. Es especial porque debe poder iniciar la carga de todos los demás paquetes. Puedes acceder a él directamente con base_env().\n\nTenga en cuenta que cuando adjunta otro paquete con library(), el entorno principal del entorno global cambia:\n\n\n\n\n\n\n\n\n\n\n\n7.4.2 El entorno funcional\n \nUna función vincula el entorno actual cuando se crea. Esto se denomina entorno de función y se utiliza para el scoping léxico. En todos los lenguajes informáticos, las funciones que capturan (o encierran) sus entornos se denominan cierres, razón por la cual este término a menudo se usa indistintamente con función en la documentación de R.\nPuede obtener el entorno de la función con fn_env():\n\ny &lt;- 1\nf &lt;- function(x) x + y\nfn_env(f)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\nUtilice environment(f) para acceder al entorno de la función f.\n\nEn los diagramas, dibujaré una función como un rectángulo con un extremo redondeado que une un entorno.\n\n\n\n\n\n\n\n\n\nEn este caso, f() vincula el entorno que vincula el nombre f a la función. Pero ese no es siempre el caso: en el siguiente ejemplo, g está enlazado en un nuevo entorno e, pero g() enlaza el entorno global. La distinción entre atar y ser atado por es sutil pero importante; la diferencia es cómo encontramos g versus cómo g encuentra sus variables.\n\ne &lt;- env()\ne$g &lt;- function() 1\n\n\n\n\n\n\n\n\n\n\n\n\n7.4.3 Espacios de nombres\n\nEn el diagrama anterior, vio que el entorno principal de un paquete varía según los otros paquetes que se hayan cargado. Esto parece preocupante: ¿no significa eso que el paquete encontrará diferentes funciones si los paquetes se cargan en un orden diferente? El objetivo de los espacios de nombres es asegurarse de que esto no suceda y de que todos los paquetes funcionen de la misma manera, independientemente de los paquetes que adjunte el usuario.\nPor ejemplo, tome sd():\n\nsd\n#&gt; function (x, na.rm = FALSE) \n#&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#&gt;     na.rm = na.rm))\n#&gt; &lt;bytecode: 0x5600b68e40f0&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nsd() se define en términos de var(), por lo que podría preocuparse de que el resultado de sd() se vea afectado por cualquier función llamada var() ya sea en el entorno global o en uno de los otros paquetes adjuntos . R evita este problema aprovechando el entorno de función versus enlace descrito anteriormente. Cada función en un paquete está asociada con un par de entornos: el entorno del paquete, del que aprendió anteriormente, y el entorno del espacio de nombres.\n\nEl entorno del paquete es la interfaz externa del paquete. Así es como usted, el usuario de R, encuentra una función en un paquete adjunto o con ::. Su padre está determinado por la ruta de búsqueda, es decir, el orden en que se han adjuntado los paquetes.\nEl entorno del espacio de nombres es la interfaz interna del paquete. El entorno del paquete controla cómo encontramos la función; el espacio de nombres controla cómo la función encuentra sus variables.\n\nCada enlace en el entorno del paquete también se encuentra en el entorno del espacio de nombres; esto asegura que cada función pueda usar cualquier otra función en el paquete. Pero algunos enlaces solo ocurren en el entorno del espacio de nombres. Estos se conocen como objetos internos o no exportados, que permiten ocultar al usuario detalles de implementación internos.\n\n\n\n\n\n\n\n\n\nCada entorno de espacio de nombres tiene el mismo conjunto de ancestros:\n\nCada espacio de nombres tiene un entorno de importaciones que contiene enlaces a todas las funciones utilizadas por el paquete. El entorno de importación está controlado por el desarrollador del paquete con el archivo NAMESPACE.\nLa importación explícita de cada función base sería tediosa, por lo que el padre del entorno de importación es el espacio de nombres base. El espacio de nombres base contiene los mismos enlaces que el entorno base, pero tiene un padre diferente.\nEl padre del espacio de nombres base es el entorno global. Esto significa que si un enlace no está definido en el entorno de importación, el paquete lo buscará de la forma habitual. Esto suele ser una mala idea (porque hace que el código dependa de otros paquetes cargados), por lo que R CMD check advierte automáticamente sobre dicho código. Es necesario principalmente por razones históricas, particularmente debido a cómo funciona el envío del método S3.\n\n\n\n\n\n\n\n\n\n\nJuntando todos estos diagramas obtenemos:\n\n\n\n\n\n\n\n\n\nEntonces, cuando sd() busca el valor de var, siempre lo encuentra en una secuencia de entornos determinada por el desarrollador del paquete, pero no por el usuario del paquete. Esto garantiza que el código del paquete siempre funcione de la misma manera, independientemente de los paquetes que haya adjuntado el usuario.\nNo existe un vínculo directo entre el paquete y los entornos de espacio de nombres; el enlace está definido por los entornos de función.\n\n\n7.4.4 Entornos de ejecución\n \nEl último tema importante que debemos cubrir es el entorno de ejecución. ¿Qué devolverá la siguiente función la primera vez que se ejecute? ¿Qué pasa con el segundo?\n\ng &lt;- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\nPiénsalo un momento antes de seguir leyendo.\n\ng(10)\n#&gt; Defining a\n#&gt; [1] 1\ng(10)\n#&gt; Defining a\n#&gt; [1] 1\n\nEsta función devuelve el mismo valor cada vez debido al principio de nuevo comienzo, descrito en la Sección 6.4.3. Cada vez que se llama a una función, se crea un nuevo entorno para albergar la ejecución. Esto se denomina entorno de ejecución y su padre es el entorno de funciones. Ilustremos ese proceso con una función más simple. La figura Figura 7.1 ilustra las convenciones gráficas: dibujo entornos de ejecución con un padre indirecto; el entorno principal se encuentra a través del entorno de función.\n\nh &lt;- function(x) {\n  # 1.\n  a &lt;- 2 # 2.\n  x + a\n}\ny &lt;- h(1) # 3.\n\n\n\n\n\n\n\n\n\nFigura 7.1: The execution environment of a simple function call. Note that the parent of the execution environment is the function environment.\n\n\n\n\n\nUn entorno de ejecución suele ser efímero; una vez que la función se haya completado, el entorno se recolectará como basura. Hay varias maneras de hacer que se quede por más tiempo. El primero es devolverlo explícitamente:\n\nh2 &lt;- function(x) {\n  a &lt;- x * 2\n  current_env()\n}\n\ne &lt;- h2(x = 10)\nenv_print(e)\n#&gt; &lt;environment: 0x5600b95a68a8&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;dbl&gt;\n#&gt; • x: &lt;dbl&gt;\nfn_env(h2)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nOtra forma de capturarlo es devolver un objeto con un enlace a ese entorno, como una función. El siguiente ejemplo ilustra esa idea con una fábrica de funciones, plus(). Usamos esa fábrica para crear una función llamada plus_one().\nEstán sucediendo muchas cosas en el diagrama porque el entorno envolvente de plus_one() es el entorno de ejecución de plus().\n\nplus &lt;- function(x) {\n  function(y) x + y\n}\n\nplus_one &lt;- plus(1)\nplus_one\n#&gt; function(y) x + y\n#&gt; &lt;environment: 0x5600b9e1ad70&gt;\n\n\n\n\n\n\n\n\n\n\n¿Qué sucede cuando llamamos plus_one()? Su entorno de ejecución tendrá el entorno de ejecución capturado de plus() como padre:\n\nplus_one(2)\n#&gt; [1] 3\n\n\n\n\n\n\n\n\n\n\nAprenderá más sobre las fábricas de funciones en la Sección 10.2.\n\n\n7.4.5 Ejercicios\n\n¿En qué se diferencia search_envs() de env_parents(global_env())?\nDibuje un diagrama que muestre los entornos circundantes de esta función:\n\nf1 &lt;- function(x1) {\n  f2 &lt;- function(x2) {\n    f3 &lt;- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)\n\nEscriba una versión mejorada de str() que proporcione más información sobre las funciones. Muestre dónde se encontró la función y en qué entorno se definió.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#sec-call-stack",
    "href": "Environments.html#sec-call-stack",
    "title": "7  Entornos",
    "section": "7.5 Pilas de llamadas",
    "text": "7.5 Pilas de llamadas\n \nHay un último entorno que debemos explicar, el entorno caller, al que se accede con rlang::caller_env(). Esto proporciona el entorno desde el que se llamó a la función y, por lo tanto, varía en función de cómo se llame a la función, no de cómo se creó. Como vimos anteriormente, este es un valor predeterminado útil cada vez que escribe una función que toma un entorno como argumento.\n\nparent.frame() es equivalente a caller_env(); solo tenga en cuenta que devuelve un entorno, no un marco.\n\nPara comprender completamente el entorno de la persona que llama, debemos analizar dos conceptos relacionados: la pila de llamadas, que se compone de marcos. La ejecución de una función crea dos tipos de contexto. Ya aprendió sobre uno: el entorno de ejecución es un elemento secundario del entorno de función, que está determinado por el lugar donde se creó la función. Hay otro tipo de contexto creado por donde se llamó a la función: esto se llama la pila de llamadas.\n\n\n7.5.1 Pilas de llamadas simples\nIlustremos esto con una secuencia simple de llamadas: f() llama a g() llama a h().\n\nf &lt;- function(x) {\n  g(x = 2)\n}\ng &lt;- function(x) {\n  h(x = 3)\n}\nh &lt;- function(x) {\n  stop()\n}\n\nLa forma más común de ver una pila de llamadas en R es mirando el traceback() después de que haya ocurrido un error:\n\nf(x = 1)\n#&gt; Error:\ntraceback()\n#&gt; 4: stop()\n#&gt; 3: h(x = 3) \n#&gt; 2: g(x = 2)\n#&gt; 1: f(x = 1)\n\nEn lugar de stop() + traceback() para entender la pila de llamadas, vamos a usar lobstr::cst() para imprimir el árbol de pilas de llamadas (call stack tree, en inglés):\n\nh &lt;- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n#&gt; █\n#&gt; └─f(x = 1)\n#&gt;   └─g(x = 2)\n#&gt;     └─h(x = 3)\n#&gt;       └─lobstr::cst()\n\nEsto nos muestra que cst() fue llamado desde h(), que fue llamado desde g(), que fue llamado desde f(). Tenga en cuenta que el orden es el opuesto de traceback(). A medida que las pilas de llamadas se vuelven más complicadas, creo que es más fácil entender la secuencia de llamadas si comienza desde el principio, en lugar del final (es decir, f() llama a g(); en lugar de g() fue llamado por f()).\n\n\n7.5.2 Evaluación perezosa\n\nLa pila de llamadas anterior es simple: mientras obtiene una pista de que hay una estructura similar a un árbol involucrada, todo sucede en una sola rama. Esto es típico de una pila de llamadas cuando todos los argumentos se evalúan con entusiasmo.\nVamos a crear un ejemplo más complicado que implique una evaluación perezosa. Crearemos una secuencia de funciones, a(), b(), c(), que pasan un argumento x.\n\na &lt;- function(x) b(x)\nb &lt;- function(x) c(x)\nc &lt;- function(x) x\n\na(f())\n#&gt; █\n#&gt; ├─a(f())\n#&gt; │ └─b(x)\n#&gt; │   └─c(x)\n#&gt; └─f()\n#&gt;   └─g(x = 2)\n#&gt;     └─h(x = 3)\n#&gt;       └─lobstr::cst()\n\nx se evalúa perezosamente, por lo que este árbol tiene dos ramas. En la primera rama a() llama a b(), luego b() llama a c(). La segunda rama comienza cuando c() evalúa su argumento x. Este argumento se evalúa en una nueva rama porque el entorno en el que se evalúa es el entorno global, no el entorno de c().\n\n\n7.5.3 Marcos\n \nCada elemento de la pila de llamadas es un marco3, también conocido como contexto de evaluación. El marco es una estructura de datos interna extremadamente importante, y el código R solo puede acceder a una pequeña parte de la estructura de datos porque manipularlo romperá R. Un marco tiene tres componentes clave:\n\nUna expresión (etiquetada con expr) que da la llamada a la función. Esto es lo que imprime traceback().\nUn entorno (etiquetado con env), que suele ser el entorno de ejecución de una función. Hay dos excepciones principales: el entorno del marco global es el entorno global, y llamar a eval() también genera marcos, donde el entorno puede ser cualquier cosa.\nUn padre, la llamada anterior en la pila de llamadas (se muestra con una flecha gris).\n\nLa figura Figura 7.2 ilustra la pila para la llamada a f(x = 1) que se muestra en la Sección 7.5.1.\n\n\n\n\n\n\n\n\nFigura 7.2: The graphical depiction of a simple call stack\n\n\n\n\n\n(Para centrarme en los entornos de llamada, he omitido los enlaces en el entorno global de f, g y h a los objetos de función respectivos.)\nEl marco también contiene controladores de salida creados con on.exit(), reinicios y controladores para el sistema de condiciones, y a qué contexto return() cuando se completa una función. Estos son detalles internos importantes a los que no se puede acceder con el código R.\n\n\n7.5.4 Alcance dinámico\n\nLa búsqueda de variables en la pila de llamadas en lugar de en el entorno adjunto se denomina ámbito dinámico. Pocos lenguajes implementan el alcance dinámico (Emacs Lisp es una [excepción notable] (http://www.gnu.org/software/emacs/emacs-paper.html#SEC15).) Esto se debe a que el alcance dinámico hace que sea mucho más difícil razonar sobre cómo opera una función: no solo necesita saber cómo se definió, también necesita saber el contexto en el que se llamó. El alcance dinámico es principalmente útil para desarrollar funciones que ayudan al análisis interactivo de datos y es uno de los temas tratados en el Capítulo 20.\n\n\n7.5.5 Ejercicios\n\nEscriba una función que enumere todas las variables definidas en el entorno en el que se llamó. Debería devolver los mismos resultados que ls().",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#sec-explicit-envs",
    "href": "Environments.html#sec-explicit-envs",
    "title": "7  Entornos",
    "section": "7.6 Como estructuras de datos",
    "text": "7.6 Como estructuras de datos\n \nAdemás de potenciar el alcance, los entornos también son estructuras de datos útiles por derecho propio porque tienen semántica de referencia. Hay tres problemas comunes que pueden ayudar a resolver:\n\nEvitar copias de datos de gran tamaño. Dado que los entornos tienen semántica de referencia, nunca creará una copia accidentalmente. Pero es complicado trabajar con entornos desnudos, por lo que en su lugar recomiendo usar objetos R6, que se construyen sobre los entornos. Obtenga más información en el Capítulo 14.\nAdministrar el estado dentro de un paquete. Los entornos explícitos son útiles en los paquetes porque le permiten mantener el estado en las llamadas a funciones. Normalmente, los objetos de un paquete están bloqueados, por lo que no puede modificarlos directamente. En su lugar, puedes hacer algo como esto:\n\nmy_env &lt;- new.env(parent = emptyenv())\nmy_env$a &lt;- 1\n\nget_a &lt;- function() {\n  my_env$a\n}\nset_a &lt;- function(value) {\n  old &lt;- my_env$a\n  my_env$a &lt;- value\n  invisible(old)\n}\n\nDevolver el valor anterior de las funciones de establecimiento es un buen patrón porque hace que sea más fácil restablecer el valor anterior junto con on.exit() (Sección 6.7.4).\nComo hashmap. Un hashmap es una estructura de datos que toma tiempo constante, O(1), para encontrar un objeto basado en su nombre. Los entornos proporcionan este comportamiento de forma predeterminada, por lo que se pueden usar para simular un mapa hash. Vea el paquete hash (Brown 2013) para un desarrollo completo de esta idea.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#sec-env-answers",
    "href": "Environments.html#sec-env-answers",
    "title": "7  Entornos",
    "section": "7.7 Respuestas de la prueba",
    "text": "7.7 Respuestas de la prueba\n\nHay cuatro formas: cada objeto en un entorno debe tener un nombre; el orden no importa; los ambientes tienen padres; los entornos tienen semántica de referencia.\nEl padre del entorno global es el último paquete que cargó. El único entorno que no tiene un padre es el entorno vacío.\nEl entorno envolvente de una función es el entorno donde se creó. Determina dónde una función busca variables.\nUse caller_env() o parent.frame().\n&lt;- siempre crea un enlace en el entorno actual; &lt;&lt;- vuelve a enlazar un nombre existente en un padre del entorno actual.\n\n\n\n\n\nBrown, Christopher. 2013. hash: Full feature implementation of hash/associated arrays/dictionaries. https://CRAN.R-project.org/package=hash.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Environments.html#footnotes",
    "href": "Environments.html#footnotes",
    "title": "7  Entornos",
    "section": "",
    "text": "Quizás se pregunte por qué rlang tiene env_poke() en lugar de env_set(). Esto es por coherencia: las funciones _set() devuelven una copia modificada; Las funciones _poke() se modifican en su lugar.↩︎\nTenga en cuenta la diferencia entre adjunto y cargado. Un paquete se carga automáticamente si accede a una de sus funciones usando ::; solo se adjunta a la ruta de búsqueda mediante library() o require().↩︎\nNB: ?environment usa marco en un sentido diferente: “Los entornos consisten en un marco, o una colección de objetos con nombre, y un puntero a un entorno envolvente”. Evitamos este sentido de marco, que proviene de S, porque es muy específico y no se usa mucho en la base R. Por ejemplo, el marco en parent.frame() es un contexto de ejecución, no una colección de objetos con nombre.↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Entornos</span>"
    ]
  },
  {
    "objectID": "Conditions.html",
    "href": "Conditions.html",
    "title": "8  Condiciones",
    "section": "",
    "text": "8.1 Introducción\nEl sistema de condición proporciona un conjunto emparejado de herramientas que permiten al autor de una función indicar que algo inusual está sucediendo y al usuario de esa función manejarlo. El autor de la función señala las condiciones con funciones como stop() (para errores), warning() (para advertencias) y message() (para mensajes), luego el usuario de la función puede manejarlas. con funciones como tryCatch() y withCallingHandlers(). Comprender el sistema de condiciones es importante porque a menudo necesitará desempeñar ambos roles: señalar las condiciones de las funciones que crea y manejar las condiciones señaladas por las funciones que llama.\nR ofrece un sistema de condiciones muy poderoso basado en ideas de Common Lisp. Al igual que el enfoque de R para la programación orientada a objetos, es bastante diferente a los lenguajes de programación actualmente populares, por lo que es fácil malinterpretarlo y se ha escrito relativamente poco sobre cómo usarlo de manera efectiva. Históricamente, esto ha significado que pocas personas (incluido yo mismo) han aprovechado al máximo su poder. El objetivo de este capítulo es remediar esa situación. Aquí aprenderá sobre las grandes ideas del sistema de condiciones de R, además de aprender un montón de herramientas prácticas que fortalecerán su código.\nEncontré dos recursos particularmente útiles al escribir este capítulo. También puede leerlos si desea obtener más información sobre las inspiraciones y motivaciones del sistema:\nTambién encontré útil trabajar con el código C subyacente que implementa estas ideas. Si está interesado en entender cómo funciona todo, puede encontrar mis notas de utilidad.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#introducción",
    "href": "Conditions.html#introducción",
    "title": "8  Condiciones",
    "section": "",
    "text": "Un prototipo de un sistema de condiciones para R de Robert Gentleman y Luke Tierney. Esto describe una versión anterior del sistema de condiciones de R. Si bien la implementación ha cambiado un poco desde que se escribió este documento, proporciona una buena descripción general de cómo encajan las piezas y algo de motivación para su diseño.\nMás allá del manejo de excepciones: condiciones y reinicios de Peter Seibel. Esto describe el manejo de excepciones en Lisp, que resulta ser muy similar al enfoque de R. Proporciona una motivación útil y ejemplos más sofisticados. He proporcionado una traducción R del capítulo en http://adv-r.had.co.nz/beyond-exception-handling.html.\n\n\n\nPrueba\n¿Quieres saltarte este capítulo? Anímate, si puedes responder las siguientes preguntas. Encuentre las respuestas al final del capítulo en la Sección 8.7.\n\n¿Cuáles son los tres tipos de condiciones más importantes?\n¿Qué función utiliza para ignorar los errores en el bloque de código?\n¿Cuál es la principal diferencia entre tryCatch() y withCallingHandlers()?\n¿Por qué podría querer crear un objeto de error personalizado?\n\n\n\nEstructura\n\nLa Sección 8.2 presenta las herramientas básicas para las condiciones de señalización y analiza cuándo es apropiado usar cada tipo.\nLa Sección 8.3 le enseña sobre las herramientas más simples para manejar condiciones: funciones como try() y suppressMessages() que tragan condiciones y evitan que lleguen al nivel superior.\nLa Sección 8.4 introduce la condición objeto y las dos herramientas fundamentales del manejo de condiciones: tryCatch() para condiciones de error y withCallingHandlers() para todo lo demás.\nLa Sección 8.5 le muestra cómo ampliar los objetos de condición incorporados para almacenar datos útiles que los controladores de condiciones pueden usar para tomar decisiones más informadas.\nLa Sección 8.6 cierra el capítulo con una bolsa de sorpresas de aplicaciones prácticas basadas en las herramientas de bajo nivel que se encuentran en las secciones anteriores.\n\n\n\n8.1.1 Requisitos previos\nAdemás de las funciones básicas de R, este capítulo utiliza funciones de señalización y manejo de condiciones de rlang.\n\nlibrary(rlang)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#sec-signalling-conditions",
    "href": "Conditions.html#sec-signalling-conditions",
    "title": "8  Condiciones",
    "section": "8.2 Condiciones de señalización",
    "text": "8.2 Condiciones de señalización\n \nHay tres condiciones que puede señalar en el código: errores, advertencias y mensajes.\n\nLos errores son los más graves; indican que no hay forma de que una función continúe y la ejecución debe detenerse.\nLas advertencias se encuentran un poco entre los errores y los mensajes, y generalmente indican que algo salió mal pero la función se pudo recuperar al menos parcialmente.\nLos mensajes son los más suaves; son una forma de informar a los usuarios que se ha realizado alguna acción en su nombre.\n\nHay una condición final que solo se puede generar de forma interactiva: una interrupción, que indica que el usuario ha interrumpido la ejecución presionando Escape, Ctrl + Pausa o Ctrl + C (según la plataforma).\nLas condiciones generalmente se muestran de manera destacada, en negrita o en color rojo, según la interfaz de R. Puede distinguirlos porque los errores siempre comienzan con “Error”, las advertencias con “Warning” o “Warning message” y los mensajes sin nada.\n\nstop(\"Así es como se ve un error\")\n#&gt; Error in eval(expr, envir, enclos): Así es como se ve un error\n\nwarning(\"Así es como se ve una advertencia\")\n#&gt; Warning: Así es como se ve una advertencia\n\nmessage(\"Así es como se ve un mensaje\")\n#&gt; Así es como se ve un mensaje\n\nLas siguientes tres secciones describen errores, advertencias y mensajes con más detalle.\n\n8.2.1 Errores\n \nEn base R, los errores son señalados, o lanzados, por stop():\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() stop(\"¡Esto es un error!\")\n\nf()\n#&gt; Error in h(): ¡Esto es un error!\n\nDe forma predeterminada, el mensaje de error incluye la llamada, pero esto normalmente no es útil (y recapitula información que puede obtener fácilmente de traceback()), por lo que creo que es una buena práctica usar call. = FALSE1:\n\nh &lt;- function() stop(\"¡Esto es un error!\", call. = FALSE)\nf()\n#&gt; Error: ¡Esto es un error!\n\nEl rlang equivalente a stop(), rlang::abort(), hace esto automáticamente. Usaremos abort() a lo largo de este capítulo, pero no llegaremos a su característica más convincente, la capacidad de agregar metadatos adicionales al objeto de condición, hasta que estemos cerca del final del capítulo.\n\nh &lt;- function() abort(\"This is an error!\")\nf()\n#&gt; Error in `h()`:\n#&gt; ! This is an error!\n\n(NB: stop() pega varias entradas juntas, mientras que abort() no lo hace. Para crear mensajes de error complejos con abortar, recomiendo usar glue::glue(). Esto nos permite usar otros argumentos para abortar () para características útiles que aprenderá en la Sección 8.5.)\nLos mejores mensajes de error le dicen qué está mal y le indican la dirección correcta para solucionar el problema. Escribir buenos mensajes de error es difícil porque los errores generalmente ocurren cuando el usuario tiene un modelo mental defectuoso de la función. Como desarrollador, es difícil imaginar cómo el usuario podría estar pensando incorrectamente sobre su función y, por lo tanto, es difícil escribir un mensaje que dirija al usuario en la dirección correcta. Dicho esto, la guía de estilo de tidyverse analiza algunos principios generales que hemos encontrado útiles: http://style.tidyverse.org/error-messages.html.\n\n\n8.2.2 Advertencias\n\nLas advertencias, señaladas por warning(), son más débiles que los errores: indican que algo salió mal, pero el código pudo recuperarse y continuar. A diferencia de los errores, puede tener múltiples advertencias de una sola llamada de función:\n\nfw &lt;- function() {\n  cat(\"1\\n\")\n  warning(\"W1\")\n  cat(\"2\\n\")\n  warning(\"W2\")\n  cat(\"3\\n\")\n  warning(\"W3\")\n}\n\nDe forma predeterminada, las advertencias se almacenan en caché y se imprimen solo cuando el control vuelve al nivel superior:\n\nfw()\n#&gt; 1\n#&gt; 2\n#&gt; 3\n#&gt; Warning messages:\n#&gt; 1: In f() : W1\n#&gt; 2: In f() : W2\n#&gt; 3: In f() : W3\n\n Puedes controlar este comportamiento con la opción warn:\n\nPara que las advertencias aparezcan inmediatamente, configure options(warn = 1).\nPara convertir las advertencias en errores, establezca options(warn = 2). Esta suele ser la forma más fácil de depurar una advertencia, ya que una vez que se trata de un error, puede usar herramientas como traceback() para encontrar la fuente.\nRestaurar el comportamiento predeterminado con options(warn = 0).\n\nAl igual que stop(), warning() también tiene un argumento de llamada. Es un poco más útil (ya que las advertencias a menudo están más lejos de su fuente), pero generalmente lo suprimo con call. = FALSE. Al igual que rlang::abort(), el equivalente en rlang de warning(), rlang::warn(), también suprime la call por defecto.\nLas advertencias ocupan un lugar algo desafiante entre los mensajes (“debe saber sobre esto”) y los errores (“¡debe arreglar esto!”), y es difícil dar consejos precisos sobre cuándo usarlos. En general, tenga cuidado, ya que es fácil pasar por alto las advertencias si hay muchos otros resultados y no desea que su función se recupere con demasiada facilidad de una entrada claramente no válida. En mi opinión, la base R tiende a abusar de las advertencias, y muchas advertencias en la base R estarían mejor como errores. Por ejemplo, creo que estas advertencias serían más útiles como errores:\n\nformals(1)\n#&gt; Warning in formals(fun): argument is not a function\n#&gt; NULL\n\nfile.remove(\"this-file-doesn't-exist\")\n#&gt; Warning in file.remove(\"this-file-doesn't-exist\"): cannot remove file\n#&gt; 'this-file-doesn't-exist', reason 'No such file or directory'\n#&gt; [1] FALSE\n\nlag(1:3, k = 1.5)\n#&gt; Warning in lag.default(1:3, k = 1.5): 'k' is not an integer\n#&gt; [1] 1 2 3\n#&gt; attr(,\"tsp\")\n#&gt; [1] -1  1  1\n\nas.numeric(c(\"18\", \"30\", \"50+\", \"345,678\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1] 18 30 NA NA\n\nSolo hay un par de casos en los que usar una advertencia es claramente apropiado:\n\nCuando desaproba una función, desea permitir que el código anterior continúe funcionando (por lo que ignorar la advertencia está bien), pero desea alentar al usuario a cambiar a una nueva función.\nCuando esté razonablemente seguro de que puede solucionar un problema: si estuviera 100% seguro de que podría solucionar el problema, no necesitaría ningún mensaje; si no estuviera seguro de poder solucionar correctamente el problema, arrojaría un error.\n\nDe lo contrario, use las advertencias con moderación y considere cuidadosamente si un error sería más apropiado.\n\n\n8.2.3 Mensajes\n \nLos mensajes, señalados por message(), son informativos; utilícelos para decirle al usuario que ha hecho algo en su nombre. Los buenos mensajes son un acto de equilibrio: desea proporcionar la información suficiente para que el usuario sepa lo que está sucediendo, pero no tanto como para que se sienta abrumado.\nLos mensajes, message(), se muestran inmediatamente y no tienen un argumento call.:\n\nfm &lt;- function() {\n  cat(\"1\\n\")\n  message(\"M1\")\n  cat(\"2\\n\")\n  message(\"M2\")\n  cat(\"3\\n\")\n  message(\"M3\")\n}\n\nfm()\n#&gt; 1\n#&gt; M1\n#&gt; 2\n#&gt; M2\n#&gt; 3\n#&gt; M3\n\nBuenos lugares para usar un mensaje son:\n\nCuando un argumento predeterminado requiere una cantidad de cálculo no trivial y desea decirle al usuario qué valor se utilizó. Por ejemplo, ggplot2 informa la cantidad de contenedores utilizados si no proporciona un binwidth.\nEn funciones que son convocadas principalmente por sus efectos secundarios que de otro modo serían silenciosos. Por ejemplo, al escribir archivos en el disco, llamar a una API web o escribir en una base de datos, es útil proporcionar mensajes de estado regulares que le informen al usuario lo que está sucediendo.\nCuando esté a punto de iniciar un proceso de ejecución prolongada sin resultados intermedios. Una barra de progreso (por ejemplo, con progress) es mejor, pero un mensaje es un buen lugar para comenzar.\nAl escribir un paquete, a veces desea mostrar un mensaje cuando se carga su paquete (es decir, en .onAttach()); aquí debes usar packageStartupMessage().\n\nEn general, cualquier función que produzca un mensaje debería tener alguna forma de suprimirlo, como un argumento quiet = TRUE. Es posible suprimir todos los mensajes con suppressMessages(), como aprenderá en breve, pero también es bueno dar un control más detallado.\nEs importante comparar message() con el cat() estrechamente relacionado. En términos de uso y resultado, parecen bastante similares2:\n\ncat(\"Hi!\\n\")\n#&gt; Hi!\n\nmessage(\"Hi!\")\n#&gt; Hi!\n\nSin embargo, los propósitos de cat() y message() son diferentes. Usa cat() cuando el rol principal de la función es imprimir en la consola, como los métodos print() o str(). Usa message() como un canal lateral para imprimir en la consola cuando el propósito principal de la función es otra cosa. En otras palabras, cat() es para cuando el usuario pide que se imprima algo y message() es para cuando el desarrollador elige imprimir algo.\n\n\n8.2.4 Ejercicios\n\nEscriba un contenedor alrededor de file.remove() que arroje un error si el archivo a eliminar no existe.\n¿Qué hace el argumento appendLF para message()? ¿Cómo se relaciona con cat()?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#sec-ignoring-conditions",
    "href": "Conditions.html#sec-ignoring-conditions",
    "title": "8  Condiciones",
    "section": "8.3 Ignorando las condiciones",
    "text": "8.3 Ignorando las condiciones\n \nLa forma más sencilla de manejar las condiciones en R es simplemente ignorarlas:\n\nIgnora los errores con try().\nIgnora las advertencias con suppressWarnings().\nIgnorar mensajes con suppressMessages().\n\nEstas funciones son de mano dura, ya que no puede usarlas para suprimir un solo tipo de condición que conozca, mientras permite que pase todo lo demás. Volveremos a ese desafío más adelante en el capítulo.\ntry() permite que la ejecución continúe incluso después de que haya ocurrido un error. Normalmente, si ejecuta una función que arroja un error, finaliza inmediatamente y no devuelve un valor:\n\nf1 &lt;- function(x) {\n  log(x)\n  10\n}\nf1(\"x\")\n#&gt; Error in log(x): non-numeric argument to mathematical function\n\nSin embargo, si ajusta la declaración que crea el error en try(), se mostrará el mensaje de error 3 pero la ejecución continuará:\n\nf2 &lt;- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n#&gt; Error in log(x) : non-numeric argument to mathematical function\n#&gt; [1] 10\n\nEs posible, pero no recomendado, guardar el resultado de try() y realizar diferentes acciones en función de si el código tuvo éxito o no 4. En su lugar, es mejor usar tryCatch() o un ayudante de nivel superior; aprenderá acerca de ellos en breve.\nUn patrón simple, pero útil, es hacer una asignación dentro de la llamada: esto le permite definir un valor predeterminado que se usará si el código no funciona correctamente. Esto funciona porque el argumento se evalúa en el entorno de llamada, no dentro de la función. (Consulte la Sección 6.5.1 para obtener más detalles).\n\ndefault &lt;- NULL\ntry(default &lt;- read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\n\nsuppressWarnings() y suppressMessages() suprimir todas las advertencias y mensajes. A diferencia de los errores, los mensajes y advertencias no terminan la ejecución, por lo que puede haber múltiples advertencias y mensajes señalados en un solo bloque.\n\nsuppressWarnings({\n  warning(\"Uhoh!\")\n  warning(\"Otra advertencia\")\n  1\n})\n#&gt; [1] 1\n\nsuppressMessages({\n  message(\"Hola\")\n  2\n})\n#&gt; [1] 2\n\nsuppressWarnings({\n  message(\"Todavía puedes verme\")\n  3\n})\n#&gt; Todavía puedes verme\n#&gt; [1] 3",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#sec-handling-conditions",
    "href": "Conditions.html#sec-handling-conditions",
    "title": "8  Condiciones",
    "section": "8.4 Controladores de condiciones",
    "text": "8.4 Controladores de condiciones\n \nCada condición tiene un comportamiento predeterminado: los errores detienen la ejecución y regresan al nivel superior, las advertencias se capturan y muestran en conjunto y los mensajes se muestran inmediatamente. Los controladores de condiciones nos permiten anular o complementar temporalmente el comportamiento predeterminado.\nDos funciones, tryCatch() y withCallingHandlers(), nos permiten registrar controladores, funciones que toman la condición señalada como único argumento. Las funciones de registro tienen la misma forma básica:\n\ntryCatch(\n  error = function(cnd) {\n    # código para ejecutar cuando se lanza un error\n  },\n  code_to_run_while_handlers_are_active\n)\n\nwithCallingHandlers(\n  warning = function(cnd) {\n    # código para ejecutar cuando se señale una advertencia\n  },\n  message = function(cnd) {\n    # código para ejecutar cuando se señala el mensaje\n  },\n  code_to_run_while_handlers_are_active\n)\n\nSe diferencian en el tipo de controladores que crean:\n\ntryCatch() define controladores que salen; después de manejar la condición, el control regresa al contexto donde se llamó a tryCatch(). Esto hace que tryCatch() sea más adecuado para trabajar con errores e interrupciones, ya que estos tienen que salir de todos modos.\nwithCallingHandlers() define controladores de llamadas; después de capturar la condición, el control vuelve al contexto donde se señaló la condición. Esto lo hace más adecuado para trabajar con condiciones sin error.\n\nPero antes de que podamos aprender y usar estos controladores, necesitamos hablar un poco sobre la condición objetos. Estos se crean implícitamente cada vez que señala una condición, pero se vuelven explícitos dentro del controlador.\n\n8.4.1 Objetos de condición\n \nHasta ahora, solo hemos señalado las condiciones y no hemos mirado los objetos que se crean detrás de escena. La forma más fácil de ver un objeto de condición es atrapar uno de una condición señalada. ese es el trabajo de rlang::catch_cnd():\n\ncnd &lt;- catch_cnd(stop(\"An error\"))\nstr(cnd)\n#&gt; List of 2\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ call   : language force(expr)\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nLas condiciones integradas son listas con dos elementos:\n\nmenssage, un vector de caracteres de longitud 1 que contiene el texto para mostrar a un usuario. Para extraer el mensaje, utilice conditionMessage(cnd).\ncall, la llamada que activó la condición. Como se describió anteriormente, no usamos la llamada, por lo que a menudo será NULL. Para extraerlo, usa conditionCall(cnd).\n\nLas condiciones personalizadas pueden contener otros componentes, que analizaremos en la Sección 8.5.\nLas condiciones también tienen un atributo class, lo que las convierte en objetos S3. No hablaremos de S3 hasta el Capítulo 13, pero afortunadamente, incluso si no conoce S3, los objetos de condición son bastante simples. Lo más importante que debe saber es que el atributo class es un vector de caracteres y determina qué controladores coincidirán con la condición.\n\n\n8.4.2 Controladores de salida\n\n\ntryCatch() egistra los controladores existentes y, por lo general, se utiliza para controlar las condiciones de error. Le permite anular el comportamiento de error predeterminado. Por ejemplo, el siguiente código devolverá NA en lugar de arrojar un error:\n\nf3 &lt;- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n#&gt; [1] NA\n\nSi no se señalan condiciones, o si la clase de la condición señalada no coincide con el nombre del controlador, el código se ejecuta normalmente:\n\ntryCatch(\n  error = function(cnd) 10,\n  1 + 1\n)\n#&gt; [1] 2\n\ntryCatch(\n  error = function(cnd) 10,\n  {\n    message(\"Hi!\")\n    1 + 1\n  }\n)\n#&gt; Hi!\n#&gt; [1] 2\n\nLos controladores configurados por tryCatch() se denominan controladores exiting porque después de señalar la condición, el control pasa al controlador y nunca vuelve al código original, lo que significa que el código sale:\n\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n#&gt; [1] \"There\"\n\nEl código protegido se evalúa en el entorno de tryCatch(), pero el código del controlador no, porque los controladores son funciones. Es importante recordar esto si está tratando de modificar objetos en el entorno principal.\nLas funciones del controlador se llaman con un solo argumento, el objeto de condición. Llamo a este argumento cnd, por convención. Este valor es solo moderadamente útil para las condiciones base porque contienen relativamente pocos datos. Es más útil cuando crea sus propias condiciones personalizadas, como verá en breve.\n\ntryCatch(\n  error = function(cnd) {\n    paste0(\"--\", conditionMessage(cnd), \"--\")\n  },\n  stop(\"This is an error\")\n)\n#&gt; [1] \"--This is an error--\"\n\ntryCatch() tiene otro argumento: finally. Especifica un bloque de código (no una función) para ejecutar independientemente de si la expresión inicial tiene éxito o falla. Esto puede ser útil para la limpieza, como eliminar archivos o cerrar conexiones. Esto es funcionalmente equivalente a usar on.exit() (y de hecho así es como se implementa), pero puede envolver fragmentos de código más pequeños que una función completa. \n\npath &lt;- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)\n\n\n\n8.4.3 Controladores de llamadas\n \nLos controladores configurados por tryCatch() se denominan controladores de salida porque hacen que el código se cierre una vez que se ha detectado la condición. Por el contrario, withCallingHandlers() configura controladores de llamadas: la ejecución del código continúa normalmente una vez que el controlador regresa. Esto tiende a hacer que withCallingHandlers() sea un emparejamiento más natural con las condiciones sin error. Los controladores de salida y llamada usan “controlador” en sentidos ligeramente diferentes:\n\nUn controlador existente maneja una señal como tú manejas un problema; hace que el problema desaparezca.\nUn controlador de llamadas maneja una señal como usted maneja un automóvil; el coche todavía existe.\n\nCompara los resultados de tryCatch() y withCallingHandlers() en el siguiente ejemplo. Los mensajes no se imprimen en el primer caso, porque el código finaliza una vez que se completa el controlador de salida. Se imprimen en el segundo caso, porque un controlador de llamadas no sale.\n\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#&gt; Caught a message!\n\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#&gt; Caught a message!\n#&gt; Someone there?\n#&gt; Caught a message!\n#&gt; Why, yes!\n\nLos controladores se aplican en orden, por lo que no debe preocuparse por quedar atrapado en un bucle infinito. En el siguiente ejemplo, el message() señalado por el controlador tampoco queda atrapado:\n\nwithCallingHandlers(\n  message = function(cnd) message(\"Second message\"),\n  message(\"First message\")\n)\n#&gt; Second message\n#&gt; First message\n\n(Pero tenga cuidado si tiene varios controladores y algunos controladores señalan condiciones que podrían ser capturadas por otro controlador: tendrá que pensar detenidamente en la orden).\nEl valor de retorno de un controlador de llamadas se ignora porque el código continúa ejecutándose después de que se completa el controlador; ¿Adónde iría el valor de retorno? Eso significa que los controladores de llamadas solo son útiles por sus efectos secundarios.\n \nUn efecto secundario importante exclusivo de los controladores de llamadas es la capacidad de amortiguar la señal. De forma predeterminada, una condición continuará propagándose a los controladores principales, hasta el controlador predeterminado (o un controlador existente, si se proporciona):\n\n# Burbujas hasta el controlador predeterminado que genera el mensaje\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n#&gt; Hello\n\n# Burbujas en tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n\nSi desea evitar la condición “burbujeante” pero aún ejecuta el resto del código en el bloque, debe silenciarlo explícitamente con rlang::cnd_muffle():\n\n# Silencia el controlador predeterminado que imprime los mensajes.\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n\n# Silencia el controlador de nivel 2 y el controlador por defecto\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n\n\n\n8.4.4 Pilas de llamadas\n \nPara completar la sección, existen algunas diferencias importantes entre las pilas de llamadas de los controladores de salida y de llamada. Estas diferencias generalmente no son importantes, pero las incluyo aquí porque ocasionalmente las he encontrado útiles, ¡y no quiero olvidarme de ellas!\nEs más fácil ver la diferencia configurando un pequeño ejemplo que usa lobstr::cst():\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() message(\"!\")\n\nLos controladores de llamadas se llaman en el contexto de la llamada que señaló la condición:\n\nwithCallingHandlers(f(), message = function(cnd) {\n  lobstr::cst()\n  cnd_muffle(cnd)\n})\n#&gt;      ▆\n#&gt;   1. ├─base::withCallingHandlers(...)\n#&gt;   2. ├─global f()\n#&gt;   3. │ └─global g()\n#&gt;   4. │   └─global h()\n#&gt;   5. │     └─base::message(\"!\")\n#&gt;   6. │       ├─base::withRestarts(...)\n#&gt;   7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n#&gt;   8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n#&gt;   9. │       └─base::signalCondition(cond)\n#&gt;  10. └─global `&lt;fn&gt;`(`&lt;smplMssg&gt;`)\n#&gt;  11.   └─lobstr::cst()\n\nMientras que los controladores existentes se llaman en el contexto de la llamada a tryCatch():\n\ntryCatch(f(), message = function(cnd) lobstr::cst())\n#&gt;     ▆\n#&gt;  1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n#&gt;  2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n#&gt;  3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt;  4.       └─value[[3L]](cond)\n#&gt;  5.         └─lobstr::cst()\n\n\n\n8.4.5 Ejercicios\n\n¿Qué información adicional contiene la condición generada por abort() en comparación con la condición generada por stop(), es decir, cuál es la diferencia entre estos dos objetos? Lea la ayuda de ?abort para obtener más información.\n\ncatch_cnd(stop(\"An error\"))\ncatch_cnd(abort(\"An error\"))\n\nPrediga los resultados de evaluar el siguiente código\n\nshow_condition &lt;- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\n\nExplique los resultados de ejecutar este código:\n\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers(\n    message = function(cnd) message(\"a\"),\n    message(\"c\")\n  )\n)\n#&gt; b\n#&gt; a\n#&gt; b\n#&gt; c\n\nLea el código fuente de catch_cnd() y explique cómo funciona.\n¿Cómo podría reescribir show_condition() para usar un solo controlador?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#sec-custom-conditions",
    "href": "Conditions.html#sec-custom-conditions",
    "title": "8  Condiciones",
    "section": "8.5 Condiciones personalizadas",
    "text": "8.5 Condiciones personalizadas\n \nUno de los desafíos del manejo de errores en R es que la mayoría de las funciones generan una de las condiciones integradas, que contienen solo un “mensaje” y una “llamada”. Eso significa que si desea detectar un tipo específico de error, solo puede trabajar con el texto del mensaje de error. Esto es propenso a errores, no solo porque el mensaje puede cambiar con el tiempo, sino también porque los mensajes se pueden traducir a otros idiomas.\nAfortunadamente, R tiene una característica poderosa, pero poco utilizada: la capacidad de crear condiciones personalizadas que pueden contener metadatos adicionales. Crear condiciones personalizadas es un poco complicado en base R, pero rlang::abort() lo hace muy fácil ya que puede proporcionar una .subclass personalizada y metadatos adicionales.\nEl siguiente ejemplo muestra el patrón básico. Recomiendo usar la siguiente estructura de llamadas para condiciones personalizadas. Esto aprovecha la coincidencia de argumentos flexibles de R para que el nombre del tipo de error aparezca primero, seguido del texto de cara al usuario, seguido de los metadatos personalizados.\n\nabort(\n  \"error_not_found\",\n  message = \"Path `blah.csv` not found\", \n  path = \"blah.csv\"\n)\n#&gt; Error:\n#&gt; ! Path `blah.csv` not found\n\nLas condiciones personalizadas funcionan igual que las condiciones normales cuando se usan de forma interactiva, pero permiten que los controladores hagan mucho más.\n\n8.5.1 Motivación\nTo explore these ideas in more depth, let’s take base::log(). It does the minimum when throwing errors caused by invalid arguments:\n\nlog(letters)\n#&gt; Error in log(letters): non-numeric argument to mathematical function\nlog(1:10, base = letters)\n#&gt; Error in log(1:10, base = letters): non-numeric argument to mathematical function\n\nCreo que podemos hacerlo mejor siendo explícitos sobre qué argumento es el problema (es decir, x o base) y diciendo cuál es la entrada problemática (no solo cuál no es).\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\n\nEsto nos da:\n\nmy_log(letters)\n#&gt; Error in `my_log()`:\n#&gt; ! `x` must be a numeric vector; not character.\nmy_log(1:10, base = letters)\n#&gt; Error in `my_log()`:\n#&gt; ! `base` must be a numeric vector; not character.\n\nEsta es una mejora para el uso interactivo, ya que es más probable que los mensajes de error guíen al usuario hacia una solución correcta. Sin embargo, no son mejores si desea manejar los errores mediante programación: todos los metadatos útiles sobre el error se atascan en una sola cadena.\n\n\n8.5.2 Señalización\n\nConstruyamos alguna infraestructura para mejorar esta situación. Comenzaremos proporcionando una función abort() personalizada para argumentos incorrectos. Esto está un poco generalizado para el ejemplo en cuestión, pero refleja patrones comunes que he visto en otras funciones. El patrón es bastante simple. Creamos un buen mensaje de error para el usuario, usando glue::glue(), y almacenamos metadatos en la llamada de condición para el desarrollador.\n\nabort_bad_argument &lt;- function(arg, must, not = NULL) {\n  msg &lt;- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not &lt;- typeof(not)\n    msg &lt;- glue::glue(\"{msg}; not {not}.\")\n  }\n  \n  abort(\"error_bad_argument\", \n    message = msg, \n    arg = arg, \n    must = must, \n    not = not\n  )\n}\n\n\n\nSi desea generar un error personalizado sin agregar una dependencia en rlang, puede crear un objeto de condición “a mano” y luego pasarlo a stop():\n\nstop_custom &lt;- function(.subclass, message, call = NULL, ...) {\n  err &lt;- structure(\n    list(\n      message = message,\n      call = call,\n      ...\n    ),\n    class = c(.subclass, \"error\", \"condition\")\n  )\n  stop(err)\n}\n\nerr &lt;- catch_cnd(\n  stop_custom(\"error_new\", \"This is a custom error\", x = 10)\n)\nclass(err)\nerr$x\n\n\nAhora podemos reescribir my_log() para usar este nuevo ayudante:\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n\nmy_log() en sí mismo no es mucho más corto, pero es un poco más significativo y asegura que los mensajes de error para argumentos incorrectos sean consistentes en todas las funciones. Produce los mismos mensajes de error interactivos que antes:\n\nmy_log(letters)\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `x` must be numeric; not character.\nmy_log(1:10, base = letters)\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `base` must be numeric; not character.\n\n\n\n8.5.3 Controlar\n\nEstos objetos de condición estructurados son mucho más fáciles de programar. El primer lugar en el que podría querer usar esta capacidad es al probar su función. Las pruebas unitarias no son un tema de este libro (consulte los paquetes R para obtener más detalles), pero los conceptos básicos son fáciles de entender. El siguiente código captura el error y luego afirma que tiene la estructura que esperamos.\n\nlibrary(testthat)\n\nerr &lt;- catch_cnd(my_log(\"a\"))\nexpect_s3_class(err, \"error_bad_argument\")\nexpect_equal(err$arg, \"x\")\nexpect_equal(err$not, \"character\")\n\nTambién podemos usar la clase (error_bad_argument) en tryCatch() para manejar solo ese error específico:\n\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n#&gt; [1] \"bad_argument\"\n\nCuando se usa tryCatch() con múltiples controladores y clases personalizadas, se llama al primer controlador que coincida con cualquier clase en el vector de clase de la señal, no a la mejor coincidencia. Por este motivo, debe asegurarse de poner primero los controladores más específicos. El siguiente código no hace lo que cabría esperar:\n\ntryCatch(\n  error = function(cnd) \"other error\",\n  error_bad_argument = function(cnd) \"bad_argument\",\n  my_log(\"a\")\n)\n#&gt; [1] \"other error\"\n\n\n\n8.5.4 Ejercicios\n\nDentro de un paquete, ocasionalmente es útil verificar que un paquete esté instalado antes de usarlo. Escriba una función que verifique si un paquete está instalado (con requireNamespace(\"pkg\", quietly = FALSE)) y, si no, arroja una condición personalizada que incluye el nombre del paquete en los metadatos.\nDentro de un paquete, a menudo debe detenerse con un error cuando algo no está bien. Otros paquetes que dependen de su paquete pueden verse tentados a verificar estos errores en sus pruebas unitarias. ¿Cómo podría ayudar a estos paquetes a evitar confiar en el mensaje de error que es parte de la interfaz de usuario en lugar de la API y que podría cambiar sin previo aviso?",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#sec-condition-applications",
    "href": "Conditions.html#sec-condition-applications",
    "title": "8  Condiciones",
    "section": "8.6 Aplicaciones",
    "text": "8.6 Aplicaciones\nAhora que ha aprendido las herramientas básicas del sistema de condiciones de R, es hora de sumergirse en algunas aplicaciones. El objetivo de esta sección no es mostrar todos los usos posibles de tryCatch() y withCallingHandlers(), sino ilustrar algunos patrones comunes que surgen con frecuencia. Con suerte, esto hará que fluya su creatividad, de modo que cuando encuentre un nuevo problema, pueda encontrar una solución útil.\n\n8.6.1 Valor de falla\n\nHay algunos patrones tryCatch() simples, pero útiles, basados en la devolución de un valor del controlador de errores. El caso más simple es un contenedor para devolver un valor predeterminado si ocurre un error:\n\nfail_with &lt;- function(expr, value = NULL) {\n  tryCatch(\n    error = function(cnd) value,\n    expr\n  )\n}\n\nfail_with(log(10), NA_real_)\n#&gt; [1] 2.3\nfail_with(log(\"x\"), NA_real_)\n#&gt; [1] NA\n\nUna aplicación más sofisticada es base::try(). A continuación, try2() extrae la esencia de base::try(); la función real es más complicada para hacer que el mensaje de error se parezca más a lo que vería si no se usara tryCatch().\n\ntry2 &lt;- function(expr, silent = FALSE) {\n  tryCatch(\n    error = function(cnd) {\n      msg &lt;- conditionMessage(cnd)\n      if (!silent) {\n        message(\"Error: \", msg)\n      }\n      structure(msg, class = \"try-error\")\n    },\n    expr\n  )\n}\n\ntry2(1)\n#&gt; [1] 1\ntry2(stop(\"Hi\"))\n#&gt; Error: Hi\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\ntry2(stop(\"Hi\"), silent = TRUE)\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\n\n\n\n8.6.2 Valores de éxito y fracaso.\nPodemos ampliar este patrón para devolver un valor si el código se evalúa correctamente (success_val) y otro si falla (error_val). Este patrón solo requiere un pequeño truco: evaluar el código proporcionado por el usuario y luego success_val. Si el código arroja un error, nunca llegaremos a success_val y, en su lugar, devolveremos error_val.\n\nfoo &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) error_val,\n    {\n      expr\n      success_val\n    }\n  )\n}\n\nPodemos usar esto para determinar si una expresión falla:\n\ndoes_error &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) TRUE,\n    {\n      expr\n      FALSE\n    }\n  )\n}\n\nO para capturar cualquier condición, como simplemente rlang::catch_cnd():\n\ncatch_cnd &lt;- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd, \n    {\n      expr\n      NULL\n    }\n  )\n}\n\nTambién podemos usar este patrón para crear una variante try(). Un desafío con try() es que es un poco difícil determinar si el código tuvo éxito o falló. En lugar de devolver un objeto con una clase especial, creo que es un poco mejor devolver una lista con dos componentes result y error.\n\nsafety &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) {\n      list(result = NULL, error = cnd)\n    },\n    list(result = expr, error = NULL)\n  )\n}\n\nstr(safety(1 + 10))\n#&gt; List of 2\n#&gt;  $ result: num 11\n#&gt;  $ error : NULL\nstr(safety(stop(\"Error!\")))\n#&gt; List of 2\n#&gt;  $ result: NULL\n#&gt;  $ error :List of 2\n#&gt;   ..$ message: chr \"Error!\"\n#&gt;   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n#&gt;   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n(Esto está estrechamente relacionado con purrr::safely(), un operador de función, al que volveremos en la Sección 11.2.1.)\n\n\n8.6.3 Renuncia\n\nAdemás de devolver valores predeterminados cuando se señala una condición, los controladores se pueden usar para generar mensajes de error más informativos. Una aplicación simple es hacer una función que funcione como options(warn = 2) para un solo bloque de código. La idea es simple: manejamos las advertencias lanzando un error:\n\nwarning2error &lt;- function(expr) {\n  withCallingHandlers(\n    warning = function(cnd) abort(conditionMessage(cnd)),\n    expr\n  )\n}\n\n\nwarning2error({\n  x &lt;- 2 ^ 4\n  warn(\"Hello\")\n})\n#&gt; Error:\n#&gt; ! Hello\n\nPodrías escribir una función similar si estuvieras tratando de encontrar la fuente de un mensaje molesto. Más sobre esto en la Sección 22.6.\n\n\n\n8.6.4 Registro\nOtro patrón común es registrar las condiciones para una investigación posterior. El nuevo desafío aquí es que los controladores de llamadas se llaman solo por sus efectos secundarios, por lo que no podemos devolver valores, sino que necesitamos modificar algún objeto en su lugar.\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n  \n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n  \n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; c\n\n¿Qué sucede si también desea capturar errores? Deberá envolver el withCallingHandlers() en un tryCatch(). Si se produce un error, será la última condición.\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n  \n  tryCatch(\n    error = function(cnd) {\n      conds &lt;&lt;- append(conds, list(cnd))\n    },\n    withCallingHandlers(\n      message = add_cond,\n      warning = add_cond,\n      expr\n    )\n  )\n  \n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  abort(\"C\")\n})\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! C\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\nEsta es la idea clave que subyace al paquete de evaluación (Wickham y Xie 2018) que impulsa a knitr: captura cada salida en una estructura de datos especial para que pueda reproducirse más tarde. En general, el paquete de evaluación es mucho más complicado que el código aquí porque también necesita manejar gráficos y salida de texto.\n\n\n8.6.5 Sin comportamiento predeterminado\nUn último patrón útil es señalar una condición que no hereda de message, warning o error. Debido a que no hay un comportamiento predeterminado, esto significa que la condición no tiene efecto a menos que el usuario lo solicite específicamente. Por ejemplo, podría imaginar un sistema de registro basado en condiciones:\n\nlog &lt;- function(message, level = c(\"info\", \"error\", \"fatal\")) {\n  level &lt;- match.arg(level)\n  signal(message, \"log\", level = level)\n}\n\nCuando llamas a log(), se señala una condición, pero no sucede nada porque no tiene un controlador predeterminado:\n\nlog(\"This code was run\")\n\nPara activar el registro, necesita un controlador que haga algo con la condición log. A continuación defino una función record_log() que registrará todos los mensajes de registro en un archivo:\n\nrecord_log &lt;- function(expr, path = stdout()) {\n  withCallingHandlers(\n    log = function(cnd) {\n      cat(\n        \"[\", cnd$level, \"] \", cnd$message, \"\\n\", sep = \"\",\n        file = path, append = TRUE\n      )\n    },\n    expr\n  )\n}\n\nrecord_log(log(\"Hello\"))\n#&gt; [info] Hello\n\nIncluso podría imaginar la superposición con otra función que le permita suprimir selectivamente algunos niveles de registro.\n\nignore_log_levels &lt;- function(expr, levels) {\n  withCallingHandlers(\n    log = function(cnd) {\n      if (cnd$level %in% levels) {\n        cnd_muffle(cnd)\n      }\n    },\n    expr\n  )\n}\n\nrecord_log(ignore_log_levels(log(\"Hello\"), \"info\"))\n\n\nSi crea un objeto de condición a mano y lo señala con signalCondition(), cnd_muffle() no funcionará. En su lugar, debe llamarlo con un reinicio de mufla definido, así:\nwithRestarts(signalCondition(cond), muffle = function() NULL)\nLos reinicios están actualmente fuera del alcance del libro, pero sospecho que se incluirán en la tercera edición.\n\n\n\n8.6.6 Ejercicios\n\nCree suppressConditions() que funcione como suppressMessages() y suppressWarnings() pero suprima todo. Piense cuidadosamente acerca de cómo debe manejar los errores.\nCompare las siguientes dos implementaciones de message2error(). ¿Cuál es la principal ventaja de withCallingHandlers() en este escenario? (Sugerencia: mire cuidadosamente el rastreo).\n\nmessage2error &lt;- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\nmessage2error &lt;- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\n\n¿Cómo modificaría la definición de catch_cnds() si quisiera recrear la combinación original de advertencias y mensajes?\n¿Por qué es peligroso atrapar interrupciones? Ejecute este código para averiguarlo.\n\nbottles_of_beer &lt;- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \", \n    i, \" bottles of beer.\"\n  )\n  while(i &gt; 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i &lt;&lt;- i - 1\n        if (i &gt; 0) {\n          message(\n            \"Take one down, pass it around, \", i, \n            \" bottle\", if (i &gt; 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \", \n    \"no more bottles of beer.\"\n  )\n}",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#sec-conditions-answers",
    "href": "Conditions.html#sec-conditions-answers",
    "title": "8  Condiciones",
    "section": "8.7 Respuestas de la prueba",
    "text": "8.7 Respuestas de la prueba\n\nerror, warning, y message.\nPodrías usar try() o tryCatch().\ntryCatch() crea controladores existentes que finalizarán la ejecución del código envuelto; withCallingHandlers() crea controladores de llamadas que no afectan la ejecución del código envuelto.\nPorque luego puede capturar tipos específicos de error con tryCatch(), en lugar de depender de la comparación de cadenas de errores, lo cual es arriesgado, especialmente cuando se traducen los mensajes.\n\n\n\n\n\nWickham, Hadley, y Yihui Xie. 2018. evaluate: Parsing and Evaluation Tools that Provide More Details than the Default. https://github.com/r-lib/evaluate.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "Conditions.html#footnotes",
    "href": "Conditions.html#footnotes",
    "title": "8  Condiciones",
    "section": "",
    "text": "El final . en call. es una peculiaridad de stop(); no leas nada.↩︎\nPero tenga en cuenta que cat() requiere un final explícito \"\\n\" para imprimir una nueva línea.↩︎\nPuede suprimir el mensaje con try(..., silent = TRUE).↩︎\nPuede saber si la expresión falló porque el resultado tendrá clase try-error.↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Condiciones</span>"
    ]
  },
  {
    "objectID": "FP.html",
    "href": "FP.html",
    "title": "Introducción",
    "section": "",
    "text": "Lenguajes de programacion funcional\nCada lenguaje de programación tiene funciones, entonces, ¿qué hace que un lenguaje de programación sea funcional? Hay muchas definiciones de lo que hace que un lenguaje sea funcional, pero hay dos hilos comunes.\nEn primer lugar, los lenguajes funcionales tienen funciones de primera clase, funciones que se comportan como cualquier otra estructura de datos. En R, esto significa que puede hacer muchas de las cosas con una función que puede hacer con un vector: puede asignarlas a variables, almacenarlas en listas, pasarlas como argumentos a otras funciones, crearlas dentro de funciones y incluso devolverlos como resultado de una función.\nEn segundo lugar, muchos lenguajes funcionales requieren que las funciones sean puras. Una función es pura si cumple dos propiedades:\nLas funciones puras son mucho más fáciles de razonar, pero obviamente tienen desventajas significativas: imagine hacer un análisis de datos en el que no pueda generar números aleatorios o leer archivos del disco.\nEstrictamente hablando, R no es un lenguaje de programación funcional porque no requiere que escribas funciones puras. Sin embargo, ciertamente puede adoptar un estilo funcional en partes de su código: no tiene que escribir funciones puras, pero a menudo debería. En mi experiencia, dividir el código en funciones que son extremadamente puras o extremadamente impuras tiende a generar un código que es más fácil de entender y se extiende a nuevas situaciones.",
    "crumbs": [
      "Programación funcional",
      "Introducción"
    ]
  },
  {
    "objectID": "FP.html#lenguajes-de-programacion-funcional",
    "href": "FP.html#lenguajes-de-programacion-funcional",
    "title": "Introducción",
    "section": "",
    "text": "La salida solo depende de las entradas, es decir, si lo vuelve a llamar con las mismas entradas, obtendrá las mismas salidas. Esto excluye funciones como runif(), read.csv() o Sys.time() que pueden devolver valores diferentes.\nLa función no tiene efectos secundarios, como cambiar el valor de una variable global, escribir en el disco o mostrar en la pantalla. Esto excluye funciones como print(), write.csv() y &lt;-.",
    "crumbs": [
      "Programación funcional",
      "Introducción"
    ]
  },
  {
    "objectID": "FP.html#estilo-funcional",
    "href": "FP.html#estilo-funcional",
    "title": "Introducción",
    "section": "Estilo funcional",
    "text": "Estilo funcional\nEs difícil describir exactamente qué es un estilo funcional, pero en general creo que significa descomponer un gran problema en partes más pequeñas y luego resolver cada parte con una función o combinación de funciones. Cuando usa un estilo funcional, se esfuerza por descomponer los componentes del problema en funciones aisladas que operan de forma independiente. Cada función tomada por sí sola es simple y fácil de entender; la complejidad se maneja componiendo funciones de varias maneras.\nLos siguientes tres capítulos analizan las tres técnicas funcionales clave que lo ayudan a descomponer los problemas en partes más pequeñas:\n\nEl 9  Funcionales muestra cómo reemplazar muchos bucles for con funcionales que son funciones (como lapply()) que toman otra función como argumento. Los funcionales le permiten tomar una función que resuelve el problema para una sola entrada y generalizarla para manejar cualquier número de entradas. Los funcionales son, con mucho, la técnica más importante y los usará todo el tiempo en el análisis de datos.\nEl 10  Fábricas de funciones introduce fábricas de funciones: funciones que crean funciones. Las fábricas de funciones se usan con menos frecuencia que las funcionales, pero pueden permitirle dividir elegantemente el trabajo entre diferentes partes de su código.\nEl 11  Operadores de funciones le muestra cómo crear operadores de función: funciones que toman funciones como entrada y producen funciones como salida. Son como los adverbios, porque normalmente modifican el funcionamiento de una función.\n\nEn conjunto, estos tipos de funciones se denominan funciones de orden superior y completan una tabla de dos por dos:",
    "crumbs": [
      "Programación funcional",
      "Introducción"
    ]
  },
  {
    "objectID": "Functionals.html",
    "href": "Functionals.html",
    "title": "9  Funcionales",
    "section": "",
    "text": "9.1 Introducción\nUn funcional es una función que toma una función como entrada y devuelve un vector como salida. Aquí hay un funcional simple: llama a la función proporcionada como entrada con 1000 números uniformes aleatorios.\nrandomise &lt;- function(f) f(runif(1e3))\nrandomise(mean)\n#&gt; [1] 0.506\nrandomise(mean)\n#&gt; [1] 0.501\nrandomise(sum)\n#&gt; [1] 489\nLo más probable es que ya hayas usado un funcional. Es posible que haya utilizado reemplazos de bucle for como lapply(), apply() y tapply() de base R; o map() de purrr; o quizás hayas usado un funcional matemático como integrate() u optim().\nUn uso común de los funcionales es como una alternativa a los bucles for. Los bucles for tienen mala reputación en R porque mucha gente cree que son lentos[^funcionals-1], pero la verdadera desventaja de los bucles for es que son muy flexibles: un bucle transmite que estás iterando, pero no lo que deberías terminar con los resultados. Así como es mejor usar while que repeat, y es mejor usar for que while (Sección 5.3.2), es mejor usar un funcional que for. Cada funcional está diseñado para una tarea específica, por lo que cuando reconoce el funcional, inmediatamente sabe por qué se está utilizando.\nSi es un usuario experimentado de bucles for, cambiar a funcionales suele ser un ejercicio de coincidencia de patrones. Miras el bucle for y encuentras un funcional que coincida con la forma básica. Si no existe uno, no intente torturar un funcional existente para que se ajuste a la forma que necesita. ¡En su lugar, déjalo como un bucle for! (O una vez que haya repetido el mismo bucle dos o más veces, tal vez piense en escribir su propio funcional).",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#introducción",
    "href": "Functionals.html#introducción",
    "title": "9  Funcionales",
    "section": "",
    "text": "Para volverse significativamente más confiable, el código debe volverse más transparente. En particular, las condiciones anidadas y los bucles deben verse con gran sospecha. Los flujos de control complicados confunden a los programadores. El código desordenado a menudo esconde errores.\n— Bjarne Stroustrup\n\n\n\n\n\n\n\nOutline\n\nLa Sección 9.2 introduce tu primer funcional: purrr :: map ().\nLa Sección 9.3 demuestra cómo puede combinar múltiples funciones simples para resolver un problema más complejo y analiza cómo el estilo purrr difiere de otros enfoques.\nLa Sección 9.4 te enseña alrededor de 18 (!!) variantes importantes de purrr::map(). Afortunadamente, su diseño ortogonal los hace fáciles de aprender, recordar y dominar.\nLa Sección 9.5 introduce un nuevo estilo de funcional: purrr::reduce(). reduce() reduce sistemáticamente un vector a un solo resultado mediante la aplicación de una función que toma dos entradas.\nLa Sección 9.6 te enseña acerca de los predicados: funciones que devuelven un solo TRUE o FALSE, y la familia de funciones que los usan para resolver problemas comunes.\nLa Sección 9.7 revisa algunos funcionales en base R que no son miembros de las familias map, reduce o predicate.\n\n\n\nRequsisitos previos\nEste capítulo se centrará en las funciones proporcionadas por el paquete purrr (Henry y Wickham 2018). Estas funciones tienen una interfaz consistente que facilita la comprensión de las ideas clave que sus equivalentes básicos, que han crecido orgánicamente durante muchos años. Compararé y contrastaré las funciones básicas de R a medida que avanzamos, y luego terminaré el capítulo con una discusión de las funciones básicas que no tienen equivalentes purrr.\n\nlibrary(purrr)",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#sec-map",
    "href": "Functionals.html#sec-map",
    "title": "9  Funcionales",
    "section": "9.2 My first functional: map()",
    "text": "9.2 My first functional: map()\n\nEl funcional más fundamental es purrr::map()[^funcionals-2]. Toma un vector y una función, llama a la función una vez por cada elemento del vector y devuelve los resultados en una lista. En otras palabras, map(1:3, f) es equivalente a list(f(1), f(2), f(3)).\n\ntriple &lt;- function(x) x * 3\nmap(1:3, triple)\n#&gt; [[1]]\n#&gt; [1] 3\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 6\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 9\n\nO, gráficamente:\n\n\n\n\n\n\n\n\n\n\nQuizás se pregunte por qué esta función se llama map(). ¿Qué tiene que ver con representar las características físicas de la tierra o el mar 🗺? De hecho, el significado proviene de las matemáticas donde mapa se refiere a “una operación que asocia cada elemento de un conjunto dado con uno o más elementos de un segundo conjunto”. Esto tiene sentido aquí porque map() define un mapeo de un vector a otro. (“Map” también tiene la agradable propiedad de ser corto, lo cual es útil para un bloque de construcción tan fundamental).\n\nLa implementación de map() es bastante simple. Asignamos una lista de la misma longitud que la entrada y luego completamos la lista con un bucle for. El corazón de la implementación es solo un puñado de líneas de código:\n\nsimple_map &lt;- function(x, f, ...) {\n  out &lt;- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] &lt;- f(x[[i]], ...)\n  }\n  out\n}\n\nLa verdadera función purrr::map() tiene algunas diferencias: está escrita en C para aprovechar hasta el último ápice de rendimiento, conserva los nombres y admite algunos atajos que aprenderá en la Sección 9.2.2.\n\n\nEl equivalente básico de map() es lapply(). La única diferencia es que lapply() no es compatible con los asistentes que aprenderá a continuación, por lo que si solo está usando map() de purrr, puede omitir la dependencia adicional y usar lapply() directamente.\n\n\n9.2.1 Producción de vectores atómicos\nmap() devuelve una lista, lo que la convierte en la más general de la familia de mapas porque puedes poner cualquier cosa en una lista. Pero es un inconveniente devolver una lista cuando lo haría una estructura de datos más simple, por lo que hay cuatro variantes más específicas: map_lgl(), map_int(), map_dbl() y map_chr(). Cada uno devuelve un vector atómico del tipo especificado:\n\n# map_chr() siempre devuelve un vector de caracteres\nmap_chr(mtcars, typeof)\n#&gt;      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#&gt; \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#&gt;       am     gear     carb \n#&gt; \"double\" \"double\" \"double\"\n\n# map_lgl() siempre devuelve un vector de valore boleanos\nmap_lgl(mtcars, is.double)\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() siempre devuelve un vector de números enteros\nn_unique &lt;- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() siempre devuelve un vector doble\nmap_dbl(mtcars, mean)\n#&gt;     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#&gt;  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 \n#&gt;    carb \n#&gt;   2.812\n\npurrr usa la convención de que los sufijos, como _dbl(), se refieren a la salida. Todas las funciones map_*() pueden tomar cualquier tipo de vector como entrada. Estos ejemplos se basan en dos hechos: mtcars es un data frame y los data frames son listas que contienen vectores de la misma longitud. Esto es más obvio si dibujamos un data frame con la misma orientación que el vector:\n\n\n\n\n\n\n\n\n\nTodas las funciones de mapa siempre devuelven un vector de salida de la misma longitud que la entrada, lo que implica que cada llamada a .f debe devolver un solo valor. Si no es así, obtendrá un error:\n\npair &lt;- function(x) c(x, x)\nmap_dbl(1:2, pair)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 2.\n\nEsto es similar al error que obtendrá si .f devuelve el tipo de resultado incorrecto:\n\nmap_dbl(1:2, as.character)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Can't coerce from a string to a double.\n\nEn cualquier caso, a menudo es útil volver a map(), porque map() puede aceptar cualquier tipo de salida. Eso le permite ver la salida problemática y averiguar qué hacer con ella.\n\nmap(1:2, pair)\n#&gt; [[1]]\n#&gt; [1] 1 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2 2\nmap(1:2, as.character)\n#&gt; [[1]]\n#&gt; [1] \"1\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"2\"\n\n\nBase R tiene dos funciones de aplicación que pueden devolver vectores atómicos: sapply() y vapply(). Te recomiendo que evites sapply() porque intenta simplificar el resultado, por lo que puede devolver una lista, un vector o una matriz. Esto dificulta la programación y debe evitarse en entornos no interactivos. vapply() es más seguro porque le permite proporcionar una plantilla, FUN.VALUE, que describe la forma de salida. Si no quieres usar purrr, te recomiendo que siempre uses vapply() en tus funciones, no sapply(). La principal desventaja de vapply() es su verbosidad: por ejemplo, el equivalente a map_dbl(x, mean, na.rm = TRUE) es vapply(x, mean, na.rm = TRUE, FUN.VALUE = doble(1)).\n\n\n\n9.2.2 Funciones y accesos directos anónimos\n \nEn lugar de usar map() con una función existente, puede crear una función anónima en línea (como se menciona en la Sección 6.2.3):\n\nmap_dbl(mtcars, function(x) length(unique(x)))\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nLas funciones anónimas son muy útiles, pero la sintaxis es detallada. Así que purrr admite un atajo especial:\n\nmap_dbl(mtcars, ~ length(unique(.x)))\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\nEsto funciona porque todas las funciones purrr traducen fórmulas, creadas por ~ (pronunciado “twiddle”), en funciones. Puedes ver lo que sucede detrás de escena llamando a as_mapper():\n\nas_mapper(~ length(unique(.x)))\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; length(unique(.x))\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\nLos argumentos de la función parecen un poco extravagantes pero le permiten referirse a . para funciones de un argumento, .x y .y para funciones de dos argumentos, y ..1, ..2, . .3, etc., para funciones con un número arbitrario de argumentos. . permanece para la compatibilidad con versiones anteriores, pero no recomiendo usarlo porque se confunde fácilmente con el . utilizado por la canalización de magrittr.\nEste atajo es particularmente útil para generar datos aleatorios:\n\nx &lt;- map(1:3, ~ runif(2))\nstr(x)\n#&gt; List of 3\n#&gt;  $ : num [1:2] 0.281 0.53\n#&gt;  $ : num [1:2] 0.433 0.917\n#&gt;  $ : num [1:2] 0.0275 0.8249\n\nReserve esta sintaxis para funciones cortas y simples. Una buena regla general es que si su función abarca líneas o usa {}, es hora de darle un nombre.\n\nLas funciones del mapa también tienen atajos para extraer elementos de un vector, impulsados por purrr::pluck(). Puede utilizar un vector de caracteres para seleccionar elementos por nombre, un vector entero para seleccionar por posición o una lista para seleccionar tanto por nombre como por posición. Estos son muy útiles para trabajar con listas profundamente anidadas, que a menudo surgen cuando se trabaja con JSON.\n\nx &lt;- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Selecciona por nombre\nmap_dbl(x, \"x\")\n#&gt; [1] 1 4 8\n\n# O por posición\nmap_dbl(x, 1)\n#&gt; [1] -1 -2 -3\n\n# Or por ambos\nmap_dbl(x, list(\"y\", 1))\n#&gt; [1] 2 5 9\n\n# Obtendrá un error si un componente no existe:\nmap_chr(x, \"z\")\n#&gt; Error in `map_chr()`:\n#&gt; ℹ In index: 3.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 0.\n\n# A menos que proporcione un valor .default\nmap_chr(x, \"z\", .default = NA)\n#&gt; [1] \"a\" \"b\" NA\n\n\nEn las funciones básicas de R, como lapply(), puede proporcionar el nombre de la función como una cadena. Esto no es tremendamente útil ya que lapply(x, \"f\") es casi siempre equivalente a lapply(x, f) y es más tipeo.\n\n\n\n9.2.3 Pasar argumentos con ...\n\n\nA menudo es conveniente pasar argumentos adicionales a la función que está llamando. Por ejemplo, es posible que desee pasar na.rm = TRUE junto con mean(). Una forma de hacerlo es con una función anónima:\n\nx &lt;- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n#&gt; [1] 3.0 5.5\n\nPero debido a que las funciones del mapa pasan ..., hay una forma más simple disponible:\n\nmap_dbl(x, mean, na.rm = TRUE)\n#&gt; [1] 3.0 5.5\n\nEsto es más fácil de entender con una imagen: cualquier argumento que viene después de f en la llamada a map() se inserta después de los datos en llamadas individuales a f():\n\n\n\n\n\n\n\n\n\nEs importante tener en cuenta que estos argumentos no están descompuestos; o dicho de otra manera, map() solo se vectoriza sobre su primer argumento. Si un argumento después de f es un vector, se pasará como está:\n\n\n\n\n\n\n\n\n\n(Aprenderá acerca de las variantes de mapa que están vectorizadas sobre múltiples argumentos en las Secciones Sección 9.4.2 y Sección 9.4.5.)\nTenga en cuenta que hay una sutil diferencia entre colocar argumentos adicionales dentro de una función anónima en comparación con pasarlos a map(). Ponerlos en una función anónima significa que serán evaluados cada vez que se ejecute f(), no solo una vez cuando llames a map(). Esto es más fácil de ver si hacemos que el argumento adicional sea aleatorio:\n\nplus &lt;- function(x, y) x + y\n\nx &lt;- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n#&gt; [1] 0.0625 0.0625 0.0625 0.0625\nmap_dbl(x, ~ plus(.x, runif(1)))\n#&gt; [1] 0.903 0.132 0.629 0.945\n\n\n\n9.2.4 Nombres de argumentos\nEn los diagramas, he omitido los nombres de los argumentos para centrarme en la estructura general. Pero recomiendo escribir los nombres completos en su código, ya que lo hace más fácil de leer. map(x, mean, 0.1) es un código perfectamente válido, pero llamará mean(x[[1]], 0.1) por lo que depende de que el lector recuerde que el segundo argumento de mean() es trim. Para evitar una carga innecesaria en el cerebro del lector[^funcionals-3], sea amable y escriba map(x, mean, trim = 0.1).\nEsta es la razón por la que los argumentos de map() son un poco extraños: en lugar de ser x y f, son .x y .f. Es más fácil ver el problema que conduce a estos nombres usando simple_map() definido anteriormente. simple_map() tiene argumentos x y f, por lo que tendrá problemas cada vez que la función a la que llama tenga argumentos x o f:\n\nbootstrap_summary &lt;- function(x, f) {\n  f(sample(x, replace = TRUE))\n}\n\nsimple_map(mtcars, bootstrap_summary, f = mean)\n#&gt; Error in mean.default(x[[i]], ...): 'trim' must be numeric of length one\n\n\nEl error es un poco desconcertante hasta que recuerdas que la llamada a simple_map() es equivalente a simple_map(x = mtcars, f = mean, bootstrap_summary) porque la coincidencia con nombre supera a la coincidencia posicional.\nLas funciones purrr reducen la probabilidad de que se produzca un conflicto de este tipo mediante el uso de .f y .x en lugar de las más comunes f y x. Por supuesto, esta técnica no es perfecta (porque la función a la que está llamando aún puede usar .f y .x), pero evita el 99% de los problemas. El 1% restante del tiempo, utilice una función anónima.\n\nLas funciones base que transmiten ... usan una variedad de convenciones de nomenclatura para evitar la coincidencia de argumentos no deseados:\n\nLa familia apply utiliza principalmente letras mayúsculas (por ejemplo, X y FUN).\ntransform() usa el prefijo más exótico _: esto hace que el nombre no sea sintáctico, por lo que siempre debe estar entre `, como se describe en la Sección 2.2.1. Esto hace que las coincidencias no deseadas sean extremadamente improbables.\nOtras funciones como uniroot() y optim() no hacen ningún esfuerzo por evitar conflictos, pero tienden a usarse con funciones especialmente creadas, por lo que es menos probable que se produzcan conflictos.\n\n\n\n\n9.2.5 Variando otro argumento\nHasta ahora, el primer argumento de map() siempre se ha convertido en el primer argumento de la función. Pero, ¿qué sucede si el primer argumento debe ser constante y desea variar un argumento diferente? ¿Cómo se obtiene el resultado en esta imagen?\n\n\n\n\n\n\n\n\n\nResulta que no hay forma de hacerlo directamente, pero hay dos trucos que puedes usar en su lugar. Para ilustrarlos, imagine que tengo un vector que contiene algunos valores inusuales y quiero explorar el efecto de diferentes cantidades de recorte al calcular la media. En este caso, el primer argumento de mean() será constante, y quiero variar el segundo argumento, trim.\n\ntrims &lt;- c(0, 0.1, 0.2, 0.5)\nx &lt;- rcauchy(1000)\n\n\nLa técnica más simple es usar una función anónima para reorganizar el orden de los argumentos:\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n#&gt; [1] -0.3500  0.0434  0.0354  0.0502\n\nEsto todavía es un poco confuso porque estoy usando x y .x. Puedes hacerlo un poco más claro abandonando el ayudante ~:\n\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#&gt; [1] -0.3500  0.0434  0.0354  0.0502\n\nA veces, si quiere ser (demasiado) inteligente, puede aprovechar las reglas flexibles de coincidencia de argumentos de R (como se describe en la Sección 6.8.2). Por ejemplo, en este ejemplo puede reescribir mean(x, trim = 0.1) como mean(0.1, x = x), por lo que podría escribir la llamada a map_dbl() como:\n\nmap_dbl(trims, mean, x = x)\n#&gt; [1] -0.3500  0.0434  0.0354  0.0502\n\nNo recomiendo esta técnica ya que se basa en la familiaridad del lector con el orden de los argumentos en .f y las reglas de coincidencia de argumentos de R.\n\nVerá una alternativa más en la Sección 9.4.5.\n\n\n9.2.6 Ejercicios\n\nUtilice as_mapper() para explorar cómo purrr genera funciones anónimas para los ayudantes de enteros, caracteres y listas. ¿Qué ayudante te permite extraer atributos? Lea la documentación para averiguarlo.\nmap(1:3, ~ runif(2)) es un patrón útil para generar números aleatorios, pero map(1:3, runif(2)) no lo es. ¿Por qué no? ¿Puede explicar por qué devuelve el resultado que lo hace?\nUse la función map() apropiada para:\n\nCalcule la desviación estándar de cada columna en un data frame numéricos.\nCalcule la desviación estándar de cada columna numérica en un data frame mixto. (Sugerencia: deberá hacerlo en dos pasos).\nCalcule el número de niveles para cada factor en un data frame.\n\nEl siguiente código simula el rendimiento de una prueba t para datos no normales. Extraiga el valor p de cada prueba, luego visualice.\n\ntrials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\n\nEl siguiente código usa un mapa anidado dentro de otro mapa para aplicar una función a cada elemento de una lista anidada. ¿Por qué falla y qué debe hacer para que funcione?\n\nx &lt;- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple &lt;- function(x) x * 3\nmap(x, map, .f = triple)\n#&gt; Error in `map()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error in `.f()`:\n#&gt; ! unused argument (function (.x, .f, ..., .progress = FALSE) \n#&gt; {\n#&gt;     map_(\"list\", .x, .f, ..., .progress = .progress)\n#&gt; })\n\nUse map() para ajustar modelos lineales al conjunto de datos mtcars usando las fórmulas almacenadas en esta lista:\n\nformulas &lt;- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\n\nAjuste el modelo mpg ~ disp a cada una de las réplicas de arranque de mtcars en la lista a continuación, luego extraiga el \\(R^2\\) del ajuste del modelo (Sugerencia: puede calcular el \\(R^2\\) con summary ().)\n\nbootstrap &lt;- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps &lt;- map(1:10, ~ bootstrap(mtcars))",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#sec-purrr-style",
    "href": "Functionals.html#sec-purrr-style",
    "title": "9  Funcionales",
    "section": "9.3 Estilo Purrr",
    "text": "9.3 Estilo Purrr\n\nAntes de continuar explorando más variantes de mapas, echemos un vistazo rápido a cómo tiende a usar varias funciones purrr para resolver un problema moderadamente realista: ajustar un modelo a cada subgrupo y extraer un coeficiente del modelo. Para este ejemplo de juguete, voy a dividir el conjunto de datos mtcars en grupos definidos por el número de cilindros, utilizando la función base split:\n\nby_cyl &lt;- split(mtcars, mtcars$cyl)\n\nEsto crea una lista de tres data frames: los automóviles con 4, 6 y 8 cilindros respectivamente.\nAhora imagine que queremos ajustar un modelo lineal, luego extraiga el segundo coeficiente (es decir, la pendiente). El siguiente código muestra cómo puede hacer eso con purrr:\n\nby_cyl |&gt; \n  map(~ lm(mpg ~ wt, data = .x)) |&gt; \n  map(coef) |&gt; \n  map_dbl(2)\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\n(Si no ha visto |&gt;, la canalización, antes, se describe en la Sección 6.3.)\nCreo que este código es fácil de leer porque cada línea encapsula un solo paso, puedes distinguir fácilmente lo funcional de lo que hace, y los ayudantes purrr nos permiten describir de manera muy concisa qué hacer en cada paso.\n¿Cómo atacarías este problema con la base R? Ciertamente podría reemplazar cada función purrr con la función base equivalente:\n\nby_cyl |&gt;  \n  lapply(function(data) lm(mpg ~ wt, data = data)) |&gt; \n  lapply(coef) |&gt; \n  vapply(function(x) x[[2]], double(1))\n#&gt;     4     6     8 \n#&gt; -5.65 -2.78 -2.19\n\nO, por supuesto, podría usar un bucle for:\n\nslopes &lt;- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model &lt;- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] &lt;- coef(model)[[2]]\n}\nslopes\n#&gt; [1] -5.65 -2.78 -2.19\n\nEs interesante notar que a medida que pasa de purrr a aplicar funciones básicas a bucles for, tiende a hacer más y más en cada iteración. En purrr iteramos 3 veces (map(), map(), map_dbl()), con funciones apply iteramos dos veces (lapply(), vapply()), y con un for loop iteramos una vez. Prefiero más pasos, pero más simples, porque creo que hace que el código sea más fácil de entender y luego modificar.",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#sec-map-variants",
    "href": "Functionals.html#sec-map-variants",
    "title": "9  Funcionales",
    "section": "9.4 Variantes de map",
    "text": "9.4 Variantes de map\nHay 23 variantes principales de map(). Hasta ahora, ha aprendido acerca de cinco (map(), map_lgl(), map_int(), map_dbl() y map_chr()). Eso significa que tienes 18 (!!) más para aprender. Eso parece mucho, pero afortunadamente el diseño de purrr significa que solo necesitas aprender cinco nuevas ideas:\n\nSalida del mismo tipo que la entrada con modify()\nIterar sobre dos entradas con map2().\nIterar con un índice usando imap()\nNo devuelve nada con walk().\nIterar sobre cualquier número de entradas con pmap().\n\nLa familia de funciones del mapa tiene entradas y salidas ortogonales, lo que significa que podemos organizar toda la familia en una matriz, con entradas en las filas y salidas en las columnas. Una vez que haya dominado la idea en una fila, puede combinarla con cualquier columna; una vez que haya dominado la idea en una columna, puede combinarla con cualquier fila. Esa relación se resume en el siguiente cuadro:\n\n\n\n\n\n\n\n\n\n\n\nList\nAtómico\nEl mismo tipo\nNada\n\n\n\n\nUn argumento\nmap()\nmap_lgl(), …\nmodify()\nwalk()\n\n\nDos argumentos\nmap2()\nmap2_lgl(), …\nmodify2()\nwalk2()\n\n\nUn argumento + índice\nimap()\nimap_lgl(), …\nimodify()\niwalk()\n\n\nN argumentos\npmap()\npmap_lgl(), …\n—\npwalk()\n\n\n\n\n9.4.1 Mismo tipo de salida que de entrada: modify()\n\nImagina que quisieras duplicar cada columna en un data frame. Primero puede intentar usar map(), pero map() siempre devuelve una lista:\n\ndf &lt;- data.frame(\n  x = 1:3,\n  y = 6:4\n)\n\nmap(df, ~ .x * 2)\n#&gt; $x\n#&gt; [1] 2 4 6\n#&gt; \n#&gt; $y\n#&gt; [1] 12 10  8\n\nSi desea mantener la salida como un data frame, puede usar modify(), que siempre devuelve el mismo tipo de salida que la entrada:\n\nmodify(df, ~ .x * 2)\n#&gt;   x  y\n#&gt; 1 2 12\n#&gt; 2 4 10\n#&gt; 3 6  8\n\nA pesar del nombre, modify() no modifica en su lugar, devuelve una copia modificada, por lo que si desea modificar permanentemente df, debe asignarlo:\n\ndf &lt;- modify(df, ~ .x * 2)\n\nComo de costumbre, la implementación básica de modify() es simple y, de hecho, es incluso más simple que map() porque no necesitamos crear un nuevo vector de salida; podemos simplemente reemplazar progresivamente la entrada. (El código real es un poco complejo para manejar casos extremos con más gracia).\n\nsimple_modify &lt;- function(x, f, ...) {\n  for (i in seq_along(x)) {\n    x[[i]] &lt;- f(x[[i]], ...)\n  }\n  x\n}\n\nEn la Sección 9.6.2 aprenderá sobre una variante muy útil de modify(), llamada modify_if(). Esto le permite (p. ej.) solo duplicar columnas numéricas de un data frame con modify_if(df, is.numeric, ~ .x * 2).\n\n\n9.4.2 Dos entradas: map2() y amigos\n\nmap() se vectoriza sobre un único argumento, .x. Esto significa que solo varía .x cuando se llama a .f, y todos los demás argumentos se pasan sin cambios, por lo que no es adecuado para algunos problemas. Por ejemplo, ¿cómo encontraría una media ponderada cuando tiene una lista de observaciones y una lista de pesos? Imagina que tenemos los siguientes datos:\n\nxs &lt;- map(1:8, ~ runif(10))\nxs[[1]][[1]] &lt;- NA\nws &lt;- map(1:8, ~ rpois(10, 5) + 1)\n\nPuedes usar map_dbl() para calcular las medias no ponderadas:\n\nmap_dbl(xs, mean)\n#&gt; [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443\n\nPero pasar ws como argumento adicional no funciona porque los argumentos después de .f no se transforman:\n\nmap_dbl(xs, weighted.mean, w = ws)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error in `weighted.mean.default()`:\n#&gt; ! 'x' and 'w' must have the same length\n\n\n\n\n\n\n\n\n\n\nNecesitamos una nueva herramienta: un map2(), que se vectoriza sobre dos argumentos. Esto significa que tanto .x como .y varían en cada llamada a .f:\n\nmap2_dbl(xs, ws, weighted.mean)\n#&gt; [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\n\n\n\n\n\n\n\n\n\n\nLos argumentos de map2() son ligeramente diferentes a los argumentos de map() ya que dos vectores vienen antes de la función, en lugar de uno. Los argumentos adicionales todavía van después:\n\nmap2_dbl(xs, ws, weighted.mean, na.rm = TRUE)\n#&gt; [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\n\n\n\n\n\n\n\n\n\n\nLa implementación básica de map2() es simple y bastante similar a la de map(). En lugar de iterar sobre un vector, iteramos sobre dos en paralelo:\n\nsimple_map2 &lt;- function(x, y, f, ...) {\n  out &lt;- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] &lt;- f(x[[i]], y[[i]], ...)\n  }\n  out\n}\n\nUna de las grandes diferencias entre map2() y la función simple anterior es que map2() recicla sus entradas para asegurarse de que tengan la misma longitud:\n\n\n\n\n\n\n\n\n\nEn otras palabras, map2(x, y, f) automáticamente se comportará como map(x, f, y) cuando sea necesario. Esto es útil al escribir funciones; en las secuencias de comandos, generalmente solo usaría la forma más simple directamente.\n\nLa base equivalente más cercana a map2() es Map(), que se analiza en la Sección 9.4.5.\n\n\n\n9.4.3 Sin salidas: walk() y amigos\nLa mayoría de las funciones se llaman por el valor que devuelven, por lo que tiene sentido capturar y almacenar el valor con una función map(). Pero algunas funciones se llaman principalmente por sus efectos secundarios (por ejemplo, cat(), write.csv() o ggsave()) y no tiene sentido capturar sus resultados. Toma este ejemplo simple que muestra un mensaje de bienvenida usando cat(). cat() devuelve NULL, así que mientras map() funciona (en el sentido de que genera las bienvenidas deseadas), también devuelve list(NULL, NULL).\n\nwelcome &lt;- function(x) {\n  cat(\"Welcome \", x, \"!\\n\", sep = \"\")\n}\nnames &lt;- c(\"Hadley\", \"Jenny\")\n\n# Además de generar las bienvenidas, también muestra\n# el valor de retorno de cat()\nmap(names, welcome)\n#&gt; Welcome Hadley!\n#&gt; Welcome Jenny!\n#&gt; [[1]]\n#&gt; NULL\n#&gt; \n#&gt; [[2]]\n#&gt; NULL\n\nPodrías evitar este problema asignando los resultados de map() a una variable que nunca usas, pero que enturbiaría la intención del código. En su lugar, purrr proporciona la familia de funciones walk que ignoran los valores de retorno de .f y en su lugar devuelven .x de forma invisible1.\n\nwalk(names, welcome)\n#&gt; Welcome Hadley!\n#&gt; Welcome Jenny!\n\nMi representación visual de caminar intenta capturar la importante diferencia con map(): las salidas son efímeras y la entrada se devuelve de forma invisible.\n\n\n\n\n\n\n\n\n\nUna de las variantes de walk() más útiles es walk2() porque un efecto secundario muy común es guardar algo en el disco, y cuando guardas algo en el disco siempre tienes un par de valores: el objeto y la ruta que en el que desea guardarlo.\n\n\n\n\n\n\n\n\n\nPor ejemplo, imagina que tienes una lista de data frames (que he creado aquí usando split()) y te gustaría guardar cada uno en un archivo CSV separado. Eso es fácil con walk2():\n\ntemp &lt;- tempfile()\ndir.create(temp)\n\ncyls &lt;- split(mtcars, mtcars$cyl)\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\ndir(temp)\n#&gt; [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\"\n\nAquí el walk2 () es equivalente a write.csv(cyls[[1]], paths[[1]]), write.csv(cyls[[2]], paths[[2]]), write.csv(cyls[[3]], paths[[3]]).\n\nNo existe una base equivalente a walk(); envuelva el resultado de lapply() en invisible() o guárdelo en una variable que nunca se use.\n\n\n\n9.4.4 Iterando sobre valores e índices\n\n\nHay tres formas básicas de recorrer un vector con un bucle for:\n\nBucle sobre los elementos: for (x in xs)\nBucle sobre los índices numéricos: for (i in seq_along(xs))\nBucle sobre los nombres: for (nm in names(xs))\n\nLa primera forma es análoga a la familia map(). Las formas segunda y tercera son equivalentes a la familia imap() que le permite iterar sobre los valores y los índices de un vector en paralelo.\nimap() es como map2() en el sentido de que su .f se llama con dos argumentos, pero aquí ambos se derivan del vector. imap(x, f) es equivalente a map2(x, nombres(x), f) si x tiene nombres, y map2(x, seq_along(x), f) si no los tiene.\nimap() suele ser útil para construir etiquetas:\n\nimap_chr(iris, ~ paste0(\"The first value of \", .y, \" is \", .x[[1]]))\n#&gt;                             Sepal.Length \n#&gt; \"The first value of Sepal.Length is 5.1\" \n#&gt;                              Sepal.Width \n#&gt;  \"The first value of Sepal.Width is 3.5\" \n#&gt;                             Petal.Length \n#&gt; \"The first value of Petal.Length is 1.4\" \n#&gt;                              Petal.Width \n#&gt;  \"The first value of Petal.Width is 0.2\" \n#&gt;                                  Species \n#&gt;   \"The first value of Species is setosa\"\n\nSi el vector no tiene nombre, el segundo argumento será el índice:\n\nx &lt;- map(1:6, ~ sample(1000, 10))\nimap_chr(x, ~ paste0(\"The highest value of \", .y, \" is \", max(.x)))\n#&gt; [1] \"The highest value of 1 is 975\" \"The highest value of 2 is 915\"\n#&gt; [3] \"The highest value of 3 is 982\" \"The highest value of 4 is 955\"\n#&gt; [5] \"The highest value of 5 is 971\" \"The highest value of 6 is 696\"\n\nimap() es una ayuda útil si desea trabajar con los valores de un vector junto con sus posiciones.\n\n\n9.4.5 Cualquier número de entradas: pmap () y amigos\n\nYa que tenemos map() y map2(), podrías esperar map3(), map4(), map5(), … Pero, ¿dónde te detendrías? En lugar de generalizar map2() a un número arbitrario de argumentos, purrr adopta un rumbo ligeramente diferente con pmap(): le proporciona una sola lista, que contiene cualquier número de argumentos. En la mayoría de los casos, será una lista de vectores de igual longitud, es decir, algo muy similar a un data frame. En los diagramas, enfatizaré esa relación dibujando la entrada de forma similar a un data frame.\n\n\n\n\n\n\n\n\n\nHay una equivalencia simple entre map2() y pmap(): map2(x, y, f) es lo mismo que pmap(list(x, y), f). El pmap() equivalente a map2_dbl(xs, ws,weighted.mean) utilizado anteriormente es:\n\npmap_dbl(list(xs, ws), weighted.mean)\n#&gt; [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\n\nComo antes, los argumentos variables vienen antes de .f (aunque ahora deben estar envueltos en una lista), y los argumentos constantes vienen después.\n\npmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)\n#&gt; [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\n\n\n\n\n\n\n\n\n\n\nUna gran diferencia entre pmap() y las otras funciones de mapa es que pmap() te da un control mucho más preciso sobre la coincidencia de argumentos porque puedes nombrar los componentes de la lista. Volviendo a nuestro ejemplo de la Sección 9.2.5, donde queríamos cambiar el argumento trim a x, podríamos usar pmap():\n\ntrims &lt;- c(0, 0.1, 0.2, 0.5)\nx &lt;- rcauchy(1000)\n\npmap_dbl(list(trim = trims), mean, x = x)\n#&gt; [1] -6.6740  0.0210  0.0235  0.0151\n\nCreo que es una buena práctica nombrar los componentes de la lista para dejar muy claro cómo se llamará a la función.\nA menudo es conveniente llamar a pmap() con un data frame. Una forma práctica de crear ese data frame es con tibble::tribble(), que le permite describir un data frame fila por fila (en lugar de columna por columna, como de costumbre): pensando en los parámetros a una función como data frame es un patrón muy poderoso. El siguiente ejemplo muestra cómo puede dibujar números uniformes aleatorios con diferentes parámetros:\n\nparams &lt;- tibble::tribble(\n  ~ n, ~ min, ~ max,\n   1L,     0,     1,\n   2L,    10,   100,\n   3L,   100,  1000\n)\n\npmap(params, runif)\n#&gt; [[1]]\n#&gt; [1] 0.332\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 53.5 47.6\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 231 715 515\n\n\n\n\n\n\n\n\n\n\nAquí, los nombres de las columnas son fundamentales: elegí cuidadosamente hacerlos coincidir con los argumentos de runif(), por lo que pmap(params, runif) es equivalente a runif(n = 1L, min = 0, max = 1), runif(n = 2, min = 10, max = 100), runif(n = 3L, min = 100, max = 1000). (Si tiene un data frame en la mano y los nombres no coinciden, use dplyr::rename() o similar).\n\nHay dos equivalentes base para la familia pmap(): Map() y mapply(). Ambos tienen importantes inconvenientes:\n\nMap() vectoriza sobre todos los argumentos para que no pueda proporcionar argumentos que no varíen.\nmapply() es la versión multidimensional de sapply(); conceptualmente, toma la salida de Map() y la simplifica si es posible. Esto le da problemas similares a sapply(). No existe un equivalente de múltiples entradas de vapply().\n\n\n\n\n9.4.6 Ejercicios\n\nExplique los resultados de modify(mtcars, 1).\nReescribe el siguiente código para usar iwalk() en lugar de walk2(). ¿Cuáles son las ventajas y desventajas?\n\ncyls &lt;- split(mtcars, mtcars$cyl)\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\nExplique cómo el siguiente código transforma un data frame utilizando funciones almacenadas en una lista.\n\ntrans &lt;- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm &lt;- names(trans)\nmtcars[nm] &lt;- map2(trans, mtcars[nm], function(f, var) f(var))\n\nCompare y contraste el enfoque map2() con este enfoque map():\n\nmtcars[nm] &lt;- map(nm, ~ trans[[.x]](mtcars[[.x]]))\n\n¿Qué devuelve write.csv(), es decir, qué sucede si lo usa con map2() en lugar de walk2()?",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#sec-reduce",
    "href": "Functionals.html#sec-reduce",
    "title": "9  Funcionales",
    "section": "9.5 Familia reduce",
    "text": "9.5 Familia reduce\nDespués de la familia map, la siguiente familia de funciones más importante es la familia reduce. Esta familia es mucho más pequeña, con solo dos variantes principales, y se usa con menos frecuencia, pero es una idea poderosa, nos brinda la oportunidad de analizar algo de álgebra útil y potencia el marco de reducción de mapas que se usa con frecuencia para procesar conjuntos de datos muy grandes.\n\n9.5.1 Lo esencial\n\n\nreduce() toma un vector de longitud n y produce un vector de longitud 1 llamando a una función con un par de valores a la vez: reduce(1:4, f) es equivalente a f(f(f(1, 2), 3), 4).\n\n\n\n\n\n\n\n\n\nreduce() es una forma útil de generalizar una función que funciona con dos entradas (una función binaria) para que funcione con cualquier cantidad de entradas. Imagina que tienes una lista de vectores numéricos y quieres encontrar los valores que ocurren en cada elemento. Primero generamos algunos datos de muestra:\n\nl &lt;- map(1:4, ~ sample(1:10, 15, replace = T))\nstr(l)\n#&gt; List of 4\n#&gt;  $ : int [1:15] 7 1 8 8 3 8 2 4 7 10 ...\n#&gt;  $ : int [1:15] 3 1 10 2 5 2 9 8 5 4 ...\n#&gt;  $ : int [1:15] 6 10 9 5 6 7 8 6 10 8 ...\n#&gt;  $ : int [1:15] 9 8 6 4 4 5 2 9 9 6 ...\n\nPara resolver este desafío necesitamos usar intersect() repetidamente:\n\nout &lt;- l[[1]]\nout &lt;- intersect(out, l[[2]])\nout &lt;- intersect(out, l[[3]])\nout &lt;- intersect(out, l[[4]])\nout\n#&gt; [1] 8 4\n\nreduce() Automatiza esta solución para nosotros, para que podamos escribir:\n\nreduce(l, intersect)\n#&gt; [1] 8 4\n\nPodríamos aplicar la misma idea si quisiéramos listar todos los elementos que aparecen en al menos una entrada. Todo lo que tenemos que hacer es cambiar de intersect() a union():\n\nreduce(l, union)\n#&gt;  [1]  7  1  8  3  2  4 10  5  9  6\n\nAl igual que la familia de mapas, también puede pasar argumentos adicionales. intersect() y union() no aceptan argumentos adicionales, así que no puedo demostrarlos aquí, pero el principio es sencillo y le hice un dibujo.\n\n\n\n\n\n\n\n\n\nComo de costumbre, la esencia de reduce() se puede reducir a un simple envoltorio alrededor de un bucle for:\n\nsimple_reduce &lt;- function(x, f) {\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n  out\n}\n\n\nEl equivalente básico es Reduce(). Tenga en cuenta que el orden de los argumentos es diferente: la función viene primero, seguida del vector, y no hay forma de proporcionar argumentos adicionales.\n\n\n\n9.5.2 accumulate\n\nLa primera variante reduce(), accumulate(), es útil para comprender cómo funciona reduce, porque en lugar de devolver solo el resultado final, también devuelve todos los resultados intermedios:\n\naccumulate(l, intersect)\n#&gt; [[1]]\n#&gt;  [1]  7  1  8  8  3  8  2  4  7 10 10  3  7 10 10\n#&gt; \n#&gt; [[2]]\n#&gt; [1]  1  8  3  2  4 10\n#&gt; \n#&gt; [[3]]\n#&gt; [1]  8  4 10\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 8 4\n\nOtra forma útil de entender reduce es pensar en sum(): sum(x) es equivalente a x[[1]] + x[[2]] + x[[3]] + ..., es decir reduce(x, `+`). Entonces accumulate(x, `+`) es la suma acumulada:\n\nx &lt;- c(4, 3, 10)\nreduce(x, `+`)\n#&gt; [1] 17\n\naccumulate(x, `+`)\n#&gt; [1]  4  7 17\n\n\n\n9.5.3 Tipos de salida\nEn el ejemplo anterior usando +, ¿qué debería devolver reduce() cuando x es corto, es decir, longitud 1 o 0? Sin argumentos adicionales, reduce() solo devuelve la entrada cuando x tiene una longitud de 1:\n\nreduce(1, `+`)\n#&gt; [1] 1\n\nEsto significa que reduce() no tiene forma de verificar que la entrada sea válida:\n\nreduce(\"a\", `+`)\n#&gt; [1] \"a\"\n\n¿Qué pasa si es de longitud 0? Recibimos un error que sugiere que necesitamos usar el argumento .init:\n\nreduce(integer(), `+`)\n#&gt; Error in `reduce()`:\n#&gt; ! Must supply `.init` when `.x` is empty.\n\n¿Qué debería ser .init aquí? Para averiguarlo, necesitamos ver qué sucede cuando se proporciona .init:\n\n\n\n\n\n\n\n\n\nAsí que si llamamos a reduce(1, `+`, init) el resultado será `1 + init. Ahora sabemos que el resultado debería ser solo 1, lo que sugiere que .init debería ser 0:\n\nreduce(integer(), `+`, .init = 0)\n#&gt; [1] 0\n\nEsto también asegura que reduce() verifique que las entradas de longitud 1 sean válidas para la función que estás llamando:\n\nreduce(\"a\", `+`, .init = 0)\n#&gt; Error in .x + .y: non-numeric argument to binary operator\n\nSi quieres ser algebraico al respecto, 0 se llama la identidad de los números reales en la operación de suma: si agregas un 0 a cualquier número, obtienes el mismo número. R aplica el mismo principio para determinar qué debe devolver una función de resumen con una entrada de longitud cero:\n\nsum(integer())  # x + 0 = x\n#&gt; [1] 0\nprod(integer()) # x * 1 = x\n#&gt; [1] 1\nmin(integer())  # min(x, Inf) = x\n#&gt; [1] Inf\nmax(integer())  # max(x, -Inf) = x\n#&gt; [1] -Inf\n\nSi está utilizando reduce() en una función, siempre debe proporcionar .init. Piense detenidamente qué debe devolver su función cuando pasa un vector de longitud 0 o 1, y asegúrese de probar su implementación.\n\n\n9.5.4 Múltiples entradas\n\nMuy ocasionalmente necesita pasar dos argumentos a la función que está reduciendo. Por ejemplo, puede tener una lista de data frames que desea unir y las variables que usa para unir variarán de un elemento a otro. Este es un escenario muy especializado, por lo que no quiero dedicarle mucho tiempo, pero sí quiero que sepas que reduce2() existe.\nLa longitud del segundo argumento varía en función de si se proporciona .init o no: si tiene cuatro elementos de x, f solo se llamará tres veces. Si proporciona init, f se llamará cuatro veces.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.5.5 Mapa reducido\n\nEs posible que haya oído hablar de map-reduce, la idea que impulsa la tecnología como Hadoop. Ahora puedes ver cuán simple y poderosa es la idea subyacente: map-reduce es un mapa combinado con una reducción. La diferencia para los datos grandes es que los datos se distribuyen en varias computadoras. Cada computadora realiza el mapa en los datos que tiene, luego envía el resultado a un coordinador que reduce los resultados individuales a un solo resultado.\nComo un ejemplo simple, imagine calcular la media de un vector muy grande, tan grande que tiene que dividirse entre varias computadoras. Puede pedirle a cada computadora que calcule la suma y la longitud, y luego devolverlos al coordinador que calcula la media general dividiendo la suma total por la longitud total.",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#sec-predicate-functionals",
    "href": "Functionals.html#sec-predicate-functionals",
    "title": "9  Funcionales",
    "section": "9.6 Funcionales de predicado",
    "text": "9.6 Funcionales de predicado\n \nUn predicado es una función que devuelve un solo TRUE o FALSE, como is.character(), is.null() o all(), y decimos un predicado coincide con un vector si devuelve TRUE.\n\n9.6.1 Lo esencial\nUn predicado funcional aplica un predicado a cada elemento de un vector. purrr proporciona siete funciones útiles que se dividen en tres grupos:\n\nsome(.x, .p) devuelve TRUE si algún elemento coincide;\nevery(.x, .p) devuelve TRUE si todos los elementos coinciden;\nnone(.x, .p) devuelve TRUE si ningún elemento coincide.\nEstos son similares a any(map_lgl(.x, .p)), all(map_lgl(.x, .p)) y all(map_lgl(.x, negate(.p))) pero terminar antes de tiempo: some() devuelve TRUE cuando ve el primer TRUE, y cada() y ninguno() devuelve FALSE cuando ven el primer FALSE o TRUE respectivamente .\ndetect(.x, .p) devuelve el valor de la primera coincidencia; detect_index(.x, .p) devuelve la ubicación de la primera coincidencia.\nkeep(.x, .p) mantiene todos los elementos coincidentes; discard(.x, .p) suelta todos los elementos coincidentes.\n\nEl siguiente ejemplo muestra cómo puede usar estas funciones con un data frame:\n\ndf &lt;- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\ndetect(df, is.factor)\n#&gt; NULL\ndetect_index(df, is.factor)\n#&gt; [1] 0\n\nstr(keep(df, is.factor))\n#&gt; 'data.frame':    3 obs. of  0 variables\nstr(discard(df, is.factor))\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\n\n\n9.6.2 Variantes de map\nmap() y modify() vienen en variantes que también toman funciones de predicado, transformando solo los elementos de .x donde .p es TRUE.\n\ndf &lt;- data.frame(\n  num1 = c(0, 10, 20),\n  num2 = c(5, 6, 7),\n  chr1 = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\n\nstr(map_if(df, is.numeric, mean))\n#&gt; List of 3\n#&gt;  $ num1: num 10\n#&gt;  $ num2: num 6\n#&gt;  $ chr1: chr [1:3] \"a\" \"b\" \"c\"\nstr(modify_if(df, is.numeric, mean))\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ num1: num  10 10 10\n#&gt;  $ num2: num  6 6 6\n#&gt;  $ chr1: chr  \"a\" \"b\" \"c\"\nstr(map(keep(df, is.numeric), mean))\n#&gt; List of 2\n#&gt;  $ num1: num 10\n#&gt;  $ num2: num 6\n\n\n\n9.6.3 Ejercicios\n\n¿Por qué is.na() no es una función de predicado? ¿Qué función base de R está más cerca de ser una versión predicada de is.na()?\nsimple_reduce() tiene un problema cuando x tiene una longitud de 0 o de 1. Describa el origen del problema y cómo podría solucionarlo.\n\nsimple_reduce &lt;- function(x, f) {\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n  out\n}\n\nImplemente la función span() de Haskell: dada una lista x y una función de predicado f, span(x, f) devuelve la ubicación de la ejecución secuencial más larga de elementos donde el predicado es verdadero. (Sugerencia: puede encontrar útil rle()).\nImplementar arg_max(). Debe tomar una función y un vector de entradas, y devolver los elementos de la entrada donde la función devuelve el valor más alto. Por ejemplo, arg_max(-10:5, function(x) x ^ 2) debería devolver -10. arg_max(-5:5, function(x) x ^ 2) debería devolver c(-5, 5). Implemente también la función coincidente arg_min().\nLa siguiente función escala un vector para que caiga en el rango [0, 1]. ¿Cómo lo aplicaría a cada columna de un data frame? ¿Cómo lo aplicaría a cada columna numérica en un data frame?\n\nscale01 &lt;- function(x) {\n  rng &lt;- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#sec-base-functionals",
    "href": "Functionals.html#sec-base-functionals",
    "title": "9  Funcionales",
    "section": "9.7 Funcionales base",
    "text": "9.7 Funcionales base\nPara terminar el capítulo, aquí ofrezco un resumen de importantes funciones base que no son miembros de las familias map, reduce o predicate y, por lo tanto, no tienen equivalente en purrr. Esto no quiere decir que no sean importantes, pero tienen un sabor más matemático o estadístico y, en general, son menos útiles en el análisis de datos.\n\n9.7.1 Matrices y arreglos\n\nmap() y amigos están especializados para trabajar con vectores unidimensionales. base::apply() está especializado para trabajar con vectores bidimensionales y superiores, es decir, matrices y arreglos. Puede pensar en apply() como una operación que resume una matriz o conjunto al colapsar cada fila o columna en un solo valor. Tiene cuatro argumentos:\n\nX, la matriz o arreglo para resumir.\nMARGIN, un vector entero que da las dimensiones para resumir, 1 = filas, 2 = columnas, etc. (El nombre del argumento proviene de pensar en los márgenes de una distribución conjunta).\nFUN, una función de resumen.\n... otros argumentos pasan a FUN.\n\nUn ejemplo típico de apply() se ve así\n\na2d &lt;- matrix(1:20, nrow = 5)\napply(a2d, 1, mean)\n#&gt; [1]  8.5  9.5 10.5 11.5 12.5\napply(a2d, 2, mean)\n#&gt; [1]  3  8 13 18\n\n\nPuede especificar múltiples dimensiones para MARGIN, lo cual es útil para arreglos de alta dimensión:\n\na3d &lt;- array(1:24, c(2, 3, 4))\napply(a3d, 1, mean)\n#&gt; [1] 12 13\napply(a3d, c(1, 2), mean)\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   10   12   14\n#&gt; [2,]   11   13   15\n\nHay dos advertencias para usar apply():\n\nAl igual que base::sapply(), no tienes control sobre el tipo de salida; se simplificará automáticamente a una lista, matriz o vector. Sin embargo, generalmente usa apply() con matrices numéricas y una función de resumen numérico, por lo que es menos probable que encuentre un problema que con sapply().\napply() tampoco es idempotente en el sentido de que si la función de resumen es el operador de identidad, la salida no siempre es la misma que la entrada.\n\na1 &lt;- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#&gt; [1] FALSE\n\na2 &lt;- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#&gt; [1] TRUE\n\nNunca uses apply() con un data frame. Siempre lo obliga a una matriz, lo que conducirá a resultados no deseados si su data frame contiene algo más que números.\n\ndf &lt;- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\napply(df, 2, mean)\n#&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#&gt; returning NA\n#&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#&gt; returning NA\n#&gt;  x  y \n#&gt; NA NA\n\n\n\n\n9.7.2 Preocupaciones matemáticas\nLos funcionales son muy comunes en matemáticas. El límite, el máximo, las raíces (el conjunto de puntos donde f(x) = 0) y la integral definida son todos funcionales: dada una función, devuelven un solo número (o vector de números). A primera vista, estas funciones no parecen encajar con el tema de la eliminación de bucles, pero si profundiza, descubrirá que todas se implementan mediante un algoritmo que implica iteración.\nBase R proporciona un conjunto útil:\n\nintegrate() encuentra el área bajo la curva definida por f()\nuniroot() encuentra donde f() llega a cero\noptimise() encuentra la ubicación del valor más bajo (o más alto) de f()\n\nEl siguiente ejemplo muestra cómo se pueden usar los funcionales con una función simple, sin():\n\nintegrate(sin, 0, pi)\n#&gt; 2 with absolute error &lt; 2.2e-14\nstr(uniroot(sin, pi * c(1 / 2, 3 / 2)))\n#&gt; List of 5\n#&gt;  $ root      : num 3.14\n#&gt;  $ f.root    : num 1.22e-16\n#&gt;  $ iter      : int 2\n#&gt;  $ init.it   : int NA\n#&gt;  $ estim.prec: num 6.1e-05\nstr(optimise(sin, c(0, 2 * pi)))\n#&gt; List of 2\n#&gt;  $ minimum  : num 4.71\n#&gt;  $ objective: num -1\nstr(optimise(sin, c(0, pi), maximum = TRUE))\n#&gt; List of 2\n#&gt;  $ maximum  : num 1.57\n#&gt;  $ objective: num 1\n\n\n\n9.7.3 Ejercicios\n\n¿Cómo organiza apply() la salida? Lea la documentación y realice algunos experimentos.\n¿Qué hacen eapply() y rapply()? ¿En purrr tiene equivalentes?\nDesafío: lea sobre el algoritmo de punto fijo. Completa los ejercicios usando R.\n\n\n\n\n\nHenry, Lionel, y Hadley Wickham. 2018. purrr: functional programming tools. https://purrr.tidyverse.org.",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Functionals.html#footnotes",
    "href": "Functionals.html#footnotes",
    "title": "9  Funcionales",
    "section": "",
    "text": "En resumen, los valores invisibles solo se imprimen si lo solicita explícitamente. Esto los hace muy adecuados para las funciones llamadas principalmente por sus efectos secundarios, ya que permite ignorar su salida de forma predeterminada, al tiempo que ofrece una opción para capturarla. Ver Sección 6.7.2 para más detalles.↩︎",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Funcionales</span>"
    ]
  },
  {
    "objectID": "Function-factories.html",
    "href": "Function-factories.html",
    "title": "10  Fábricas de funciones",
    "section": "",
    "text": "10.1 Introducción\nUna fábrica de funciones es una función que hace funciones. Aquí hay un ejemplo muy simple: usamos una fábrica de funciones (power1()) para hacer dos funciones secundarias (square() y cube()):\npower1 &lt;- function(exp) {\n  function(x) {\n    x ^ exp\n  }\n}\n\nsquare &lt;- power1(2)\ncube &lt;- power1(3)\nNo se preocupe si esto aún no tiene sentido, ¡debería tenerlo al final del capítulo!\nLlamaré square() y cube() funciones fabricadas, pero este es solo un término para facilitar la comunicación con otros humanos: desde la perspectiva de R, no son diferentes a las funciones creadas de otra manera.\nsquare(3)\n#&gt; [1] 9\ncube(3)\n#&gt; [1] 27\nYa ha aprendido acerca de los componentes individuales que hacen posibles las fábricas de funciones:\nEn este capítulo, aprenderá cómo la combinación no obvia de estas tres funciones conduce a la fábrica de funciones. También verá ejemplos de su uso en visualización y estadísticas.\nDe las tres principales herramientas de programación funcional (funcionales, fábricas de funciones y operadores de funciones), las fábricas de funciones son las menos utilizadas. En general, no tienden a reducir la complejidad general del código, sino que dividen la complejidad en fragmentos más fáciles de digerir. Las fábricas de funciones también son un bloque de construcción importante para los muy útiles operadores de funciones, sobre los cuales aprenderá en el Capítulo 11.",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fábricas de funciones</span>"
    ]
  },
  {
    "objectID": "Function-factories.html#introducción",
    "href": "Function-factories.html#introducción",
    "title": "10  Fábricas de funciones",
    "section": "",
    "text": "En la Sección 6.2.3, aprendiste sobre las funciones de primera clase de R. En R, vinculas una función a un nombre de la misma manera que vinculas cualquier objeto a un nombre: con &lt;-.\nEn la Sección 7.4.2, aprendiste que una función captura (encierra) el entorno en el que se crea.\nEn la Sección 7.4.4, aprendió que una función crea un nuevo entorno de ejecución cada vez que se ejecuta. Este entorno suele ser efímero, pero aquí se convierte en el entorno envolvente de la función fabricada.\n\n\n\n\nEstructura\n\nLa Sección 10.2 comienza el capítulo con una explicación de cómo funcionan las fábricas de funciones, reuniendo ideas del alcance y los entornos. También verá cómo se pueden usar fábricas de funciones para implementar una memoria para funciones, lo que permite que los datos persistan entre llamadas.\nLa Sección 10.3 ilustra el uso de fábricas de funciones con ejemplos de ggplot2. Verá dos ejemplos de cómo funciona ggplot2 con fábricas de funciones proporcionadas por el usuario y un ejemplo de cómo ggplot2 usa una fábrica de funciones internamente.\nLa Sección 10.4 utiliza fábricas de funciones para abordar tres desafíos de las estadísticas: comprender la transformación de Box-Cox, resolver problemas de máxima verosimilitud y dibujar remuestreos de arranque.\nLa Sección 10.5 muestra cómo puede combinar fábricas de funciones y funcionales para generar rápidamente una familia de funciones a partir de datos.\n\n\n\nRequisitos previos\nAsegúrese de estar familiarizado con el contenido de las Secciones Sección 6.2.3 (funciones de primera clase), Sección 7.4.2 (el entorno funcional) y Sección 7.4.4 (entornos de ejecución) mencionados anteriormente.\nLas fábricas de funciones solo necesitan base R. Usaremos un poco de rlang para mirar dentro de ellas más fácilmente, y usaremos ggplot2 y scales para explorar el uso de fábricas de funciones en la visualización.\n\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(scales)",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fábricas de funciones</span>"
    ]
  },
  {
    "objectID": "Function-factories.html#sec-factory-fundamentals",
    "href": "Function-factories.html#sec-factory-fundamentals",
    "title": "10  Fábricas de funciones",
    "section": "10.2 Fundamentos de fábrica",
    "text": "10.2 Fundamentos de fábrica\nLa idea clave que hace que las fábricas de funciones funcionen se puede expresar de manera muy concisa:\n\nEl entorno envolvente de la función fabricada es un entorno de ejecución de la fábrica de funciones.\n\nSolo se necesitan unas pocas palabras para expresar estas grandes ideas, pero se necesita mucho más trabajo para entender realmente lo que esto significa. Esta sección te ayudará a juntar las piezas con exploración interactiva y algunos diagramas.\n\n10.2.1 Entornos\nEmpecemos echando un vistazo a square() y cube():\n\nsquare\n#&gt; function(x) {\n#&gt;     x ^ exp\n#&gt;   }\n#&gt; &lt;environment: 0x56249ca67520&gt;\n\ncube\n#&gt; function(x) {\n#&gt;     x ^ exp\n#&gt;   }\n#&gt; &lt;bytecode: 0x56249a774ab8&gt;\n#&gt; &lt;environment: 0x56249cad3258&gt;\n\nEs obvio de dónde viene x, pero ¿cómo encuentra R el valor asociado con exp? La simple impresión de las funciones fabricadas no es reveladora porque los cuerpos son idénticos; los contenidos del entorno envolvente son los factores importantes. Podemos obtener un poco más de información usando rlang::env_print(). Eso nos muestra que tenemos dos entornos diferentes (cada uno de los cuales era originalmente un entorno de ejecución de power1()). Los entornos tienen el mismo padre, que es el entorno envolvente de power1(), el entorno global.\n\nenv_print(square)\n#&gt; &lt;environment: 0x56249ca67520&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • exp: &lt;dbl&gt;\n\nenv_print(cube)\n#&gt; &lt;environment: 0x56249cad3258&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • exp: &lt;dbl&gt;\n\nenv_print() nos muestra que ambos entornos tienen un enlace a exp, pero queremos ver su valor 1. Podemos hacerlo obteniendo primero el entorno de la función y luego extrayendo los valores:\n\nfn_env(square)$exp\n#&gt; [1] 2\n\nfn_env(cube)$exp\n#&gt; [1] 3\n\nEsto es lo que hace que las funciones fabricadas se comporten de manera diferente entre sí: los nombres en el entorno adjunto están vinculados a valores diferentes.\n\n\n10.2.2 Convenciones de diagrama\nTambién podemos mostrar estas relaciones en un diagrama:\n\n\n\n\n\n\n\n\n\nEstán sucediendo muchas cosas en este diagrama y algunos de los detalles no son tan importantes. Podemos simplificar considerablemente usando dos convenciones:\n\nCualquier símbolo flotante libre vive en el entorno global.\nCualquier entorno sin un padre explícito hereda del entorno global.\n\n\n\n\n\n\n\n\n\n\nEsta vista, que se centra en los entornos, no muestra ningún vínculo directo entre cube() y square(). Esto se debe a que el enlace se realiza a través del cuerpo de la función, que es idéntico para ambos, pero no se muestra en este diagrama.\nPara terminar, veamos el entorno de ejecución de square(10). Cuando square() ejecuta x ^ exp, encuentra x en el entorno de ejecución y exp en su entorno adjunto.\n\nsquare(10)\n#&gt; [1] 100\n\n\n\n\n\n\n\n\n\n\n\n\n10.2.3 Evaluación forzada\nHay un error sutil en power1() causado por una evaluación perezosa. Para ver el problema necesitamos introducir alguna indirección:\n\nx &lt;- 2\nsquare &lt;- power1(x)\nx &lt;- 3\n\n¿Qué debería devolver square(2)? Esperarías que devuelva 4:\n\nsquare(2)\n#&gt; [1] 8\n\nDesafortunadamente, no es así porque x solo se evalúa con pereza cuando se ejecuta square(), no cuando se ejecuta power1(). En general, este problema surgirá cada vez que cambie un enlace entre llamar a la función de fábrica y llamar a la función fabricada. Es probable que esto suceda rara vez, pero cuando sucede, conducirá a un verdadero error de rascado de cabeza.\nPodemos solucionar este problema forzando la evaluación con force():\n\npower2 &lt;- function(exp) {\n  force(exp)\n  function(x) {\n    x ^ exp\n  }\n}\n\nx &lt;- 2\nsquare &lt;- power2(x)\nx &lt;- 3\nsquare(2)\n#&gt; [1] 4\n\nCada vez que cree una fábrica de funciones, asegúrese de que se evalúen todos los argumentos, usando force() según sea necesario si el argumento solo lo usa la función fabricada.\n\n\n10.2.4 Funciones con estado\n\n\nLas fábricas de funciones también le permiten mantener el estado a través de las invocaciones de funciones, lo que generalmente es difícil de hacer debido al principio de nuevo comienzo descrito en la Sección 6.4.3.\nHay dos cosas que lo hacen posible:\n\nEl entorno envolvente de la función fabricada es único y constante.\nR tiene un operador de asignación especial, &lt;&lt;-, que modifica los enlaces en el entorno envolvente.\n\nEl operador de asignación habitual, &lt;-, siempre crea un enlace en el entorno actual. El operador de superasignación, &lt;&lt;- vuelve a vincular un nombre existente que se encuentra en un entorno principal.\nEl siguiente ejemplo muestra cómo podemos combinar estas ideas para crear una función que registre cuántas veces ha sido llamada:\n\nnew_counter &lt;- function() {\n  i &lt;- 0\n  \n  function() {\n    i &lt;&lt;- i + 1\n    i\n  }\n}\n\ncounter_one &lt;- new_counter()\ncounter_two &lt;- new_counter()\n\n\n\n\n\n\n\n\n\n\nCuando se ejecuta la función fabricada, i &lt;&lt;- i + 1 modificará i en su entorno adjunto. Debido a que las funciones fabricadas tienen entornos envolventes independientes, tienen recuentos independientes:\n\ncounter_one()\n#&gt; [1] 1\ncounter_one()\n#&gt; [1] 2\ncounter_two()\n#&gt; [1] 1\n\n\n\n\n\n\n\n\n\n\nLas funciones con estado se utilizan mejor con moderación. Tan pronto como su función comience a administrar el estado de múltiples variables, es mejor cambiar a R6, el tema del Capítulo 14.\n\n\n10.2.5 Recolección de basura\n\nCon la mayoría de las funciones, puede confiar en el recolector de basura para limpiar cualquier objeto temporal grande creado dentro de una función. Sin embargo, las funciones fabricadas se aferran al entorno de ejecución, por lo que deberá desvincular explícitamente cualquier objeto temporal grande con rm(). Compara los tamaños de g1() y g2() en el siguiente ejemplo:\n\nf1 &lt;- function(n) {\n  x &lt;- runif(n)\n  m &lt;- mean(x)\n  function() m\n}\n\ng1 &lt;- f1(1e6)\nlobstr::obj_size(g1)\n#&gt; 8.01 MB\n\nf2 &lt;- function(n) {\n  x &lt;- runif(n)\n  m &lt;- mean(x)\n  rm(x)\n  function() m\n}\n\ng2 &lt;- f2(1e6)\nlobstr::obj_size(g2)\n#&gt; 12.96 kB\n\n\n\n10.2.6 Ejercicios\n\nLa definición de force() es simple:\n\nforce\n#&gt; function (x) \n#&gt; x\n#&gt; &lt;bytecode: 0x562496d04ce0&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nWhy is it better to force(x) instead of just x?\nBase R contiene dos fábricas de funciones, approxfun() y ecdf(). Lea su documentación y experimente para descubrir qué hacen las funciones y qué devuelven.\nCree una función pick() que tome un índice, i, como argumento y devuelva una función con un argumento x que subjunte x con i.\n\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\n\nCree una función que cree funciones que calculen el ith momento central de un vector numérico. Puedes probarlo ejecutando el siguiente código:\n\nm1 &lt;- moment(1)\nm2 &lt;- moment(2)\n\nx &lt;- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\n\n¿Qué pasa si no usas un cierre? Haz predicciones, luego verifica con el siguiente código.\n\ni &lt;- 0\nnew_counter2 &lt;- function() {\n  i &lt;&lt;- i + 1\n  i\n}\n\n¿Qué sucede si usa &lt;- en lugar de &lt;&lt;-? Haz predicciones, luego verifica con el siguiente código.\n\nnew_counter3 &lt;- function() {\n  i &lt;- 0\n  function() {\n    i &lt;- i + 1\n    i\n  }\n}",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fábricas de funciones</span>"
    ]
  },
  {
    "objectID": "Function-factories.html#sec-graph-fact",
    "href": "Function-factories.html#sec-graph-fact",
    "title": "10  Fábricas de funciones",
    "section": "10.3 Fábricas gráficas",
    "text": "10.3 Fábricas gráficas\nComenzaremos nuestra exploración de fábricas de funciones útiles con algunos ejemplos de ggplot2.\n\n10.3.1 Etiquetado\nUno de los objetivos del paquete scales es facilitar la personalización de las etiquetas en ggplot2. Proporciona muchas funciones para controlar los detalles finos de ejes y leyendas. Las funciones del formateador2 son una clase útil de funciones que facilitan el control de la aparición de roturas de ejes. El diseño de estas funciones inicialmente puede parecer un poco extraño: todas devuelven una función, a la que debe llamar para formatear un número.\n\ny &lt;- c(12345, 123456, 1234567)\ncomma_format()(y)\n#&gt; [1] \"12,345\"    \"123,456\"   \"1,234,567\"\n\nnumber_format(scale = 1e-3, suffix = \" K\")(y)\n#&gt; [1] \"12 K\"    \"123 K\"   \"1 235 K\"\n\nEn otras palabras, la interfaz principal es una fábrica de funciones. A primera vista, esto parece agregar una complejidad adicional por poca ganancia. Pero permite una buena interacción con las escalas de ggplot2, porque aceptan funciones en el argumento label:\n\ndf &lt;- data.frame(x = 1, y = y)\ncore &lt;- ggplot(df, aes(x, y)) + \n  geom_point() + \n  scale_x_continuous(breaks = 1, labels = NULL) +\n  labs(x = NULL, y = NULL)\n  \ncore\ncore + scale_y_continuous(\n  labels = comma_format()\n)\ncore + scale_y_continuous(\n  labels = number_format(scale = 1e-3, suffix = \" K\")\n)\ncore + scale_y_continuous(\n  labels = scientific_format()\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.3.2 Contenedores de histograma\nUna característica poco conocida de geom_histogram() es que el argumento binwidth puede ser una función. Esto es particularmente útil porque la función se ejecuta una vez para cada grupo, lo que significa que puede tener diferentes anchos de bin en diferentes facetas, lo que de otro modo no sería posible.\nPara ilustrar esta idea y ver dónde podría ser útil el ancho de bin variable, voy a construir un ejemplo en el que un ancho de bin fijo no es muy bueno.\n\n# construir algunos datos de muestra con números muy diferentes en cada celda\nsd &lt;- c(1, 5, 15)\nn &lt;- 100\n\ndf &lt;- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\n\n\n\n\n\n\n\n\nAquí cada faceta tiene el mismo número de observaciones, pero la variabilidad es muy diferente. Sería bueno si pudiéramos solicitar que los anchos de intervalo varíen para obtener aproximadamente el mismo número de observaciones en cada intervalo. Una forma de hacerlo es con una fábrica de funciones que ingresa el número deseado de contenedores (n) y genera una función que toma un vector numérico y devuelve un ancho de contenedor:\n\nbinwidth_bins &lt;- function(n) {\n  force(n)\n  \n  function(x) {\n    (max(x) - min(x)) / n\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = binwidth_bins(20)) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\n\n\n\n\n\n\n\n\nPodríamos usar este mismo patrón para envolver las funciones base de R que automáticamente encuentran el llamado binwidth óptimo 3, nclass.Sturges(), nclass.scott() y nclass .FD():\n\nbase_bins &lt;- function(type) {\n  fun &lt;- switch(type,\n    Sturges = nclass.Sturges,\n    scott = nclass.scott,\n    FD = nclass.FD,\n    stop(\"Unknown type\", call. = FALSE)\n  )\n  \n  function(x) {\n    (max(x) - min(x)) / fun(x)\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = base_bins(\"FD\")) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\n\n\n\n\n\n\n\n\n\n\n10.3.3 ggsave()\n\nFinalmente, quiero mostrar una fábrica de funciones utilizada internamente por ggplot2. ggplot2:::plot_dev() es utilizado por ggsave() para pasar de una extensión de archivo (por ejemplo, png, jpeg, etc.) a una función de dispositivo gráfico (por ejemplo, png(), jpeg( )). El desafío aquí surge porque los dispositivos gráficos básicos tienen algunas inconsistencias menores que debemos corregir:\n\nLa mayoría tiene filename como primer argumento, pero algunos tienen file.\nEl width y height de los dispositivos gráficos de trama usan unidades de píxeles por defecto, pero los gráficos vectoriales usan pulgadas.\n\nA continuación se muestra una versión levemente simplificada de plot_dev():\n\nplot_dev &lt;- function(ext, dpi = 96) {\n  force(dpi)\n  \n  switch(ext,\n    eps =  ,\n    ps  =  function(path, ...) {\n      grDevices::postscript(\n        file = filename, ..., onefile = FALSE, \n        horizontal = FALSE, paper = \"special\"\n      )\n    },\n    pdf = function(filename, ...) grDevices::pdf(file = filename, ...),\n    svg = function(filename, ...) svglite::svglite(file = filename, ...),\n    emf = ,\n    wmf = function(...) grDevices::win.metafile(...),\n    png = function(...) grDevices::png(..., res = dpi, units = \"in\"),\n    jpg = ,\n    jpeg = function(...) grDevices::jpeg(..., res = dpi, units = \"in\"),\n    bmp = function(...) grDevices::bmp(..., res = dpi, units = \"in\"),\n    tiff = function(...) grDevices::tiff(..., res = dpi, units = \"in\"),\n    stop(\"Unknown graphics extension: \", ext, call. = FALSE)\n  )\n}\n\nplot_dev(\"pdf\")\n#&gt; function(filename, ...) grDevices::pdf(file = filename, ...)\n#&gt; &lt;bytecode: 0x56249e915518&gt;\n#&gt; &lt;environment: 0x56249e6a1990&gt;\nplot_dev(\"png\")\n#&gt; function(...) grDevices::png(..., res = dpi, units = \"in\")\n#&gt; &lt;bytecode: 0x56249ea79258&gt;\n#&gt; &lt;environment: 0x56249ec959d8&gt;\n\n\n\n10.3.4 Ejercicios\n\nComparar y contrastar ggplot2::label_bquote() con scales::number_format()",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fábricas de funciones</span>"
    ]
  },
  {
    "objectID": "Function-factories.html#sec-stat-fact",
    "href": "Function-factories.html#sec-stat-fact",
    "title": "10  Fábricas de funciones",
    "section": "10.4 Fábricas estadísticas",
    "text": "10.4 Fábricas estadísticas\nLos ejemplos más motivadores para las fábricas de funciones provienen de las estadísticas:\n\nLa transformación Box-Cox.\nRemuestreo Bootstrap.\nEstimación de máxima verosimilitud.\n\nTodos estos ejemplos se pueden abordar sin fábricas de funciones, pero creo que las fábricas de funciones son una buena opción para estos problemas y brindan soluciones elegantes. Estos ejemplos requieren algunos antecedentes estadísticos, así que siéntase libre de omitirlos si no tienen mucho sentido para usted.\n\n10.4.1 La transformación Box-Cox\n\nLa transformación de Box-Cox (un tipo de transformación de potencia) es una transformación flexible que a menudo se usa para transformar los datos hacia la normalidad. Tiene un solo parámetro, \\(\\lambda\\), que controla la fuerza de la transformación. Podríamos expresar la transformación como una función simple de dos argumentos:\n\nboxcox1 &lt;- function(x, lambda) {\n  stopifnot(length(lambda) == 1)\n  \n  if (lambda == 0) {\n    log(x)\n  } else {\n    (x ^ lambda - 1) / lambda\n  }\n}\n\nPero volver a formular como una fábrica de funciones facilita la exploración de su comportamiento con stat_function():\n\nboxcox2 &lt;- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}\n\nstat_boxcox &lt;- function(lambda) {\n  stat_function(aes(colour = lambda), fun = boxcox2(lambda), size = 1)\n}\n\nggplot(data.frame(x = c(0, 5)), aes(x)) + \n  lapply(c(0.5, 1, 1.5), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))\n#&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#&gt; ℹ Please use `linewidth` instead.\n\n# visualmente, log() parece tener sentido como la transformación\n# para lambda = 0; a medida que los valores se hacen cada vez más pequeños, la función\n# se acerca cada vez más a una transformación de registro\nggplot(data.frame(x = c(0.01, 1)), aes(x)) + \n  lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn general, esto le permite usar una transformación de Box-Cox con cualquier función que acepte una función de transformación unaria: no tiene que preocuparse de que esa función proporcione ... para pasar argumentos adicionales. También creo que la partición de lambda y x en dos argumentos de función diferentes es natural, ya que lambda juega un papel bastante diferente al de x.\n\n\n10.4.2 Generadores de arranque\n\nLas fábricas de funciones son un enfoque útil para el arranque. En lugar de pensar en un solo arranque (¡siempre necesita más de uno!), puede pensar en un generador de arranque, una función que produce un nuevo arranque cada vez que se llama:\n\nboot_permute &lt;- function(df, var) {\n  n &lt;- nrow(df)\n  force(var)\n  \n  function() {\n    col &lt;- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nboot_mtcars1 &lt;- boot_permute(mtcars, \"mpg\")\nhead(boot_mtcars1())\n#&gt; [1] 16.4 22.8 22.8 22.8 16.4 19.2\nhead(boot_mtcars1())\n#&gt; [1] 17.8 18.7 30.4 30.4 16.4 21.0\n\nLa ventaja de una fábrica de funciones es más clara con un bootstrap paramétrico donde primero tenemos que ajustar un modelo. Podemos hacer este paso de configuración una vez, cuando se llama a la fábrica, en lugar de una vez cada vez que generamos el arranque:\n\nboot_model &lt;- function(df, formula) {\n  mod &lt;- lm(formula, data = df)\n  fitted &lt;- unname(fitted(mod))\n  resid &lt;- unname(resid(mod))\n  rm(mod)\n\n  function() {\n    fitted + sample(resid)\n  }\n} \n\nboot_mtcars2 &lt;- boot_model(mtcars, mpg ~ wt)\nhead(boot_mtcars2())\n#&gt; [1] 25.0 24.0 21.7 19.2 24.9 16.0\nhead(boot_mtcars2())\n#&gt; [1] 27.4 21.0 20.3 19.4 16.3 21.3\n\nUso rm(mod) porque los objetos del modelo lineal son bastante grandes (incluyen copias completas de la matriz del modelo y los datos de entrada) y quiero mantener la función fabricada lo más pequeña posible.\n\n\n10.4.3 Estimación de máxima verosimilitud\n \nEl objetivo de la estimación de máxima verosimilitud (MLE) es encontrar los valores de los parámetros para una distribución que hacen que los datos observados sean más probables. Para hacer MLE, comienza con una función de probabilidad. Por ejemplo, tome la distribución de Poisson. Si conocemos \\(\\lambda\\), podemos calcular la probabilidad de obtener un vector \\(\\mathbf{x}\\) de valores (\\(x_1\\), \\(x_2\\), …, \\(x_n\\)) multiplicando la función de probabilidad de Poisson como sigue:\n\\(P(\\lambda, \\mathbf{x}) = \\prod_{i=1}^{n} \\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!}\\)\nEn estadística, casi siempre trabajamos con el registro de esta función. El logaritmo es una transformación monótona que conserva propiedades importantes (es decir, los extremos se encuentran en el mismo lugar), pero tiene ventajas específicas:\n\nEl registro convierte un producto en una suma, con lo que es más fácil trabajar.\nMultiplicar números pequeños produce números aún más pequeños, lo que hace que la aproximación de punto flotante utilizada por una computadora sea menos precisa.\n\nApliquemos una transformación logarítmica a esta función de probabilidad y simplifiquemos tanto como sea posible:\n\\(\\log(P(\\lambda, \\mathbf{x})) = \\sum_{i=1}^{n} \\log(\\frac{\\lambda^{x_i} e^{-\\lambda}}{x_i!})\\)\n\\(\\log(P(\\lambda, \\mathbf{x})) = \\sum_{i=1}^{n} \\left( x_i \\log(\\lambda) - \\lambda - \\log(x_i!) \\right)\\)\n\\(\\log(P(\\lambda, \\mathbf{x})) = \\sum*{i=1}^{n} x_i* \\log(\\lambda) - \\sum{i=1}^{n} \\lambda - \\sum_{i=1}^{n} \\log(x_i!)\\)\n\\(\\log(P(\\lambda, \\mathbf{x})) = \\log(\\lambda) \\sum*{i=1}^{n} x_i - n* \\lambda - \\sum{i=1}^{n} \\log(x_i!)\\)\nAhora podemos convertir esta función en una función R. La función R es bastante elegante porque R está vectorizado y, dado que es un lenguaje de programación estadístico, R viene con funciones integradas como log-factorial (lfactorial()).\n\nlprob_poisson &lt;- function(lambda, x) {\n  n &lt;- length(x)\n  (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x))\n}\n\nConsidere este vector de observaciones:\n\nx1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\n\nPodemos usar lprob_poisson() para calcular la probabilidad (registrada) de x1 para diferentes valores de lambda.\n\nlprob_poisson(10, x1)\n#&gt; [1] -184\nlprob_poisson(20, x1)\n#&gt; [1] -61.1\nlprob_poisson(30, x1)\n#&gt; [1] -31\n\nHasta ahora hemos estado pensando en lambda como fijo y conocido y la función nos dijo la probabilidad de obtener diferentes valores de x. Pero en la vida real, observamos ‘x’ y es ‘lambda’ lo que se desconoce. La verosimilitud es la función de probabilidad vista a través de este lente: queremos encontrar la lambda que hace que la x observada sea la más probable. Es decir, dada x, ¿qué valor de lambda nos da el valor más alto de lprob_poisson()?\nEn estadística, destacamos este cambio de perspectiva al escribir \\(f_{\\mathbf{x}}(\\lambda)\\) en lugar de \\(f(\\lambda, \\mathbf{x})\\). En R, podemos usar una fábrica de funciones. Proporcionamos x y generamos una función con un solo parámetro, lambda:\n\nll_poisson1 &lt;- function(x) {\n  n &lt;- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\n\n(No necesitamos force() porque length() fuerza implícitamente la evaluación de x.)\nUna cosa buena de este enfoque es que podemos hacer algunos cálculos previos: cualquier término que solo involucre x se puede calcular una vez en la fábrica. Esto es útil porque necesitaremos llamar a esta función muchas veces para encontrar la mejor lambda.\n\nll_poisson2 &lt;- function(x) {\n  n &lt;- length(x)\n  sum_x &lt;- sum(x)\n  c &lt;- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\n\nAhora podemos usar esta función para encontrar el valor de lambda que maximiza la probabilidad (log):\n\nll1 &lt;- ll_poisson2(x1)\n\nll1(10)\n#&gt; [1] -184\nll1(20)\n#&gt; [1] -61.1\nll1(30)\n#&gt; [1] -31\n\nEn lugar de prueba y error, podemos automatizar el proceso de encontrar el mejor valor con optimise(). Evaluará ll1() muchas veces, utilizando trucos matemáticos para reducir el valor más grande lo más rápido posible. Los resultados nos dicen que el valor más alto es -30.27 que ocurre cuando lambda = 32.1:\n\noptimise(ll1, c(0, 100), maximum = TRUE)\n#&gt; $maximum\n#&gt; [1] 32.1\n#&gt; \n#&gt; $objective\n#&gt; [1] -30.3\n\nAhora, podríamos haber resuelto este problema sin usar una fábrica de funciones porque optimise() pasa ... a la función que se está optimizando. Eso significa que podríamos usar la función de probabilidad de registro directamente:\n\noptimise(lprob_poisson, c(0, 100), x = x1, maximum = TRUE)\n#&gt; $maximum\n#&gt; [1] 32.1\n#&gt; \n#&gt; $objective\n#&gt; [1] -30.3\n\nLa ventaja de usar una fábrica de funciones aquí es bastante pequeña, pero hay dos sutilezas:\n\nPodemos precalcular algunos valores en fábrica, ahorrando tiempo de cálculo en cada iteración.\nEl diseño de dos niveles refleja mejor la estructura matemática del problema subyacente.\n\nEstas ventajas aumentan en problemas MLE más complejos, donde tiene múltiples parámetros y múltiples vectores de datos.\n\n\n\n10.4.4 Ejercicios\n\nEn boot_model(), ¿por qué no necesito forzar la evaluación de df o formula?\n¿Por qué podrías formular la transformación de Box-Cox de esta manera?\n\nboxcox3 &lt;- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}\n\n¿Por qué no debe preocuparse de que boot_permute() almacene una copia de los datos dentro de la función que genera?\n¿Cuánto tiempo ahorra ll_poisson2() en comparación con ll_poisson1()? Use bench::mark() para ver cuánto más rápido ocurre la optimización. ¿Cómo cambia la longitud de ‘x’ los resultados?",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fábricas de funciones</span>"
    ]
  },
  {
    "objectID": "Function-factories.html#sec-functional-factories",
    "href": "Function-factories.html#sec-functional-factories",
    "title": "10  Fábricas de funciones",
    "section": "10.5 Fábricas de funciones + funcionales",
    "text": "10.5 Fábricas de funciones + funcionales\nPara terminar el capítulo, mostraré cómo puede combinar funcionales y fábricas de funciones para convertir datos en muchas funciones. El siguiente código crea muchas funciones de potencia con nombres especiales al iterar sobre una lista de argumentos:\n\nnames &lt;- list(\n  square = 2, \n  cube = 3, \n  root = 1/2, \n  cuberoot = 1/3, \n  reciprocal = -1\n)\nfuns &lt;- purrr::map(names, power1)\n\nfuns$root(64)\n#&gt; [1] 8\nfuns$root\n#&gt; function(x) {\n#&gt;     x ^ exp\n#&gt;   }\n#&gt; &lt;bytecode: 0x56249a774ab8&gt;\n#&gt; &lt;environment: 0x56249ee08498&gt;\n\nEsta idea se extiende de manera directa si su fábrica de funciones toma dos (reemplace map() con map2()) o más (reemplace con pmap()) argumentos.\nUna desventaja de la construcción actual es que tienes que prefijar cada llamada de función con funs$. Hay tres formas de eliminar esta sintaxis adicional:\n\nPara un efecto muy temporal, puedes usar with():\n\nwith(funs, root(100))\n#&gt; [1] 10\n\nRecomiendo esto porque deja muy claro cuándo se ejecuta el código en un contexto especial y cuál es ese contexto.\nPara un efecto más prolongado, puede attach() las funciones a la ruta de búsqueda, luego detach() cuando haya terminado:\n\nattach(funs)\n#&gt; The following objects are masked _by_ .GlobalEnv:\n#&gt; \n#&gt;     cube, square\nroot(100)\n#&gt; [1] 10\ndetach(funs)\n\nProbablemente le hayan dicho que evite usar attach(), y ese es generalmente un buen consejo. Sin embargo, la situación es un poco diferente a lo habitual porque adjuntamos una lista de funciones, no un data frame. Es menos probable que modifique una función que una columna en un data frame, por lo que algunos de los peores problemas con attach() no se aplican.\nFinalmente, podrías copiar las funciones al entorno global con env_bind() (aprenderás sobre !!! en la Sección 19.6). Esto es en su mayoría permanente:\n\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#&gt; [1] 10\n\nMás tarde puede desvincular esos mismos nombres, pero no hay garantía de que no se hayan vuelto a vincular mientras tanto, y es posible que esté eliminando un objeto que otra persona creó.\n\nrlang::env_unbind(globalenv(), names(funs))\n\n\nAprenderá un enfoque alternativo para el mismo problema en la Sección 19.7.4. En lugar de usar una fábrica de funciones, puede construir la función con cuasicomillas. Esto requiere conocimientos adicionales, pero genera funciones con cuerpos legibles y evita la captura accidental de objetos grandes en el alcance adjunto. Usamos esa idea en la Sección 21.2.4 cuando trabajamos en herramientas para generar HTML desde R.\n\n10.5.1 Ejercicios\n\n¿Cuál de los siguientes comandos es equivalente a with(x, f(z))?\n\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\nIt depends.\n\nCompare y contraste los efectos de env_bind() frente a attach() para el siguiente código.\n\nfuns &lt;- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#&gt; The following objects are masked from package:base:\n#&gt; \n#&gt;     mean, sum\nmean &lt;- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean &lt;- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fábricas de funciones</span>"
    ]
  },
  {
    "objectID": "Function-factories.html#footnotes",
    "href": "Function-factories.html#footnotes",
    "title": "10  Fábricas de funciones",
    "section": "",
    "text": "Es probable que una versión futura de env_print() resuma mejor el contenido, por lo que no necesita este paso.↩︎\nEs un desafortunado accidente de la historia que las escalas usen sufijos de función en lugar de prefijos de función. Eso es porque fue escrito antes de que entendiera las ventajas de autocompletar al usar prefijos comunes en lugar de sufijos comunes.↩︎\nggplot2 no expone estas funciones directamente porque no creo que la definición de optimización necesaria para hacer que el problema sea matemáticamente tratable coincida con las necesidades reales de exploración de datos.↩︎",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fábricas de funciones</span>"
    ]
  },
  {
    "objectID": "Function-operators.html",
    "href": "Function-operators.html",
    "title": "11  Operadores de funciones",
    "section": "",
    "text": "11.1 Introducción\nEn este capítulo, aprenderá acerca de los operadores de funciones. Un operador de función es una función que toma una (o más) funciones como entrada y devuelve una función como salida. El siguiente código muestra un operador de función simple, chatty(). Envuelve una función, creando una nueva función que imprime su primer argumento. Puede crear una función como esta porque le da una ventana para ver cómo funcionan los funcionales, como map_int().\nchatty &lt;- function(f) {\n  force(f)\n  \n  function(x, ...) {\n    message(\"Processing \", x)\n    f(x, ...)\n  }\n}\nf &lt;- function(x) x ^ 2\ns &lt;- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n#&gt; Processing 3\n#&gt; Processing 2\n#&gt; Processing 1\n#&gt; [1] 9 4 1\nLos operadores de funciones están estrechamente relacionados con las fábricas de funciones; de hecho, son solo una fábrica de funciones que toma una función como entrada. Al igual que las fábricas, no hay nada que no puedas hacer sin ellas, pero a menudo te permiten eliminar la complejidad para que tu código sea más legible y reutilizable.\nLos operadores de función suelen estar emparejados con funcionales. Si está utilizando un bucle for, rara vez hay una razón para usar un operador de función, ya que hará que su código sea más complejo con poca ganancia.\nSi está familiarizado con Python, los decoradores son solo otro nombre para los operadores de funciones.",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Operadores de funciones</span>"
    ]
  },
  {
    "objectID": "Function-operators.html#introducción",
    "href": "Function-operators.html#introducción",
    "title": "11  Operadores de funciones",
    "section": "",
    "text": "Estructura\n\nLa Sección 11.2 le presenta dos operadores de funciones existentes extremadamente útiles y le muestra cómo usarlos para resolver problemas reales.\nLa Sección 11.3 funciona a través de un problema susceptible de solución con operadores de función: descargar muchas páginas web.\n\n\n\nRequisitos previos\nLos operadores de funciones son un tipo de fábrica de funciones, así que asegúrese de estar familiarizado al menos con la Sección 6.2 antes de continuar.\nUsaremos purrr para un par de funciones que aprendiste en el Capítulo 9, y algunos operadores de funciones que aprenderás a continuación. También usaremos el paquete memoise (Wickham et al. 2018) para el operador memoise().\n\nlibrary(purrr)\nlibrary(memoise)",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Operadores de funciones</span>"
    ]
  },
  {
    "objectID": "Function-operators.html#sec-existing-fos",
    "href": "Function-operators.html#sec-existing-fos",
    "title": "11  Operadores de funciones",
    "section": "11.2 Operadores de funciones existentes",
    "text": "11.2 Operadores de funciones existentes\nHay dos operadores de funciones muy útiles que lo ayudarán a resolver problemas recurrentes comunes y le darán una idea de lo que pueden hacer los operadores de funciones: purrr::safely() y memoise::memoise().\n\n11.2.1 Captura de errores con purrr::safely()\n\n\nUna ventaja de los bucles for es que si una de las iteraciones falla, aún puede acceder a todos los resultados hasta la falla:\n\nx &lt;- list(\n  c(0.512, 0.165, 0.717),\n  c(0.064, 0.781, 0.427),\n  c(0.890, 0.785, 0.495),\n  \"oops\"\n)\n\nout &lt;- rep(NA_real_, length(x))\nfor (i in seq_along(x)) {\n  out[[i]] &lt;- sum(x[[i]])\n}\n#&gt; Error in sum(x[[i]]): invalid 'type' (character) of argument\nout\n#&gt; [1] 1.39 1.27 2.17   NA\n\nSi hace lo mismo con un funcional, no obtiene ningún resultado, lo que dificulta descubrir dónde radica el problema:\n\nmap_dbl(x, sum)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 4.\n#&gt; Caused by error:\n#&gt; ! invalid 'type' (character) of argument\n\npurrr::safely() proporciona una herramienta para ayudar con este problema. safely() es un operador de función que transforma una función para convertir errores en datos. (Puede aprender la idea básica que hace que funcione en la Sección 8.6.2.) Comencemos echándole un vistazo fuera de map_dbl():\n\nsafe_sum &lt;- safely(sum)\nsafe_sum\n#&gt; function (...) \n#&gt; capture_error(.f(...), otherwise, quiet)\n#&gt; &lt;bytecode: 0x55c9eae30138&gt;\n#&gt; &lt;environment: 0x55c9eae2fca0&gt;\n\nComo todos los operadores de funciones, safely() toma una función y devuelve una función envuelta a la que podemos llamar como de costumbre:\n\nstr(safe_sum(x[[1]]))\n#&gt; List of 2\n#&gt;  $ result: num 1.39\n#&gt;  $ error : NULL\nstr(safe_sum(x[[4]]))\n#&gt; List of 2\n#&gt;  $ result: NULL\n#&gt;  $ error :List of 2\n#&gt;   ..$ message: chr \"invalid 'type' (character) of argument\"\n#&gt;   ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#&gt;   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nPuedes ver que una función transformada por safely() siempre devuelve una lista con dos elementos, result y error. Si la función se ejecuta correctamente, error es NULL y result contiene el resultado; si la función falla, result es NULL y error contiene el error.\nAhora usemos safely() con un funcional:\n\nout &lt;- map(x, safely(sum))\nstr(out)\n#&gt; List of 4\n#&gt;  $ :List of 2\n#&gt;   ..$ result: num 1.39\n#&gt;   ..$ error : NULL\n#&gt;  $ :List of 2\n#&gt;   ..$ result: num 1.27\n#&gt;   ..$ error : NULL\n#&gt;  $ :List of 2\n#&gt;   ..$ result: num 2.17\n#&gt;   ..$ error : NULL\n#&gt;  $ :List of 2\n#&gt;   ..$ result: NULL\n#&gt;   ..$ error :List of 2\n#&gt;   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#&gt;   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#&gt;   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nLa salida tiene una forma un poco inconveniente, ya que tenemos cuatro listas, cada una de las cuales es una lista que contiene el resultado y el error. Podemos hacer que la salida sea más fácil de usar girándola “al revés” con purrr::transpose(), de modo que obtengamos una lista de resultados y una lista de errores:\n\nout &lt;- transpose(map(x, safely(sum)))\nstr(out)\n#&gt; List of 2\n#&gt;  $ result:List of 4\n#&gt;   ..$ : num 1.39\n#&gt;   ..$ : num 1.27\n#&gt;   ..$ : num 2.17\n#&gt;   ..$ : NULL\n#&gt;  $ error :List of 4\n#&gt;   ..$ : NULL\n#&gt;   ..$ : NULL\n#&gt;   ..$ : NULL\n#&gt;   ..$ :List of 2\n#&gt;   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#&gt;   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#&gt;   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nAhora podemos encontrar fácilmente los resultados que funcionaron o las entradas que fallaron:\n\nok &lt;- map_lgl(out$error, is.null)\nok\n#&gt; [1]  TRUE  TRUE  TRUE FALSE\n\nx[!ok]\n#&gt; [[1]]\n#&gt; [1] \"oops\"\n\nout$result[ok]\n#&gt; [[1]]\n#&gt; [1] 1.39\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 1.27\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 2.17\n\nPuedes usar esta misma técnica en muchas situaciones diferentes. Por ejemplo, imagine que está ajustando un modelo lineal generalizado (GLM) a una lista de marcos de datos. Los GLM a veces pueden fallar debido a problemas de optimización, pero aún desea poder intentar ajustar todos los modelos y luego mirar hacia atrás a los que fallaron:\n\nfit_model &lt;- function(df) {\n  glm(y ~ x1 + x2 * x3, data = df)\n}\n\nmodels &lt;- transpose(map(datasets, safely(fit_model)))\nok &lt;- map_lgl(models$error, is.null)\n\n# ¿Qué datos no lograron converger?\ndatasets[!ok]\n\n# ¿Qué modelos tuvieron éxito?\nmodels[ok]\n\nCreo que este es un gran ejemplo del poder de combinar funcionales y operadores de funciones: safely() te permite expresar de manera sucinta lo que necesitas para resolver un problema común de análisis de datos.\npurrr viene con otros tres operadores de función en una línea similar:\n\npossibly(): devuelve un valor predeterminado cuando hay un error. No proporciona ninguna forma de saber si ocurrió un error o no, por lo que es mejor reservarlo para los casos en los que hay algún valor centinela obvio (como NA).\nquietly(): convierte la salida, los mensajes y los efectos secundarios de advertencia en componentes de salida, mensaje y advertencia de la salida.\nauto_browse(): ejecuta automáticamente browser() dentro de la función cuando hay un error.\n\nConsulte su documentación para obtener más detalles.\n\n\n11.2.2 Almacenamiento en caché de cálculos con memoise::memoise()\n \nOtro operador de función útil es memoise::memoise(). Memoriza una función, lo que significa que la función recordará las entradas anteriores y devolverá los resultados almacenados en caché. La memorización es un ejemplo de la compensación clásica de las ciencias de la computación entre memoria y velocidad. Una función memorizada puede ejecutarse mucho más rápido, pero debido a que almacena todas las entradas y salidas anteriores, utiliza más memoria.\nExploremos esta idea con una función de juguete que simula una operación costosa:\n\nslow_function &lt;- function(x) {\n  Sys.sleep(1)\n  x * 10 * runif(1)\n}\nsystem.time(print(slow_function(1)))\n#&gt; [1] 0.808\n#&gt;    user  system elapsed \n#&gt;       0       0       1\n\nsystem.time(print(slow_function(1)))\n#&gt; [1] 8.34\n#&gt;    user  system elapsed \n#&gt;   0.001   0.000   1.003\n\nCuando memorizamos esta función, es lenta cuando la llamamos con nuevos argumentos. Pero cuando lo llamamos con argumentos de que se ve antes, es instantáneo: recupera el valor anterior del cómputo.\n\nfast_function &lt;- memoise::memoise(slow_function)\nsystem.time(print(fast_function(1)))\n#&gt; [1] 6.01\n#&gt;    user  system elapsed \n#&gt;       0       0       1\n\nsystem.time(print(fast_function(1)))\n#&gt; [1] 6.01\n#&gt;    user  system elapsed \n#&gt;   0.013   0.000   0.013\n\nUn uso relativamente realista de la memorización es calcular la serie de Fibonacci. La serie de Fibonacci se define recursivamente: los dos primeros valores se definen por convención, \\(f(0) = 0\\), \\(f(1) = 1\\), y luego \\(f(n) = f(n - 1) + f (n - 2)\\) (para cualquier entero positivo). Una versión ingenua es lenta porque, por ejemplo, fib(10) calcula fib(9) y fib(8), y fib(9) calcula fib(8) y fib(7) ), y así sucesivamente.\n\nfib &lt;- function(n) {\n  if (n &lt; 2) return(n)\n  fib(n - 2) + fib(n - 1)\n}\nsystem.time(fib(23))\n#&gt;    user  system elapsed \n#&gt;   0.029   0.000   0.029\nsystem.time(fib(24))\n#&gt;    user  system elapsed \n#&gt;   0.042   0.004   0.046\n\nMemoizar fib() hace que la implementación sea mucho más rápida porque cada valor se calcula solo una vez:\n\nfib2 &lt;- memoise::memoise(function(n) {\n  if (n &lt; 2) return(n)\n  fib2(n - 2) + fib2(n - 1)\n})\nsystem.time(fib2(23))\n#&gt;    user  system elapsed \n#&gt;   0.006   0.000   0.006\n\nY las llamadas futuras pueden basarse en cálculos anteriores:\n\nsystem.time(fib2(24))\n#&gt;    user  system elapsed \n#&gt;   0.001   0.000   0.001\n\nEste es un ejemplo de programación dinámica, donde un problema complejo se puede dividir en muchos subproblemas superpuestos, y recordar los resultados de un subproblema mejora considerablemente el rendimiento.\nPiense cuidadosamente antes de memorizar una función. Si la función no es pura, es decir, la salida no depende solo de la entrada, obtendrá resultados engañosos y confusos. Creé un error sutil en las herramientas de desarrollo porque memoricé los resultados de available.pachages(), que es bastante lento porque tiene que descargar un archivo grande de CRAN. Los paquetes disponibles no cambian con tanta frecuencia, pero si tiene un proceso R que se ha estado ejecutando durante algunos días, los cambios pueden volverse importantes y, dado que el problema solo surgió en los procesos R de ejecución prolongada, el error fue muy doloroso para encontrar.\n\n\n11.2.3 Ejercicios\n\nBase R proporciona un operador de función en forma de Vectorize(). ¿Qué hace? ¿Cuándo podría usarlo?\nLee el código fuente de posiblemente(). ¿Como funciona?\nLee el código fuente de safely(). ¿Como funciona?",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Operadores de funciones</span>"
    ]
  },
  {
    "objectID": "Function-operators.html#sec-fo-case-study",
    "href": "Function-operators.html#sec-fo-case-study",
    "title": "11  Operadores de funciones",
    "section": "11.3 Estudio de caso: Creación de sus propios operadores de función",
    "text": "11.3 Estudio de caso: Creación de sus propios operadores de función\n\nmemoise() y safely() son muy útiles pero también bastante complejos. En este caso de estudio, aprenderá cómo crear sus propios operadores de función más simples. Imagine que tiene un vector con nombre de URL y desea descargar cada uno en el disco. Eso es bastante simple con walk2() y file.download():\n\nurls &lt;- c(\n  \"adv-r\" = \"https://adv-r.hadley.nz\", \n  \"r4ds\" = \"http://r4ds.had.co.nz/\"\n  # y muchos más\n)\npath &lt;- paste0(tempdir(), names(urls), \".html\")\n\nwalk2(urls, path, download.file, quiet = TRUE)\n\nEste enfoque está bien para un puñado de URL, pero a medida que el vector se alarga, es posible que desee agregar un par de funciones más:\n\nAgregue un pequeño retraso entre cada solicitud para evitar martillar el servidor.\nMostrar un . cada pocas URL para que sepamos que la función sigue funcionando.\n\nEs relativamente fácil agregar estas funciones adicionales si usamos un bucle for:\n\nfor(i in seq_along(urls)) {\n  Sys.sleep(0.1)\n  if (i %% 10 == 0) cat(\".\")\n  download.file(urls[[i]], paths[[i]])\n}\n\nCreo que este ciclo for es subóptimo porque intercala diferentes preocupaciones: pausar, mostrar el progreso y descargar. Esto hace que el código sea más difícil de leer y dificulta la reutilización de los componentes en situaciones nuevas. En cambio, veamos si podemos usar operadores de función para extraer la pausa y mostrar el progreso y hacerlos reutilizables.\nPrimero, escribamos un operador de función que agregue un pequeño retraso. Voy a llamarlo delay_by() por razones que serán más claras en breve, y tiene dos argumentos: la función para envolver y la cantidad de retraso para agregar. La implementación real es bastante simple. El truco principal es forzar la evaluación de todos los argumentos como se describe en la Sección 10.2.5, porque los operadores de función son un tipo especial de fábrica de funciones:\n\ndelay_by &lt;- function(f, amount) {\n  force(f)\n  force(amount)\n  \n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\nsystem.time(runif(100))\n#&gt;    user  system elapsed \n#&gt;       0       0       0\nsystem.time(delay_by(runif, 0.1)(100))\n#&gt;    user  system elapsed \n#&gt;     0.0     0.0     0.1\n\nY podemos usarlo con el walk2() original:\n\nwalk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)\n\nCrear una función para mostrar el punto ocasional es un poco más difícil, porque ya no podemos confiar en el índice del bucle. Podríamos pasar el índice como otro argumento, pero eso rompe la encapsulación: una preocupación de la función de progreso ahora se convierte en un problema que el contenedor de nivel superior debe manejar. En su lugar, usaremos otro truco de fábrica de funciones (de la Sección 10.2.4), para que el contenedor de progreso pueda administrar su propio contador interno:\n\ndot_every &lt;- function(f, n) {\n  force(f)\n  force(n)\n  \n  i &lt;- 0\n  function(...) {\n    i &lt;&lt;- i + 1\n    if (i %% n == 0) cat(\".\")\n    f(...)\n  }\n}\nwalk(1:100, runif)\nwalk(1:100, dot_every(runif, 10))\n#&gt; ..........\n\nAhora podemos expresar nuestro bucle for original como:\n\nwalk2(\n  urls, path, \n  dot_every(delay_by(download.file, 0.1), 10), \n  quiet = TRUE\n)\n\nEsto está empezando a ser un poco difícil de leer porque estamos componiendo muchas llamadas a funciones y los argumentos se están dispersando. Una forma de resolver eso es usar la tubería:\n\nwalk2(\n  urls, path, \n  download.file |&gt; dot_every(10) |&gt; delay_by(0.1), \n  quiet = TRUE\n)\n\nLa canalización funciona bien aquí porque elegí cuidadosamente los nombres de las funciones para generar una oración (casi) legible: tome download.file luego (agregue) un punto cada 10 iteraciones, luego retrase 0.1s. Cuanto más claramente pueda expresar la intención de su código a través de nombres de funciones, más fácilmente otros (¡incluido usted en el futuro!) podrán leer y comprender el código.\n\n11.3.1 Ejercicios\n\nSopesar los pros y los contras de download.file |&gt; dot_every(10) |&gt; delay_by(0.1) versus download.file |&gt; delay_by(0.1) |&gt; dot_every(10).\n¿Deberías memorizar download.file()? ¿Por qué o por qué no?\nCree un operador de función que informe cada vez que se crea o elimina un archivo en el directorio de trabajo, usando dir() y setdiff(). ¿Qué otros efectos de funciones globales le gustaría rastrear?\nEscriba un operador de función que registre una marca de tiempo y un mensaje en un archivo cada vez que se ejecute una función.\nModifique delay_by() para que, en lugar de retrasar una cantidad de tiempo fija, asegure que haya transcurrido una cierta cantidad de tiempo desde la última vez que se llamó a la función. Es decir, si llamó a g &lt;- delay_by(1, f); g(); Sys.sleep(2); g() no debería haber un retraso adicional.\n\n\n\n\n\nWickham, Hadley, Jim Hester, Kirill Müller, y Daniel Cook. 2018. memoise: Memoisation of Functions. https://github.com/r-lib/memoise.",
    "crumbs": [
      "Programación funcional",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Operadores de funciones</span>"
    ]
  },
  {
    "objectID": "OO.html",
    "href": "OO.html",
    "title": "Introdución",
    "section": "",
    "text": "Sistemas de POO\nDiferentes personas usan los términos de programación orientada a objetos de diferentes maneras, por lo que esta sección proporciona una descripción general rápida del vocabulario importante. Las explicaciones están necesariamente comprimidas, pero volveremos a estas ideas varias veces.\nLa razón principal para usar POO es polimorfismo (literalmente: muchas formas). El polimorfismo significa que un desarrollador puede considerar la interfaz de una función por separado de su implementación, lo que hace posible usar la misma forma de función para diferentes tipos de entrada. Esto está estrechamente relacionado con la idea de encapsulación: el usuario no necesita preocuparse por los detalles de un objeto porque están encapsulados detrás de una interfaz estándar.\nPara ser concretos, el polimorfismo es lo que permite que summary() produzca diferentes salidas para variables numéricas y factoriales:\ndiamonds &lt;- ggplot2::diamonds\n\nsummary(diamonds$carat)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;    0.20    0.40    0.70    0.80    1.04    5.01\n\nsummary(diamonds$cut)\n#&gt;      Fair      Good Very Good   Premium     Ideal \n#&gt;      1610      4906     12082     13791     21551\nPodrías imaginar summary() que contiene una serie de declaraciones if-else, pero eso significaría que solo el autor original podría agregar nuevas implementaciones. Un sistema OOP hace posible que cualquier desarrollador amplíe la interfaz con implementaciones para nuevos tipos de entrada.\nPara ser más precisos, los sistemas OO llaman al tipo de un objeto su clase, y una implementación para una clase específica se llama método. En términos generales, una clase define lo que un objeto es y los métodos describen lo que ese objeto puede hacer. La clase define los campos, los datos que posee cada instancia de esa clase. Las clases están organizadas en una jerarquía de modo que si no existe un método para una clase, se usa el método de su padre y se dice que el hijo hereda el comportamiento. Por ejemplo, en R, un factor ordenado hereda de un factor regular y un modelo lineal generalizado hereda de un modelo lineal. El proceso de encontrar el método correcto dada una clase se llama despacho de métodos.\nHay dos paradigmas principales de programación orientada a objetos que difieren en cómo se relacionan los métodos y las clases. En este libro, tomaremos prestada la terminología de Extending R (Chambers 2016) y llamaremos a estos paradigmas encapsulados y funcionales:\nCon esta terminología en la mano, ahora podemos hablar precisamente de los diferentes sistemas OO disponibles en R.",
    "crumbs": [
      "Programación orientada a objetos",
      "Introdución"
    ]
  },
  {
    "objectID": "OO.html#sistemas-de-poo",
    "href": "OO.html#sistemas-de-poo",
    "title": "Introdución",
    "section": "",
    "text": "En la programación orientada a objetos encapsulada, los métodos pertenecen a objetos o clases, y las llamadas a métodos normalmente se ven como object.method(arg1, arg2). Esto se denomina encapsulado porque el objeto encapsula tanto los datos (con campos) como el comportamiento (con métodos), y es el paradigma que se encuentra en los lenguajes más populares.\nEn la programación orientada a objetos funcional, los métodos pertenecen a funciones genéricas y las llamadas a métodos se parecen a las llamadas a funciones ordinarias: generic(object, arg2, arg3). Esto se llama funcional porque desde el exterior parece una llamada de función regular, e internamente los componentes también son funciones.",
    "crumbs": [
      "Programación orientada a objetos",
      "Introdución"
    ]
  },
  {
    "objectID": "OO.html#poo-en-r",
    "href": "OO.html#poo-en-r",
    "title": "Introdución",
    "section": "POO en R",
    "text": "POO en R\nBase R proporciona tres sistemas OOP: S3, S4 y clases de referencia (RC):\n\nS3 es el primer sistema de POO de R y se describe en Modelos estadísticos en S (Chambers y Hastie 1992). S3 es una implementación informal de POO funcional y se basa en convenciones comunes en lugar de garantías inquebrantables. Esto hace que sea fácil comenzar, proporcionando una forma económica de resolver muchos problemas simples.\nS4 es una reescritura formal y rigurosa de S3 y se introdujo en Programación con datos (Chambers 1998). Requiere más trabajo inicial que S3, pero a cambio ofrece más garantías y una mayor encapsulación. S4 se implementa en el paquete base de métodos, que siempre se instala con R.\n(Quizás se pregunte si existen S1 y S2. No lo hacen: S3 y S4 fueron nombrados de acuerdo con las versiones de S que acompañaban. Las dos primeras versiones de S no tenían ningún marco de POO.)\nRC implementa OO encapsulado. Los objetos RC son un tipo especial de objetos S4 que también son mutables, es decir, en lugar de usar la semántica habitual de copiar al modificar de R, se pueden modificar en su lugar. Esto los hace más difíciles de razonar, pero les permite resolver problemas que son difíciles de resolver en el estilo OOP funcional de S3 y S4.\n\nLos paquetes CRAN proporcionan otros sistemas de POO:\n\nR6 (Chang 2017) implementa OOP encapsulado como RC, pero resuelve algunos problemas importantes. En este libro, aprenderá sobre R6 en lugar de RC, por las razones descritas en la 14.5 ¿Por qué R6?.\nR.oo (Bengtsson 2003) proporciona algo de formalismo además de S3 y hace posible tener objetos mutables de S3.\nproto (Grothendieck, Kates, y Petzoldt 2016) implementa otro estilo de programación orientada a objetos basado en la idea de prototipos, que desdibujan las distinciones entre clases e instancias de clases (objetos). Me enamoré brevemente de la programación basada en prototipos (Wickham 2011) y la usé en ggplot2, pero ahora creo que es mejor seguir con los formularios estándar.\n\nAparte del R6, que es ampliamente utilizado, estos sistemas son principalmente de interés teórico. Tienen sus puntos fuertes, pero pocos usuarios de R los conocen y los entienden, por lo que es difícil que otros los lean y contribuyan a su código.",
    "crumbs": [
      "Programación orientada a objetos",
      "Introdución"
    ]
  },
  {
    "objectID": "OO.html#sloop",
    "href": "OO.html#sloop",
    "title": "Introdución",
    "section": "sloop",
    "text": "sloop\nAntes de continuar, quiero presentar el paquete sloop:\n\nlibrary(sloop)\n\nEl paquete sloop (piense en “navegar los mares de OOP”) proporciona una serie de ayudantes que completan las piezas que faltan en la base R. El primero de ellos es sloop::otype(). Hace que sea fácil descifrar el sistema OOP utilizado por un objeto capturado de forma salvaje:\n\notype(1:10)\n#&gt; [1] \"base\"\n\notype(mtcars)\n#&gt; [1] \"S3\"\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2) ^ 2)\notype(mle_obj)\n#&gt; [1] \"S4\"\n\nUtilice esta función para averiguar qué capítulo leer para entender cómo trabajar con un objeto existente.\n\n\n\n\nBengtsson, Henrik. 2003. «The R.oo package - Object-Oriented Programming with References Using Standard R Code». En Proceedings of the 3rd International Workshop on Distributed Statistical Computing (DSC 2003), editado por Kurt Hornik, Friedrich Leisch, y Achim Zeileis. Vienna, Austria: https://www.r-project.org/conferences/DSC-2003/Proceedings/. https://www.r-project.org/conferences/DSC-2003/Proceedings/Bengtsson.pdf.\n\n\nChambers, John M. 1998. Programming with Data: A Guide to the S Language. Springer.\n\n\n———. 2016. Extending R. CRC Press.\n\n\nChambers, John M, y Trevor J Hastie. 1992. Statistical Models in S. Wadsworth & Brooks/Cole Advanced Books & Software.\n\n\nChang, Winston. 2017. R6: Classes with reference semantics. https://r6.r-lib.org.\n\n\nGrothendieck, Gabor, Louis Kates, y Thomas Petzoldt. 2016. proto: prototype object-based programming. https://CRAN.R-project.org/package=proto.\n\n\nWickham, Hadley. 2011. «mutatr: mutable objects for R». Computational Statistics 26 (3): 405--418. https://doi.org/10.1007/s00180-011-0235-7.",
    "crumbs": [
      "Programación orientada a objetos",
      "Introdución"
    ]
  },
  {
    "objectID": "OO.html#footnotes",
    "href": "OO.html#footnotes",
    "title": "Introdución",
    "section": "",
    "text": "La excepción es Julia, que también usa la función genérica de POO. En comparación con R, la implementación de Julia está completamente desarrollada y tiene un rendimiento extremo.↩︎",
    "crumbs": [
      "Programación orientada a objetos",
      "Introdución"
    ]
  },
  {
    "objectID": "base-types.html",
    "href": "base-types.html",
    "title": "12  Tipos básicos",
    "section": "",
    "text": "12.1 Introducción\nPara hablar de objetos y programación orientada a objetos en R, primero debemos aclarar una confusión fundamental sobre dos usos de la palabra “objeto”. Hasta ahora en este libro, hemos usado la palabra en el sentido general captado por la concisa cita de John Chambers: “Todo lo que existe en R es un objeto”. Sin embargo, aunque todo es un objeto, no todo está orientado a objetos. Esta confusión surge porque los objetos base provienen de S y se desarrollaron antes de que nadie pensara que S podría necesitar un sistema OOP. Las herramientas y la nomenclatura evolucionaron orgánicamente durante muchos años sin un solo principio rector.\nLa mayoría de las veces, la distinción entre objetos y objetos orientados a objetos no es importante. Pero aquí tenemos que entrar en detalles esenciales, así que usaremos los términos objetos base y objetos OO para distinguirlos.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Tipos básicos</span>"
    ]
  },
  {
    "objectID": "base-types.html#introducción",
    "href": "base-types.html#introducción",
    "title": "12  Tipos básicos",
    "section": "",
    "text": "Estructura\n\nLa Sección 12.2 le muestra cómo identificar objetos base y OO.\nLa Sección 12.3 proporciona un conjunto completo de los tipos base utilizados para construir todos los objetos.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Tipos básicos</span>"
    ]
  },
  {
    "objectID": "base-types.html#sec-base-vs-oo",
    "href": "base-types.html#sec-base-vs-oo",
    "title": "12  Tipos básicos",
    "section": "12.2 Base versus objetos OO",
    "text": "12.2 Base versus objetos OO\n \nPara saber la diferencia entre un objeto base y OO, usa is.object() o sloop::otype():\n\n# Un objeto básico:\nis.object(1:10)\n#&gt; [1] FALSE\nsloop::otype(1:10)\n#&gt; [1] \"base\"\n\n# Un objeto OO\nis.object(mtcars)\n#&gt; [1] TRUE\nsloop::otype(mtcars)\n#&gt; [1] \"S3\"\n\nTécnicamente, la diferencia entre los objetos base y OO es que los objetos OO tienen un atributo de “clase”:\n\nattr(1:10, \"class\")\n#&gt; NULL\n\nattr(mtcars, \"class\")\n#&gt; [1] \"data.frame\"\n\nPuede que ya estés familiarizado con la función class(). Es seguro aplicar esta función a objetos S3 y S4, pero devuelve resultados engañosos cuando se aplica a objetos base. Es más seguro usar sloop::s3_class(), que devuelve la clase implícita que los sistemas S3 y S4 usarán para seleccionar métodos. Aprenderá más sobre s3_class() en la Sección 13.7.1.\n\nx &lt;- matrix(1:4, nrow = 2)\nclass(x)\n#&gt; [1] \"matrix\" \"array\"\nsloop::s3_class(x)\n#&gt; [1] \"matrix\"  \"integer\" \"numeric\"",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Tipos básicos</span>"
    ]
  },
  {
    "objectID": "base-types.html#sec-base-types-2",
    "href": "base-types.html#sec-base-types-2",
    "title": "12  Tipos básicos",
    "section": "12.3 Tipos básicos",
    "text": "12.3 Tipos básicos\n\n\nMientras que solo los objetos OO tienen un atributo de clase, cada objeto tiene un tipo base:\n\ntypeof(1:10)\n#&gt; [1] \"integer\"\n\ntypeof(mtcars)\n#&gt; [1] \"list\"\n\nLos tipos base no forman un sistema OOP porque las funciones que se comportan de manera diferente para diferentes tipos base se escriben principalmente en código C que usa instrucciones de cambio. Esto significa que solo R-core puede crear nuevos tipos, y crear un nuevo tipo es mucho trabajo porque cada declaración de cambio debe modificarse para manejar un nuevo caso. Como consecuencia, rara vez se agregan nuevos tipos base. El cambio más reciente, en 2011, agregó dos tipos exóticos que nunca se ven en R, pero que son necesarios para diagnosticar problemas de memoria. Antes de eso, el último tipo agregado fue un tipo base especial para objetos S4 agregado en 2005.\n\nEn total, hay 25 tipos de base diferentes. Se enumeran a continuación, agrupados libremente según el lugar en el que se analicen en este libro. Estos tipos son los más importantes en el código C, por lo que a menudo los verá llamados por sus nombres de tipo C. Los he incluido entre paréntesis.\n\nVectores, Capítulo 3, incluye tipos NULL (NILSXP), logical (LGLSXP), integer (INTSXP), double (REALSXP), complex (CPLXSXP), character (STRSXP), list (VECSXP), y raw (RAWSXP).\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\ntypeof(1L)\n#&gt; [1] \"integer\"\ntypeof(1i)\n#&gt; [1] \"complex\"\n\nLas funciones, Capítulo 6, incluyen los tipos cierre (funciones regulares de R, CLOSXP), especiales (funciones internas, SPECIALSXP) e incorporadas (funciones primitivas, BUILTINSXP).\n\ntypeof(mean)\n#&gt; [1] \"closure\"\ntypeof(`[`)\n#&gt; [1] \"special\"\ntypeof(sum)    \n#&gt; [1] \"builtin\"\n\nLas funciones internas y primitivas se describen en la Sección 6.2.2.\nEntornos, Capítulo 7, tienen tipo entorno (ENVSXP).\n\ntypeof(globalenv())\n#&gt; [1] \"environment\"\n\nEl tipo S4 (S4SXP), Capítulo 15, se usa para las clases de S4 que no heredan de un tipo base existente.\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2) ^ 2)\ntypeof(mle_obj)\n#&gt; [1] \"S4\"\n\nLos componentes del lenguaje, Capítulo 18), incluyen símbolo (también conocido como nombre, SYMSXP), idioma (generalmente llamadas llamadas, LANGSXP) y pairlist (usado para argumentos de función, LISTSXP ) tipos.\n\ntypeof(quote(a))\n#&gt; [1] \"symbol\"\ntypeof(quote(a + 1))\n#&gt; [1] \"language\"\ntypeof(formals(mean))\n#&gt; [1] \"pairlist\"\n\nexpression (EXPRSXP) es un tipo de propósito especial que solo es devuelto por parse() y expression(). Las expresiones generalmente no son necesarias en el código de usuario.\nLos tipos restantes son esotéricos y rara vez se ven en R. Son importantes principalmente para el código C: externalptr (EXTPTRSXP), weakref (WEAKREFSXP), bytecode (BCODESXP), promise (PROMSXP), ... (DOTSXP), y any (ANYSXP).\n\n\nEs posible que hayas oído hablar de mode() y storage.mode(). No utilice estas funciones: solo existen para proporcionar nombres de tipo que sean compatibles con S.\n\n12.3.1 Tipo numérico\n \nTenga cuidado al hablar del tipo numérico, porque R usa “numérico” para referirse a tres cosas ligeramente diferentes:\n\nEn algunos lugares, numérico se usa como un alias para el tipo doble. Por ejemplo, as.numeric() es idéntico a as.double(), y numeric() es idéntico a double().\n(R también usa ocasionalmente real en lugar de doble; NA_real_ es el único lugar donde es probable que encuentres esto en la práctica.)\nEn los sistemas S3 y S4, numérico se usa como una forma abreviada de tipo entero o doble, y se usa cuando se seleccionan métodos:\n\nsloop::s3_class(1)\n#&gt; [1] \"double\"  \"numeric\"\nsloop::s3_class(1L)\n#&gt; [1] \"integer\" \"numeric\"\n\nis.numeric() pruebas para objetos que se comportan como números. Por ejemplo, los factores tienen el tipo “entero” pero no se comportan como números (es decir, no tiene sentido tomar la media del factor).\n\ntypeof(factor(\"x\"))\n#&gt; [1] \"integer\"\nis.numeric(factor(\"x\"))\n#&gt; [1] FALSE\n\n\nEn este libro, siempre uso numérico para indicar un objeto de tipo entero o doble.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Tipos básicos</span>"
    ]
  },
  {
    "objectID": "S3.html",
    "href": "S3.html",
    "title": "13  S3",
    "section": "",
    "text": "13.1 Introducción\nS3 es el primer y más simple sistema OO de R. S3 es informal y ad hoc, pero hay cierta elegancia en su minimalismo: no se le puede quitar ninguna parte y seguir teniendo un sistema OO útil. Por estas razones, debe usarlo, a menos que tenga una razón convincente para hacerlo de otra manera. S3 es el único sistema OO utilizado en los paquetes base y stats, y es el sistema más utilizado en los paquetes CRAN.\nS3 es muy flexible, lo que significa que te permite hacer cosas que son bastante desaconsejables. Si viene de un entorno estricto como Java, esto parecerá bastante aterrador, pero le da a los programadores de R una gran libertad. Puede ser muy difícil evitar que las personas hagan algo que usted no quiere que hagan, pero sus usuarios nunca se detendrán porque hay algo que aún no ha implementado. Dado que S3 tiene pocas restricciones integradas, la clave para su uso exitoso es aplicar las restricciones usted mismo. Por lo tanto, este capítulo le enseñará las convenciones que debe seguir (casi) siempre.\nEl objetivo de este capítulo es mostrarle cómo funciona el sistema S3, no cómo usarlo de manera efectiva para crear nuevas clases y genéricos. Recomiendo combinar el conocimiento teórico de este capítulo con el conocimiento práctico codificado en el paquete vctrs.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#introducción",
    "href": "S3.html#introducción",
    "title": "13  S3",
    "section": "",
    "text": "Estructura\n\nLa Sección 13.2 brinda una descripción general rápida de todos los componentes principales de S3: clases, genéricos y métodos. También aprenderá sobre sloop::s3_dispatch(), que usaremos a lo largo del capítulo para explorar cómo funciona S3.\nLa Sección 13.3 entra en los detalles de la creación de una nueva clase S3, incluidas las tres funciones que deberían acompañar a la mayoría de las clases: un constructor, un ayudante y un validador.\nLa Sección 13.4 describe cómo funcionan los métodos y genéricos de S3, incluidos los aspectos básicos del envío de métodos.\nLa Sección 13.5 analiza los cuatro estilos principales de los objetos de S3: vector, registro, marco de datos y escalar.\nLa Sección 13.6 demuestra cómo funciona la herencia en S3 y le muestra lo que necesita para hacer que una clase sea “subclasificable”.\nLa Sección 13.7 concluye el capítulo con una discusión de los detalles más finos del envío de métodos, incluidos los tipos base, los genéricos internos, los genéricos de grupo y el envío doble.\n\n\n\nRequisitos previos\nLas clases de S3 se implementan mediante atributos, así que asegúrese de estar familiarizado con los detalles descritos en la Sección 3.3. Usaremos vectores S3 base existentes para ejemplos y exploración, así que asegúrese de estar familiarizado con las clases factor, Date, difftime, POSIXct y POSIXlt descritas en la Sección 3.4.\nUsaremos el paquete sloop para sus ayudantes interactivos.\n\nlibrary(sloop)",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#sec-s3-basics",
    "href": "S3.html#sec-s3-basics",
    "title": "13  S3",
    "section": "13.2 Lo esencial",
    "text": "13.2 Lo esencial\n \nUn objeto S3 es un tipo base con al menos un atributo de “clase” (se pueden usar otros atributos para almacenar otros datos). Por ejemplo, tome el factor. Su tipo base es el vector entero, tiene un atributo clase de “factor”, y un atributo niveles que almacena los niveles posibles:\n\nf &lt;- factor(c(\"a\", \"b\", \"c\"))\n\ntypeof(f)\n#&gt; [1] \"integer\"\nattributes(f)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\nPuede obtener el tipo base subyacente al unclass(), lo que elimina el atributo de clase, lo que hace que pierda su comportamiento especial:\n\nunclass(f)\n#&gt; [1] 1 2 3\n#&gt; attr(,\"levels\")\n#&gt; [1] \"a\" \"b\" \"c\"\n\n \nUn objeto de S3 se comporta de manera diferente a su tipo base subyacente cada vez que se pasa a un genérico (abreviatura de función genérica). La forma más fácil de saber si una función es genérica es usar sloop::ftype() y buscar “genérica” en la salida:\n\nftype(print)\n#&gt; [1] \"S3\"      \"generic\"\nftype(str)\n#&gt; [1] \"S3\"      \"generic\"\nftype(unclass)\n#&gt; [1] \"primitive\"\n\nUna función genérica define una interfaz, que utiliza una implementación diferente según la clase de un argumento (casi siempre el primer argumento). Muchas funciones básicas de R son genéricas, incluida la importante print():\n\nprint(f)\n#&gt; [1] a b c\n#&gt; Levels: a b c\n\n# la eliminación de clase vuelve al comportamiento de entero\nprint(unclass(f))\n#&gt; [1] 1 2 3\n#&gt; attr(,\"levels\")\n#&gt; [1] \"a\" \"b\" \"c\"\n\nTenga en cuenta que str() es genérico, y algunas clases de S3 usan ese genérico para ocultar los detalles internos. Por ejemplo, la clase POSIXlt que se usa para representar datos de fecha y hora en realidad está construida encima de una lista, un hecho que está oculto por su método str():\n\ntime &lt;- strptime(c(\"2017-01-01\", \"2020-05-04 03:21\"), \"%Y-%m-%d\")\nstr(time)\n#&gt;  POSIXlt[1:2], format: \"2017-01-01\" \"2020-05-04\"\n\nstr(unclass(time))\n#&gt; List of 11\n#&gt;  $ sec   : num [1:2] 0 0\n#&gt;  $ min   : int [1:2] 0 0\n#&gt;  $ hour  : int [1:2] 0 0\n#&gt;  $ mday  : int [1:2] 1 4\n#&gt;  $ mon   : int [1:2] 0 4\n#&gt;  $ year  : int [1:2] 117 120\n#&gt;  $ wday  : int [1:2] 0 1\n#&gt;  $ yday  : int [1:2] 0 124\n#&gt;  $ isdst : int [1:2] 0 0\n#&gt;  $ zone  : chr [1:2] \"UTC\" \"UTC\"\n#&gt;  $ gmtoff: int [1:2] 0 0\n#&gt;  - attr(*, \"tzone\")= chr \"UTC\"\n#&gt;  - attr(*, \"balanced\")= logi TRUE\n\nEl genérico es un intermediario: su trabajo es definir la interfaz (es decir, los argumentos) y luego encontrar la implementación correcta para el trabajo. La implementación para una clase específica se denomina método, y el genérico encuentra ese método realizando despacho de métodos.\nPuede usar sloop::s3_dispatch() para ver el proceso de envío del método:\n\ns3_dispatch(print(f))\n#&gt; =&gt; print.factor\n#&gt;  * print.default\n\n Volveremos a los detalles del envío en la Sección 13.4.1, por ahora tenga en cuenta que los métodos S3 son funciones con un esquema de nombres especial, generic.class(). Por ejemplo, el método factor para el genérico print() se llama print.factor(). Nunca debe llamar al método directamente, sino confiar en el genérico para encontrarlo por usted.\nEn general, puede identificar un método por la presencia de . en el nombre de la función, pero hay una serie de funciones importantes en base R que se escribieron antes de S3 y, por lo tanto, usan . para unir palabras. Si no está seguro, verifique con sloop::ftype():\n\nftype(t.test)\n#&gt; [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#&gt; [1] \"S3\"     \"method\"\n\n A diferencia de la mayoría de las funciones, no puede ver el código fuente de la mayoría de los métodos S3 1 simplemente escribiendo sus nombres. Esto se debe a que los métodos de S3 generalmente no se exportan: viven solo dentro del paquete y no están disponibles en el entorno global. En su lugar, puede usar sloop::s3_get_method(), que funcionará independientemente de dónde resida el método:\n\nweighted.mean.Date\n#&gt; Error in eval(expr, envir, enclos): object 'weighted.mean.Date' not found\n\ns3_get_method(weighted.mean.Date)\n#&gt; function (x, w, ...) \n#&gt; .Date(weighted.mean(unclass(x), w, ...))\n#&gt; &lt;bytecode: 0x560a80395fc0&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\n\n13.2.1 Ejercicios\n\nDescribe la diferencia entre t.test() y t.data.frame(). ¿Cuándo se llama cada función?\nHaga una lista de las funciones básicas de R que se usan comúnmente y que contienen . en su nombre, pero que no son métodos de S3.\n¿Qué hace el método as.data.frame.data.frame()? ¿Por qué es confuso? ¿Cómo podría evitar esta confusión en su propio código?\nDescriba la diferencia de comportamiento en estas dos llamadas.\n\nset.seed(1014)\nsome_days &lt;- as.Date(\"2017-01-31\") + sample(10, 5)\n\nmean(some_days)\n#&gt; [1] \"2017-02-06\"\nmean(unclass(some_days))\n#&gt; [1] 17203\n\n¿Qué clase de objeto devuelve el siguiente código? ¿Sobre qué tipo de base está construido? ¿Qué atributos utiliza?\n\nx &lt;- ecdf(rpois(100, 10))\nx\n#&gt; Empirical CDF \n#&gt; Call: ecdf(rpois(100, 10))\n#&gt;  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01\n\n¿Qué clase de objeto devuelve el siguiente código? ¿Sobre qué tipo de base está construido? ¿Qué atributos utiliza?\n\nx &lt;- table(rpois(100, 5))\nx\n#&gt; \n#&gt;  1  2  3  4  5  6  7  8  9 10 \n#&gt;  7  5 18 14 15 15 14  4  5  3",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#sec-s3-classes",
    "href": "S3.html#sec-s3-classes",
    "title": "13  S3",
    "section": "13.3 Clases",
    "text": "13.3 Clases\n \nSi ha realizado programación orientada a objetos en otros lenguajes, se sorprenderá al saber que S3 no tiene una definición formal de una clase: para convertir un objeto en una instancia de una clase, simplemente establezca el atributo de clase. Puedes hacerlo durante la creación con structure(), o después del hecho con class&lt;-():\n\n# Crear y asignar clases en un solo paso\nx &lt;- structure(list(), class = \"my_class\")\n\n# Crear, luego establecer la clase\nx &lt;- list()\nclass(x) &lt;- \"my_class\"\n\nPuede determinar la clase de un objeto S3 con class(x) y ver si un objeto es una instancia de una clase usando inherits(x, \"classname\").\n\nclass(x)\n#&gt; [1] \"my_class\"\ninherits(x, \"my_class\")\n#&gt; [1] TRUE\ninherits(x, \"your_class\")\n#&gt; [1] FALSE\n\nEl nombre de la clase puede ser cualquier cadena, pero recomiendo usar solo letras y _. Evite . porque (como se mencionó anteriormente) puede confundirse con el separador . entre un nombre genérico y un nombre de clase. Al usar una clase en un paquete, recomiendo incluir el nombre del paquete en el nombre de la clase. Eso asegura que no chocará accidentalmente con una clase definida por otro paquete.\nS3 no tiene comprobaciones de corrección, lo que significa que puede cambiar la clase de los objetos existentes:\n\n# Crear un modelo lineal\nmod &lt;- lm(log(mpg) ~ log(disp), data = mtcars)\nclass(mod)\n#&gt; [1] \"lm\"\nprint(mod)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = log(mpg) ~ log(disp), data = mtcars)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    log(disp)  \n#&gt;       5.381       -0.459\n\n# Conviértelo en una fecha (?!)\nclass(mod) &lt;- \"Date\"\n\n# Como era de esperar, esto no funciona muy bien\nprint(mod)\n#&gt; Error in as.POSIXlt(.Internal(Date2POSIXlt(x, tz)), tz = tz): 'list' object cannot be coerced to type 'double'\n\nSi ha usado otros lenguajes orientados a objetos, esto podría hacerle sentir mareado, pero en la práctica esta flexibilidad causa pocos problemas. R no evita que te dispares en el pie, pero mientras no apuntes el arma a los dedos de los pies y aprietes el gatillo, no tendrás ningún problema.\nPara evitar las intersecciones de pie y bala al crear su propia clase, le recomiendo que proporcione generalmente tres funciones:\n\nUn constructor de bajo nivel, new_myclass(), que crea eficientemente nuevos objetos con la estructura correcta.\nUn validador, validate_myclass(), que realiza verificaciones más costosas desde el punto de vista computacional para garantizar que el objeto tenga los valores correctos.\nUn ayudante fácil de usar, myclass(), que proporciona una manera conveniente para que otros creen objetos de su clase.\n\nNo necesita un validador para clases muy simples, y puede omitir el asistente si la clase es solo para uso interno, pero siempre debe proporcionar un constructor.\n\n13.3.1 Constructores\n \nS3 no proporciona una definición formal de una clase, por lo que no tiene una forma integrada de garantizar que todos los objetos de una clase determinada tengan la misma estructura (es decir, el mismo tipo base y los mismos atributos con los mismos tipos). En su lugar, debe aplicar una estructura coherente mediante el uso de un constructor.\nEl constructor debe seguir tres principios:\n\nSe llamará new_myclass().\nTener un argumento para el objeto base y uno para cada atributo.\nComprobar el tipo del objeto base y los tipos de cada atributo.\n\nIlustraré estas ideas creando constructores para las clases base2 con las que ya está familiarizado. Para comenzar, hagamos un constructor para la clase S3 más simple: Date. Una fecha es simplemente un doble con un único atributo: su clase es Date. Esto lo convierte en un constructor muy simple:\n\n\nnew_Date &lt;- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"Date\")\n}\n\nnew_Date(c(-1, 0, 1))\n#&gt; [1] \"1969-12-31\" \"1970-01-01\" \"1970-01-02\"\n\nEl propósito de los constructores es ayudarte a ti, el desarrollador. Eso significa que puede mantenerlos simples y no necesita optimizar los mensajes de error para el consumo público. Si espera que los usuarios también creen objetos, debe crear una función de ayuda amigable, llamada class_name(), que describiré en breve.\nUn constructor un poco más complicado es el de difftime, que se usa para representar diferencias de tiempo. Se basa de nuevo en un doble, pero tiene un atributo de unidades que debe tomar uno de un pequeño conjunto de valores:\n\n\nnew_difftime &lt;- function(x = double(), units = \"secs\") {\n  stopifnot(is.double(x))\n  units &lt;- match.arg(units, c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))\n\n  structure(x,\n    class = \"difftime\",\n    units = units\n  )\n}\n\nnew_difftime(c(1, 10, 3600), \"secs\")\n#&gt; Time differences in secs\n#&gt; [1]    1   10 3600\nnew_difftime(52, \"weeks\")\n#&gt; Time difference of 52 weeks\n\nEl constructor es una función de desarrollador: será llamado en muchos lugares por un usuario experimentado. Eso significa que está bien intercambiar un poco de seguridad a cambio de rendimiento, y debe evitar verificaciones potencialmente lentas en el constructor.\n\n\n13.3.2 Validadores\n \nLas clases más complicadas requieren controles de validez más complicados. Tome factores, por ejemplo. Un constructor solo verifica que los tipos sean correctos, lo que permite crear factores con formato incorrecto:\n\n\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nnew_factor(1:5, \"a\")\n#&gt; Error in as.character.factor(x): malformed factor\nnew_factor(0:1, \"a\")\n#&gt; Error in as.character.factor(x): malformed factor\n\nEn lugar de sobrecargar al constructor con controles complicados, es mejor ponerlos en una función separada. Si lo hace, le permite crear nuevos objetos de forma económica cuando sabe que los valores son correctos y reutilizar fácilmente las comprobaciones en otros lugares.\n\nvalidate_factor &lt;- function(x) {\n  values &lt;- unclass(x)\n  levels &lt;- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values &gt; 0)) {\n    stop(\n      \"Todos los valores `x` deben ser no faltantes y mayores que cero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) &lt; max(values)) {\n    stop(\n      \"Debe haber al menos tantos `levels` como valores posibles en `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nvalidate_factor(new_factor(1:5, \"a\"))\n#&gt; Error: Debe haber al menos tantos `levels` como valores posibles en `x`\nvalidate_factor(new_factor(0:1, \"a\"))\n#&gt; Error: Todos los valores `x` deben ser no faltantes y mayores que cero\n\nEsta función de validación se llama principalmente por sus efectos secundarios (arrojar un error si el objeto no es válido), por lo que esperaría que devuelva su entrada principal de forma invisible (como se describe en la Sección 6.7.2). Sin embargo, es útil que los métodos de validación regresen visiblemente, como veremos a continuación.\n\n\n13.3.3 Ayudantes\n \nSi desea que los usuarios construyan objetos de su clase, también debe proporcionar un método auxiliar que les haga la vida lo más fácil posible. Un ayudante siempre debe:\n\nTener el mismo nombre que la clase, p. myclass().\nTermine llamando al constructor y al validador, si existe.\nCree mensajes de error cuidadosamente elaborados y adaptados a un usuario final.\nTenga una interfaz de usuario cuidadosamente diseñada con valores predeterminados cuidadosamente seleccionados y conversiones útiles.\n\nLa última viñeta es la más complicada y es difícil dar consejos generales. Sin embargo, hay tres patrones comunes:\n\nA veces, todo lo que necesita hacer el ayudante es forzar sus entradas al tipo deseado. Por ejemplo, new_difftime() es muy estricto y viola la convención habitual de que puede usar un vector entero siempre que pueda usar un vector doble:\n\nnew_difftime(1:10)\n#&gt; Error in new_difftime(1:10): is.double(x) is not TRUE\n\nNo es el trabajo del constructor ser flexible, así que aquí creamos un ayudante que solo fuerza la entrada a un doble.\n\ndifftime &lt;- function(x = double(), units = \"secs\") {\n  x &lt;- as.double(x)\n  new_difftime(x, units = units)\n}\n\ndifftime(1:10)\n#&gt; Time differences in secs\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\n\nA menudo, la representación más natural de un objeto complejo es una cadena. Por ejemplo, es muy conveniente especificar factores con un vector de caracteres. El siguiente código muestra una versión simple de factor(): toma un vector de caracteres y supone que los niveles deberían ser valores únicos. Esto no siempre es correcto (ya que es posible que algunos niveles no se vean en los datos), pero es un valor predeterminado útil.\n\nfactor &lt;- function(x = character(), levels = unique(x)) {\n  ind &lt;- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"a\", \"a\", \"b\"))\n#&gt; [1] a a b\n#&gt; Levels: a b\n\n\nAlgunos objetos complejos se especifican de manera más natural mediante múltiples componentes simples. Por ejemplo, creo que es natural construir una fecha y hora proporcionando los componentes individuales (año, mes, día, etc.). Eso me lleva a este ayudante POSIXct() que se parece a la función existente ISODatetime()3:\n\nPOSIXct &lt;- function(year = integer(), \n                    month = integer(), \n                    day = integer(), \n                    hour = 0L, \n                    minute = 0L, \n                    sec = 0, \n                    tzone = \"\") {\n  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)\n}\n\nPOSIXct(2020, 1, 1, tzone = \"America/New_York\")\n#&gt; [1] \"2020-01-01 EST\"\n\n\n\nPara clases más complicadas, debe sentirse libre de ir más allá de estos patrones para hacer la vida lo más fácil posible para sus usuarios.\n\n\n13.3.4 Ejercicios\n\nEscribe un constructor para los objetos data.frame. ¿Sobre qué tipo base se construye un marco de datos? ¿Qué atributos utiliza? ¿Cuáles son las restricciones impuestas a los elementos individuales? ¿Qué pasa con los nombres?\nMejore mi ayudante factor() para que tenga un mejor comportamiento cuando uno o más valores no se encuentran en los niveles. ¿Qué hace base::factor() en esta situación?\nLee atentamente el código fuente de factor(). ¿Qué hace que mi constructor no hace?\nLos factores tienen un atributo opcional de “contrastes”. Lea la ayuda de C() y describa brevemente el propósito del atributo. ¿Qué tipo debe tener? Reescriba el constructor new_factor() para incluir este atributo.\nLea la documentación de utils::as.roman(). ¿Cómo escribirías un constructor para esta clase? ¿Necesita un validador? ¿Qué podría hacer un ayudante?",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#sec-s3-methods",
    "href": "S3.html#sec-s3-methods",
    "title": "13  S3",
    "section": "13.4 Genéricos y métodos",
    "text": "13.4 Genéricos y métodos\n\n \nEl trabajo de un genérico S3 es realizar el envío de métodos, es decir, encontrar la implementación específica para una clase. El envío de métodos se realiza mediante UseMethod(), al que todos los genéricos llaman4. UseMethod() toma dos argumentos: el nombre de la función genérica (obligatorio) y el argumento a usar para el envío del método (opcional). Si omite el segundo argumento, se enviará en función del primer argumento, que casi siempre es lo que se desea.\nLa mayoría de los genéricos son muy simples y consisten solo en una llamada a UseMethod(). Tome mean() por ejemplo:\n\nmean\n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x560a7b035b40&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\nCrear su propio genérico es igualmente simple:\n\nmy_new_generic &lt;- function(x) {\n  UseMethod(\"my_new_generic\")\n}\n\n(Si se pregunta por qué tenemos que repetir my_new_generic dos veces, piense en la Sección 6.2.3.)\nNo pasa ninguno de los argumentos del genérico a UseMethod(); utiliza magia profunda para pasar al método automáticamente. El proceso preciso es complicado y con frecuencia sorprendente, por lo que debe evitar realizar cualquier cálculo de forma genérica. Para conocer todos los detalles, lea detenidamente la sección Detalles técnicos en ?UseMethod.\n\n13.4.1 Método de envío\n \n¿Cómo funciona UseMethod()? Básicamente, crea un vector de nombres de métodos, paste0(\"generic\", \".\", c(class(x), \"default\")), y luego busca cada método potencial a su vez. Podemos ver esto en acción con sloop::s3_dispatch(). Le das una llamada a un genérico S3 y enumera todos los métodos posibles. Por ejemplo, ¿qué método se llama cuando imprime un objeto Date?\n\nx &lt;- Sys.Date()\ns3_dispatch(print(x))\n#&gt; =&gt; print.Date\n#&gt;  * print.default\n\nLa salida aquí es simple:\n\n=&gt; indica el método que se llama, aquí print.Date()\n* indica un método que está definido, pero no llamado, aquí print.default().\n\nLa clase “predeterminada” es una pseudoclase especial. Esta no es una clase real, pero se incluye para que sea posible definir un respaldo estándar que se encuentra siempre que un método específico de clase no está disponible.\nLa esencia del envío de métodos es bastante simple, pero a medida que avanza el capítulo, verá que se vuelve progresivamente más complicado para abarcar la herencia, los tipos base, los genéricos internos y los genéricos de grupo. El siguiente código muestra un par de casos más complicados a los que volveremos en las secciones, Sección 13.6 y Sección 13.7.\n\nx &lt;- matrix(1:10, nrow = 2)\ns3_dispatch(mean(x))\n#&gt;    mean.matrix\n#&gt;    mean.integer\n#&gt;    mean.numeric\n#&gt; =&gt; mean.default\n\ns3_dispatch(sum(Sys.time()))\n#&gt;    sum.POSIXct\n#&gt;    sum.POSIXt\n#&gt;    sum.default\n#&gt; =&gt; Summary.POSIXct\n#&gt;    Summary.POSIXt\n#&gt;    Summary.default\n#&gt; -&gt; sum (internal)\n\n\n\n13.4.2 Encontrar métodos\n\nsloop::s3_dispatch() te permite encontrar el método específico usado para una sola llamada. ¿Qué sucede si desea encontrar todos los métodos definidos para un genérico o asociados con una clase? Ese es el trabajo de sloop::s3_methods_generic() y sloop::s3_methods_class():\n\ns3_methods_generic(\"mean\")\n#&gt; # A tibble: 7 × 4\n#&gt;   generic class      visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 mean    Date       TRUE    base               \n#&gt; 2 mean    default    TRUE    base               \n#&gt; 3 mean    difftime   TRUE    base               \n#&gt; 4 mean    POSIXct    TRUE    base               \n#&gt; 5 mean    POSIXlt    TRUE    base               \n#&gt; 6 mean    quosure    FALSE   registered S3method\n#&gt; 7 mean    vctrs_vctr FALSE   registered S3method\n\ns3_methods_class(\"ordered\")\n#&gt; # A tibble: 4 × 4\n#&gt;   generic       class   visible source             \n#&gt;   &lt;chr&gt;         &lt;chr&gt;   &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 as.data.frame ordered TRUE    base               \n#&gt; 2 Ops           ordered TRUE    base               \n#&gt; 3 relevel       ordered FALSE   registered S3method\n#&gt; 4 Summary       ordered TRUE    base\n\n\n\n13.4.3 Crear métodos\n \nHay dos arrugas a tener en cuenta cuando crea un nuevo método:\n\nPrimero, solo debe escribir un método si posee el genérico o la clase. R le permitirá definir un método incluso si no lo hace, pero es de muy mala educación. En su lugar, trabaje con el autor del genérico o de la clase para agregar el método en su código.\nUn método debe tener los mismos argumentos que su genérico. Esto se aplica en los paquetes mediante R CMD check, pero es una buena práctica incluso si no está creando un paquete.\nHay una excepción a esta regla: si el genérico tiene ..., el método puede contener un superconjunto de argumentos. Esto permite que los métodos tomen argumentos adicionales arbitrarios. La desventaja de usar ..., sin embargo, es que cualquier argumento mal escrito se tragará silenciosamente 5, como se menciona en la Sección 6.6.\n\n\n\n13.4.4 Ejercicios\n\nLea el código fuente de t() y t.test() y confirme que t.test() es un método genérico de S3 y no un método de S3. ¿Qué pasa si creas un objeto con la clase test y llamas t() con él? ¿Por qué?\n\nx &lt;- structure(1:10, class = \"test\")\nt(x)\n\n¿Para qué genéricos tiene métodos la clase table?\n¿Para qué genéricos tiene métodos la clase ecdf?\n¿Qué base genérica tiene el mayor número de métodos definidos?\nLea detenidamente la documentación de UseMethod() y explique por qué el siguiente código devuelve los resultados que devuelve. ¿Qué dos reglas usuales de evaluación de funciones viola UseMethod()?\n\ng &lt;- function(x) {\n  x &lt;- 10\n  y &lt;- 10\n  UseMethod(\"g\")\n}\ng.default &lt;- function(x) c(x = x, y = y)\n\nx &lt;- 1\ny &lt;- 1\ng(x)\n#&gt; x y \n#&gt; 1 1\n\n¿Cuáles son los argumentos para [? ¿Por qué es una pregunta difícil de responder?",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#sec-object-styles",
    "href": "S3.html#sec-object-styles",
    "title": "13  S3",
    "section": "13.5 Estilos de objeto",
    "text": "13.5 Estilos de objeto\n\nHasta ahora me he centrado en clases de estilo vectorial como Date y factor. Estos tienen la propiedad clave de que length(x) representa el número de observaciones en el vector. Hay tres variantes que no tienen esta propiedad:\n\nLos objetos de estilo de registro utilizan una lista de vectores de igual longitud para representar componentes individuales del objeto. El mejor ejemplo de esto es POSIXlt, que debajo del capó es una lista de 11 componentes de fecha y hora como año, mes y día. Las clases de estilo de registro anulan longitud() y los métodos de creación de subconjuntos para ocultar este detalle de implementación.\n\nx &lt;- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))\nx\n#&gt; [1] \"2020-01-01 00:00:01 UTC\" \"2020-01-01 00:00:02 UTC\"\n#&gt; [3] \"2020-01-01 00:00:03 UTC\"\n\nlength(x)\n#&gt; [1] 3\nlength(unclass(x))\n#&gt; [1] 11\n\nx[[1]] # the first date time\n#&gt; [1] \"2020-01-01 00:00:01 UTC\"\nunclass(x)[[1]] # the first component, the number of seconds\n#&gt; [1] 1 2 3\n\n\nLos marcos de datos son similares a los objetos de estilo de registro en que ambos usan listas de vectores de igual longitud. Sin embargo, los marcos de datos son conceptualmente bidimensionales y los componentes individuales se exponen fácilmente al usuario. El número de observaciones es el número de filas, no la longitud:\n\nx &lt;- data.frame(x = 1:100, y = 1:100)\nlength(x)\n#&gt; [1] 2\nnrow(x)\n#&gt; [1] 100\n\n\nLos objetos escalares normalmente usan una lista para representar una sola cosa. Por ejemplo, un objeto lm es una lista de longitud 12 pero representa un modelo.\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nlength(mod)\n#&gt; [1] 12\n\nLos objetos escalares también se pueden construir sobre funciones, llamadas y entornos6. En general, esto es menos útil, pero puede ver aplicaciones en stats::ecdf(), R6 (Capítulo 14) y rlang::quo() (Capítulo 19) . \n\nDesafortunadamente, describir el uso apropiado de cada uno de estos estilos de objeto está más allá del alcance de este libro. Sin embargo, puede obtener más información en la documentación del paquete vctrs (https://vctrs.r-lib.org); el paquete también proporciona constructores y ayudantes que facilitan la implementación de los diferentes estilos.\n\n13.5.1 Ejercicios\n\nCategorice los objetos devueltos por lm(), factor(), table(), as.Date(), as.POSIXct() ecdf(), ordered(), I() en los estilos descritos anteriormente.\n¿Cómo sería una función constructora para objetos lm, new_lm()? Use ?lm y experimente para descubrir los campos obligatorios y sus tipos.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#sec-s3-inheritance",
    "href": "S3.html#sec-s3-inheritance",
    "title": "13  S3",
    "section": "13.6 Herencia",
    "text": "13.6 Herencia\n \nLas clases de S3 pueden compartir el comportamiento a través de un mecanismo llamado herencia. La herencia está impulsada por tres ideas:\n\nLa clase puede ser un carácter vector. Por ejemplo, las clases ordered y POSIXct tienen dos componentes en su clase:\n\nclass(ordered(\"x\"))\n#&gt; [1] \"ordered\" \"factor\"\nclass(Sys.time())\n#&gt; [1] \"POSIXct\" \"POSIXt\"\n\n\nSi no se encuentra un método para la clase en el primer elemento del vector, R busca un método para la segunda clase (y así sucesivamente):\n\ns3_dispatch(print(ordered(\"x\")))\n#&gt;    print.ordered\n#&gt; =&gt; print.factor\n#&gt;  * print.default\ns3_dispatch(print(Sys.time()))\n#&gt; =&gt; print.POSIXct\n#&gt;    print.POSIXt\n#&gt;  * print.default\n\nUn método puede delegar trabajo llamando a NextMethod(). Volveremos a eso muy pronto; por ahora, tenga en cuenta que s3_dispatch() informa delegación con -&gt;.\n\ns3_dispatch(ordered(\"x\")[1])\n#&gt;    [.ordered\n#&gt; =&gt; [.factor\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\ns3_dispatch(Sys.time()[1])\n#&gt; =&gt; [.POSIXct\n#&gt;    [.POSIXt\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\n\nAntes de continuar, necesitamos un poco de vocabulario para describir la relación entre las clases que aparecen juntas en un vector de clase. Diremos que ordered es una subclase de factor porque siempre aparece antes que él en el vector de clase y, a la inversa, diremos que factor es una superclase de ordered.\nS3 no impone restricciones en la relación entre subclases y superclases, pero su vida será más fácil si impone algunas. Le recomiendo que se adhiera a dos principios simples al crear una subclase:\n\nEl tipo base de la subclase debe ser el mismo que el de la superclase.\nLos atributos de la subclase deben ser un superconjunto de los atributos de la superclase.\n\nPOSIXt no se adhiere a estos principios porque POSIXct tiene tipo doble y POSIXlt tiene tipo lista. Esto significa que POSIXt no es una superclase, e ilustra que es bastante posible usar el sistema de herencia S3 para implementar otros estilos de código compartido (aquí POSIXt juega un papel más como una interfaz), pero necesitará descubra convenciones seguras usted mismo. \n\n13.6.1 NextMethod()\n\nNextMethod() es la parte más difícil de entender de la herencia, por lo que comenzaremos con un ejemplo concreto para el caso de uso más común: [. Comenzaremos creando una clase de juguete simple: una clase secreta que oculta su salida cuando se imprime:\n\nnew_secret &lt;- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"secret\")\n}\n\nprint.secret &lt;- function(x, ...) {\n  print(strrep(\"x\", nchar(x)))\n  invisible(x)\n}\n\nx &lt;- new_secret(c(15, 1, 456))\nx\n#&gt; [1] \"xx\"  \"x\"   \"xxx\"\n\nEsto funciona, pero el método predeterminado [ no conserva la clase:\n\ns3_dispatch(x[1])\n#&gt;    [.secret\n#&gt;    [.default\n#&gt; =&gt; [ (internal)\nx[1]\n#&gt; [1] 15\n\nPara arreglar esto, necesitamos proporcionar un método [.secret. ¿Cómo podríamos implementar este método? El enfoque ingenuo no funcionará porque nos quedaremos atrapados en un bucle infinito:\n\n`[.secret` &lt;- function(x, i) {\n  new_secret(x[i])\n}\n\nEn su lugar, necesitamos alguna forma de llamar al código [ subyacente, es decir, la implementación que sería llamada si no tuviéramos un método [.secret. Un enfoque sería unclass() el objeto:\n\n`[.secret` &lt;- function(x, i) {\n  x &lt;- unclass(x)\n  new_secret(x[i])\n}\nx[1]\n#&gt; [1] \"xx\"\n\nEsto funciona, pero es ineficiente porque crea una copia de x. Un mejor enfoque es usar NextMethod(), que resuelve de manera concisa el problema de delegar al método que se habría llamado si [.secret no existiera:\n\n`[.secret` &lt;- function(x, i) {\n  new_secret(NextMethod())\n}\nx[1]\n#&gt; [1] \"xx\"\n\nPodemos ver lo que está pasando con sloop::s3_dispatch():\n\ns3_dispatch(x[1])\n#&gt; =&gt; [.secret\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\nEl =&gt; indica que se llama a [.secret, pero que NextMethod() delega el trabajo al método interno subyacente [, como se muestra en -&gt;.\nAl igual que con UseMethod(), la semántica precisa de NextMethod() es compleja. En particular, realiza un seguimiento de la lista de posibles métodos siguientes con una variable especial, lo que significa que la modificación del objeto que se envía no tendrá ningún impacto en el método que se llamará a continuación.\n\n\n13.6.2 Permitir subclases\n\nCuando crea una clase, debe decidir si desea permitir subclases, ya que requiere algunos cambios en el constructor y una reflexión cuidadosa en sus métodos.\nPara permitir subclases, el constructor principal debe tener argumentos ... y class:\n\nnew_secret &lt;- function(x, ..., class = character()) {\n  stopifnot(is.double(x))\n\n  structure(\n    x,\n    ...,\n    class = c(class, \"secret\")\n  )\n}\n\nLuego, el constructor de la subclase puede simplemente llamar al constructor de la clase principal con argumentos adicionales según sea necesario. Por ejemplo, imagina que queremos crear una clase supersecreta que también oculta la cantidad de caracteres:\n\nnew_supersecret &lt;- function(x) {\n  new_secret(x, class = \"supersecret\")\n}\n\nprint.supersecret &lt;- function(x, ...) {\n  print(rep(\"xxxxx\", length(x)))\n  invisible(x)\n}\n\nx2 &lt;- new_supersecret(c(15, 1, 456))\nx2\n#&gt; [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"\n\nPara permitir la herencia, también debe pensar detenidamente en sus métodos, ya que ya no puede usar el constructor. Si lo hace, el método siempre devolverá la misma clase, independientemente de la entrada. Esto obliga a quien hace una subclase a hacer mucho trabajo extra.\nConcretamente, esto significa que debemos revisar el método [.secret. Actualmente siempre devuelve un secret(), incluso cuando se le da un supersecreto:\n\n`[.secret` &lt;- function(x, ...) {\n  new_secret(NextMethod())\n}\n\nx2[1:3]\n#&gt; [1] \"xx\"  \"x\"   \"xxx\"\n\n\nQueremos asegurarnos de que [.secret devuelva la misma clase que x incluso si es una subclase. Por lo que puedo decir, no hay forma de resolver este problema usando solo la base R. En su lugar, deberá utilizar el paquete vctrs, que proporciona una solución en forma de vctrs::vec_restore() genérico. Este genérico toma dos entradas: un objeto que ha perdido información de subclase y un objeto de plantilla para usar para la restauración.\nPor lo general, los métodos vec_restore() son bastante simples: simplemente llama al constructor con los argumentos apropiados:\n\nvec_restore.secret &lt;- function(x, to, ...) new_secret(x)\nvec_restore.supersecret &lt;- function(x, to, ...) new_supersecret(x)\n\n(Si su clase tiene atributos, deberá pasarlos de to al constructor).\nAhora podemos usar vec_restore() en el método [.secret:\n\n`[.secret` &lt;- function(x, ...) {\n  vctrs::vec_restore(NextMethod(), x)\n}\nx2[1:3]\n#&gt; [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"\n\n(Solo entendí completamente este problema recientemente, por lo que al momento de escribir no se usa en el tidyverse. Con suerte, para cuando estés leyendo esto, se habrá implementado, lo que hará que sea mucho más fácil (por ejemplo) subclasificar tibbles. )\nSi construye su clase usando las herramientas provistas por el paquete vctrs, [ obtendrá este comportamiento automáticamente. Solo necesitará proporcionar su propio método [ si usa atributos que dependen de los datos o desea un comportamiento de subconjunto no estándar. Ver ?vctrs::new_vctr para más detalles.\n\n\n13.6.3 Ejercicios\n\n¿Cómo admite subclases [.Date? ¿Cómo no admite subclases?\nR tiene dos clases para representar datos de fecha y hora, POSIXct y POSIXlt, que heredan ambas de POSIXt. ¿Qué genéricos tienen comportamientos diferentes para las dos clases? ¿Qué genéricos comparten el mismo comportamiento?\n¿Qué espera que devuelva este código? ¿Qué devuelve realmente? ¿Por qué?\n\ngeneric2 &lt;- function(x) UseMethod(\"generic2\")\ngeneric2.a1 &lt;- function(x) \"a1\"\ngeneric2.a2 &lt;- function(x) \"a2\"\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#sec-s3-dispatch",
    "href": "S3.html#sec-s3-dispatch",
    "title": "13  S3",
    "section": "13.7 Detalles de envío",
    "text": "13.7 Detalles de envío\n\nEste capítulo concluye con algunos detalles adicionales sobre el envío de métodos. Es seguro omitir estos detalles si es nuevo en S3.\n\n13.7.1 S3 y tipos básicos\n \n¿Qué sucede cuando llama a un genérico S3 con un objeto base, es decir, un objeto sin clase? Podrías pensar que enviaría lo que class() devuelve:\n\nclass(matrix(1:5))\n#&gt; [1] \"matrix\" \"array\"\n\nPero, lamentablemente, el envío se produce en la clase implícita, que tiene tres componentes:\n\nLa cadena “array” o “matrix” si el objeto tiene dimensiones\nEl resultado de typeof() con algunos ajustes menores\nLa cadena “numeric” si el objeto es “integer” o “double”\n\nNo hay una función base que calcule la clase implícita, pero puede usar sloop::s3_class()\n\ns3_class(matrix(1:5))\n#&gt; [1] \"matrix\"  \"integer\" \"numeric\"\n\nEsto es usado por s3_dispatch():\n\ns3_dispatch(print(matrix(1:5)))\n#&gt;    print.matrix\n#&gt;    print.integer\n#&gt;    print.numeric\n#&gt; =&gt; print.default\n\nEsto significa que la clade, class(), de un objeto no determina de forma única su envío:\n\nx1 &lt;- 1:5\nclass(x1)\n#&gt; [1] \"integer\"\ns3_dispatch(mean(x1))\n#&gt;    mean.integer\n#&gt;    mean.numeric\n#&gt; =&gt; mean.default\n\nx2 &lt;- structure(x1, class = \"integer\")\nclass(x2)\n#&gt; [1] \"integer\"\ns3_dispatch(mean(x2))\n#&gt;    mean.integer\n#&gt; =&gt; mean.default\n\n\n\n13.7.2 Genéricos internos\n\nAlgunas funciones básicas, como [, sum() y cbind(), se denominan genéricos internos porque no llaman a UseMethod() sino que llaman a las funciones de C DispatchGroup( ) o DispatchOrEval(). s3_dispatch() muestra genéricos internos al incluir el nombre del genérico seguido de (internal):\n\ns3_dispatch(Sys.time()[1])\n#&gt; =&gt; [.POSIXct\n#&gt;    [.POSIXt\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\nPor motivos de rendimiento, los genéricos internos no envían a los métodos a menos que se haya establecido el atributo de clase, lo que significa que los genéricos internos no utilizan la clase implícita. Nuevamente, si alguna vez se siente confundido acerca del envío de métodos, puede confiar en s3_dispatch().\n\n\n13.7.3 Genéricos del grupo\n \nLos genéricos de grupo son la parte más complicada del envío de métodos de S3 porque involucran tanto NextMethod() como genéricos internos. Al igual que los genéricos internos, solo existen en la base R y no puede definir su propio grupo genérico.\nHay cuatro genéricos de grupo:\n\nMatemáticas: abs(), sign(), sqrt(), floor(), cos(), sin(), log(), y más (ver ?Math para la lista completa).\nOperaciones: +, -, *, /, ^, %%, %/%, &, |, !, ==, !=, &lt;, &lt;=, &gt;=, y &gt;.\nResumen: all(), any(), sum(), prod(), min(), max(), y range().\nComplejo: Arg(), Conj(), Im(), Mod(), Re().\n\nLa definición de un solo grupo genérico para su clase anula el comportamiento predeterminado para todos los miembros del grupo. Los métodos para genéricos grupales se buscan solo si los métodos para el genérico específico no existen:\n\ns3_dispatch(sum(Sys.time()))\n#&gt;    sum.POSIXct\n#&gt;    sum.POSIXt\n#&gt;    sum.default\n#&gt; =&gt; Summary.POSIXct\n#&gt;    Summary.POSIXt\n#&gt;    Summary.default\n#&gt; -&gt; sum (internal)\n\nLa mayoría de los genéricos de grupo implican una llamada a NextMethod(). Por ejemplo, tome los objetos difftime(). Si observa el envío del método para abs(), verá que hay un grupo genérico Math definido.\n\ny &lt;- as.difftime(10, units = \"mins\")\ns3_dispatch(abs(y))\n#&gt;    abs.difftime\n#&gt;    abs.default\n#&gt; =&gt; Math.difftime\n#&gt;    Math.default\n#&gt; -&gt; abs (internal)\n\nMath.difftime básicamente se ve así:\n\nMath.difftime &lt;- function(x, ...) {\n  new_difftime(NextMethod(), units = attr(x, \"units\"))\n}\n\nDespacha al siguiente método, aquí el valor predeterminado interno, para realizar el cálculo real y luego restaurar la clase y los atributos. (Para admitir mejor las subclases de difftime, sería necesario llamar a vec_restore(), como se describe en la Sección 13.6.2.)\nDentro de una función genérica de grupo, una variable especial .Generic proporciona la función genérica real llamada. Esto puede ser útil cuando se producen mensajes de error y, a veces, puede ser útil si necesita recuperar manualmente el genérico con diferentes argumentos.\n\n\n13.7.4 Despacho doble\n \nLos genéricos del grupo Ops, que incluye la aritmética de dos argumentos y los operadores booleanos como - y &, implementan un tipo especial de envío de métodos. Despachan en el tipo de ambos argumentos, que se llama despacho doble. Esto es necesario para preservar la propiedad conmutativa de muchos operadores, es decir, a + b debería ser igual a b + a. Tome el siguiente ejemplo simple:\n\ndate &lt;- as.Date(\"2017-01-01\")\ninteger &lt;- 1L\n\ndate + integer\n#&gt; [1] \"2017-01-02\"\ninteger + date\n#&gt; [1] \"2017-01-02\"\n\nSi + se enviara solo en el primer argumento, devolvería valores diferentes para los dos casos. Para superar este problema, los genéricos del grupo Ops utilizan una estrategia ligeramente diferente a la habitual. En lugar de hacer un envío de un solo método, hacen dos, uno para cada entrada. Hay tres posibles resultados de esta búsqueda:\n\nLos métodos son los mismos, por lo que no importa qué método se utilice.\nLos métodos son diferentes y R recurre al método interno con una advertencia.\nUn método es interno, en cuyo caso R llama al otro método.\n\nEste enfoque es propenso a errores, por lo que si desea implementar un despacho doble robusto para operadores algebraicos, le recomiendo usar el paquete vctrs. Ver ?vctrs::vec_arith para más detalles.\n\n\n13.7.5 Ejercicios\n\nExplique las diferencias en el envío a continuación:\n\nlength.integer &lt;- function(x) 10\n\nx1 &lt;- 1:5\nclass(x1)\n#&gt; [1] \"integer\"\ns3_dispatch(length(x1))\n#&gt;  * length.integer\n#&gt;    length.numeric\n#&gt;    length.default\n#&gt; =&gt; length (internal)\n\nx2 &lt;- structure(x1, class = \"integer\")\nclass(x2)\n#&gt; [1] \"integer\"\ns3_dispatch(length(x2))\n#&gt; =&gt; length.integer\n#&gt;    length.default\n#&gt;  * length (internal)\n\n¿Qué clases tienen un método para el grupo Math genérico en base R? Lee el código fuente. ¿Cómo funcionan los métodos?\nMath.difftime() es más complicado de lo que describí. ¿Por qué?",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "S3.html#footnotes",
    "href": "S3.html#footnotes",
    "title": "13  S3",
    "section": "",
    "text": "Las excepciones son los métodos que se encuentran en el paquete base, como t.data.frame, y los métodos que ha creado.↩︎\nLas versiones recientes de R tienen constructores .Date(), .difftime(), .POSIXct() y .POSIXlt(), pero son internos, no están bien documentados y no siguen los principios que Recomiendo.↩︎\nEste ayudante no es eficiente: en segundo plano ISODatetime() funciona pegando los componentes en una cadena y luego usando strptime(). Un equivalente más eficiente está disponible en lubridate::make_datetime().↩︎\nLa excepción son los genéricos internos, que se implementan en C y son el tema de la Sección 13.7.2.↩︎\nConsulte https://github.com/hadley/ellipsis para ver una forma experimental de advertir cuando los métodos no usan todos los argumentos en ..., lo que proporciona una posible resolución de este problema.↩︎\nTambién puede construir un objeto encima de una lista de pares, pero todavía tengo que encontrar una buena razón para hacerlo.↩︎",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>S3</span>"
    ]
  },
  {
    "objectID": "R6.html",
    "href": "R6.html",
    "title": "14  R6",
    "section": "",
    "text": "14.1 Introducción\nEste capítulo describe el sistema R6 OOP. R6 tiene dos propiedades especiales:\nSi aprendió programación orientada a objetos en otro lenguaje de programación, es probable que R6 se sienta muy natural y se incline a preferirlo a S3. Resista la tentación de seguir el camino de menor resistencia: en la mayoría de los casos, R6 lo llevará a un código R no idiomático. Volveremos a este tema en la Sección 16.3.\nR6 es muy similar a un sistema OOP base llamado clases de referencia, o RC para abreviar. Describo por qué enseño R6 y no RC en la Sección 14.5.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R6</span>"
    ]
  },
  {
    "objectID": "R6.html#introducción",
    "href": "R6.html#introducción",
    "title": "14  R6",
    "section": "",
    "text": "Utiliza el paradigma OOP encapsulado, lo que significa que los métodos pertenecen a los objetos, no a los genéricos, y los llamas como object$method().\nLos objetos R6 son mutables, lo que significa que se modifican en su lugar y, por lo tanto, tienen semántica de referencia.\n\n\n\n\nEstructura\n\nLa Sección 14.2 introduce R6::R6Class(), la única función que necesita saber para crear clases R6. Aprenderá sobre el método constructor, $new(), que le permite crear objetos R6, así como otros métodos importantes como $initialize() y $print().\nLa Sección 14.3 analiza los mecanismos de acceso de R6: campos privados y activos. Juntos, estos le permiten ocultar datos del usuario o exponer datos privados para leer pero no escribir.\nLa Sección 14.4 explora las consecuencias de la semántica de referencia de R6. Aprenderá sobre el uso de finalizadores para limpiar automáticamente cualquier operación realizada en el inicializador y un problema común si usa un objeto R6 como un campo en otro objeto R6.\nLa Sección 14.5 describe por qué cubro R6, en lugar del sistema RC base.\n\n\n\nRequisitos previos\nDebido a que R6 no está integrado en la base R, deberá instalar y cargar el paquete R6 para usarlo:\n\n# install.packages(\"R6\")\nlibrary(R6)\n\nLos objetos R6 tienen semántica de referencia, lo que significa que se modifican en el lugar, no se copian al modificar. Si no está familiarizado con estos términos, repase su vocabulario leyendo la Sección 2.5.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R6</span>"
    ]
  },
  {
    "objectID": "R6.html#sec-r6-classes",
    "href": "R6.html#sec-r6-classes",
    "title": "14  R6",
    "section": "14.2 Clases y métodos",
    "text": "14.2 Clases y métodos\n \nR6 solo necesita una única llamada de función para crear tanto la clase como sus métodos: R6::R6Class(). ¡Esta es la única función del paquete que usará!1\nEl siguiente ejemplo muestra los dos argumentos más importantes para R6Class():\n\nEl primer argumento es el classname. No es estrictamente necesario, pero mejora los mensajes de error y permite usar objetos R6 con genéricos S3. Por convención, las clases R6 tienen nombres UpperCamelCase.\nEl segundo argumento, public, proporciona una lista de métodos (funciones) y campos (cualquier otra cosa) que conforman la interfaz pública del objeto. Por convención, los métodos y campos usan snake_case. Los métodos pueden acceder a los métodos y campos del objeto actual a través de self$.2 \n\n\nAccumulator &lt;- R6Class(\"Accumulator\", list(\n  sum = 0,\n  add = function(x = 1) {\n    self$sum &lt;- self$sum + x \n    invisible(self)\n  })\n)\n\nSiempre debe asignar el resultado de R6Class() a una variable con el mismo nombre que la clase, porque R6Class() devuelve un objeto R6 que define la clase:\n\nAccumulator\n#&gt; &lt;Accumulator&gt; object generator\n#&gt;   Public:\n#&gt;     sum: 0\n#&gt;     add: function (x = 1) \n#&gt;     clone: function (deep = FALSE) \n#&gt;   Parent env: &lt;environment: R_GlobalEnv&gt;\n#&gt;   Locked objects: TRUE\n#&gt;   Locked class: FALSE\n#&gt;   Portable: TRUE\n\n Construyes un nuevo objeto a partir de la clase llamando al método new(). En R6, los métodos pertenecen a los objetos, por lo que usa $ para acceder a new():\n\nx &lt;- Accumulator$new() \n\nA continuación, puede llamar a los métodos y acceder a los campos con $:\n\nx$add(4) \nx$sum\n#&gt; [1] 4\n\nEn esta clase, los campos y métodos son públicos, lo que significa que puede obtener o establecer el valor de cualquier campo. Más adelante, veremos cómo usar campos y métodos privados para evitar el acceso casual a las partes internas de su clase.\nPara que quede claro cuando hablamos de campos y métodos en lugar de variables y funciones, pondré el prefijo $ en sus nombres. Por ejemplo, la clase Accumulate tiene el campo $sum y el método $add().\n\n14.2.1 Encadenamiento de métodos\n\n$add() se llama principalmente por su efecto secundario de actualizar $sum.\n\nAccumulator &lt;- R6Class(\"Accumulator\", list(\n  sum = 0,\n  add = function(x = 1) {\n    self$sum &lt;- self$sum + x \n    invisible(self)\n  })\n)\n\nLos métodos R6 de efectos secundarios siempre deben devolver self de forma invisible. Esto devuelve el objeto “actual” y hace posible encadenar varias llamadas a métodos:\n\nx$add(10)$add(10)$sum\n#&gt; [1] 24\n\nPara facilitar la lectura, puede poner una llamada de método en cada línea:\n\nx$\n  add(10)$\n  add(10)$\n  sum\n#&gt; [1] 44\n\nEsta técnica se llama encadenamiento de métodos y se usa comúnmente en lenguajes como Python y JavaScript. El encadenamiento de métodos está profundamente relacionado con la tubería, y discutiremos los pros y los contras de cada enfoque en la Sección 16.3.3.\n\n\n14.2.2 Métodos importantes\n \nHay dos métodos importantes que deben definirse para la mayoría de las clases: $initialize() y $print(). No son obligatorios, pero proporcionarlos hará que su clase sea más fácil de usar.\n$initialize() anula el comportamiento predeterminado de $new(). Por ejemplo, el siguiente código define una clase de Persona con los campos $name y $age. Para asegurar que $name sea siempre una sola cadena, y $age sea siempre un solo número, puse controles en $initialize().\n\nPerson &lt;- R6Class(\"Person\", list(\n  name = NULL,\n  age = NA,\n  initialize = function(name, age = NA) {\n    stopifnot(is.character(name), length(name) == 1)\n    stopifnot(is.numeric(age), length(age) == 1)\n    \n    self$name &lt;- name\n    self$age &lt;- age\n  }\n))\n\nhadley &lt;- Person$new(\"Hadley\", age = \"thirty-eight\")\n#&gt; Error in initialize(...): is.numeric(age) is not TRUE\n\nhadley &lt;- Person$new(\"Hadley\", age = 38)\n\nSi tiene requisitos de validación más costosos, impleméntelos en un $validate() separado y solo llame cuando sea necesario.\nDefinir $print() le permite anular el comportamiento de impresión predeterminado. Como con cualquier método R6 llamado por sus efectos secundarios, $print() debería devolver invisible(self).\n\nPerson &lt;- R6Class(\"Person\", list(\n  name = NULL,\n  age = NA,\n  initialize = function(name, age = NA) {\n    self$name &lt;- name\n    self$age &lt;- age\n  },\n  print = function(...) {\n    cat(\"Person: \\n\")\n    cat(\"  Name: \", self$name, \"\\n\", sep = \"\")\n    cat(\"  Age:  \", self$age, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\nhadley2 &lt;- Person$new(\"Hadley\")\nhadley2\n#&gt; Person: \n#&gt;   Name: Hadley\n#&gt;   Age:  NA\n\nEste código ilustra un aspecto importante de R6. Debido a que los métodos están vinculados a objetos individuales, el objeto hadley creado previamente no obtiene este nuevo método:\n\nhadley\n#&gt; &lt;Person&gt;\n#&gt;   Public:\n#&gt;     age: 38\n#&gt;     clone: function (deep = FALSE) \n#&gt;     initialize: function (name, age = NA) \n#&gt;     name: Hadley\n\nhadley$print\n#&gt; NULL\n\nDesde la perspectiva de R6, no hay relación entre hadley y hadley2; coincidentemente comparten el mismo nombre de clase. Esto no causa problemas cuando se usan objetos R6 ya desarrollados, pero puede hacer que la experimentación interactiva sea confusa. Si está cambiando el código y no puede averiguar por qué los resultados de las llamadas a métodos no son diferentes, asegúrese de haber reconstruido los objetos R6 con la nueva clase.\n\n\n14.2.3 Agregar métodos después de la creación\n\nEn lugar de crear continuamente nuevas clases, también es posible modificar los campos y métodos de una clase existente. Esto es útil al explorar de forma interactiva o cuando tiene una clase con muchas funciones que le gustaría dividir en partes. Agrega nuevos elementos a una clase existente con $set(), proporcionando la visibilidad (más información en la Sección 14.3), el nombre y el componente.\n\nAccumulator &lt;- R6Class(\"Accumulator\")\nAccumulator$set(\"public\", \"sum\", 0)\nAccumulator$set(\"public\", \"add\", function(x = 1) {\n  self$sum &lt;- self$sum + x \n  invisible(self)\n})\n\nComo se indicó anteriormente, los nuevos métodos y campos solo están disponibles para nuevos objetos; no se agregan retrospectivamente a los objetos existentes.\n\n\n14.2.4 Herencia\n \nPara heredar el comportamiento de una clase existente, proporcione el objeto de la clase al argumento inherit:\n\nAccumulatorChatty &lt;- R6Class(\"AccumulatorChatty\", \n  inherit = Accumulator,\n  public = list(\n    add = function(x = 1) {\n      cat(\"Adding \", x, \"\\n\", sep = \"\")\n      super$add(x = x)\n    }\n  )\n)\n\nx2 &lt;- AccumulatorChatty$new()\nx2$add(10)$add(1)$sum\n#&gt; Adding 10\n#&gt; Adding 1\n#&gt; [1] 11\n\n$add() anula la implementación de la superclase, pero aún podemos delegar a la implementación de la superclase usando super$. (Esto es análogo a NextMethod() en S3, como se explica en la Sección 13.6.) Cualquier método que no se invalide utilizará la implementación en la clase principal.\n\n\n14.2.5 Introspección\n\nCada objeto R6 tiene una clase S3 que refleja su jerarquía de clases R6. Esto significa que la forma más fácil de determinar la clase (y todas las clases de las que hereda) es usar class():\n\nclass(hadley2)\n#&gt; [1] \"Person\" \"R6\"\n\nLa jerarquía S3 incluye la clase base “R6”. Esto proporciona un comportamiento común, incluido un método print.R6() que llama a $print(), como se describe arriba.\n Puede enumerar todos los métodos y campos con names():\n\nnames(hadley2)\n#&gt; [1] \".__enclos_env__\" \"age\"             \"name\"            \"clone\"          \n#&gt; [5] \"print\"           \"initialize\"\n\nDefinimos $name, $age, $print e $initialize. Como sugiere el nombre, .__enclos_env__ es un detalle de implementación interna que no debe tocar; volveremos a $clone() en la Sección 14.4.\n\n\n14.2.6 Ejercicios\n\nCree una cuenta bancaria clase R6 que almacene un saldo y le permita depositar y retirar dinero. Cree una subclase que arroje un error si intenta entrar en sobregiro. Cree otra subclase que le permita entrar en sobregiro, pero le cobre una tarifa.\nCree una clase R6 que represente un mazo de cartas barajado. Deberías poder sacar cartas del mazo con $draw(n), devolver todas las cartas al mazo y volver a barajar con $reshuffle(). Use el siguiente código para hacer un vector de tarjetas.\n\nsuit &lt;- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue &lt;- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards &lt;- paste0(rep(value, 4), suit)\n\n¿Por qué no puedes modelar una cuenta bancaria o una baraja de cartas con una clase S3?\nCree una clase R6 que le permita obtener y establecer la zona horaria actual. Puede acceder a la zona horaria actual con Sys.timezone() y configurarla con Sys.setenv(TZ = \"newtimezone\"). Al configurar la zona horaria, asegúrese de que la nueva zona horaria esté en la lista proporcionada por OlsonNames().\nCree una clase R6 que administre el directorio de trabajo actual. Debe tener los métodos $get() y $set().\n¿Por qué no puede modelar la zona horaria o el directorio de trabajo actual con una clase S3?\n¿Sobre qué tipo base se construyen los objetos R6? ¿Qué atributos tienen?",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R6</span>"
    ]
  },
  {
    "objectID": "R6.html#sec-r6-access",
    "href": "R6.html#sec-r6-access",
    "title": "14  R6",
    "section": "14.3 Control de acceso",
    "text": "14.3 Control de acceso\n\nR6Class() tiene otros dos argumentos que funcionan de manera similar a public:\n\nprivate te permite crear campos y métodos que solo están disponibles dentro de la clase, no fuera de ella.\nactivo le permite usar funciones de acceso para definir campos dinámicos o activos.\n\nEstos se describen en las siguientes secciones.\n\n14.3.1 Privacidad\n\nCon R6 puedes definir campos y métodos privados, elementos a los que solo se puede acceder desde dentro de la clase, no desde fuera3. Hay dos cosas que debe saber para aprovechar los elementos privados:\n\nEl argumento ‘privado’ de ‘R6Class’ funciona de la misma manera que el argumento ‘publico’: le da una lista con nombre de métodos (funciones) y campos (todo lo demás).\nLos campos y métodos definidos en private están disponibles dentro de los métodos que usan private$ en lugar de self$. No puede acceder a campos o métodos privados fuera de la clase.\n\nPara concretar esto, podríamos hacer que los campos $age y $name de la clase Persona sean privados. Con esta definición de Person solo podemos establecer $age y $name durante la creación del objeto, y no podemos acceder a sus valores desde fuera de la clase.\n\nPerson &lt;- R6Class(\"Person\", \n  public = list(\n    initialize = function(name, age = NA) {\n      private$name &lt;- name\n      private$age &lt;- age\n    },\n    print = function(...) {\n      cat(\"Person: \\n\")\n      cat(\"  Name: \", private$name, \"\\n\", sep = \"\")\n      cat(\"  Age:  \", private$age, \"\\n\", sep = \"\")\n    }\n  ),\n  private = list(\n    age = NA,\n    name = NULL\n  )\n)\n\nhadley3 &lt;- Person$new(\"Hadley\")\nhadley3\n#&gt; Person: \n#&gt;   Name: Hadley\n#&gt;   Age:  NA\nhadley3$name\n#&gt; NULL\n\nLa distinción entre campos públicos y privados es importante cuando crea redes complejas de clases y desea dejar lo más claro posible qué está bien que otros accedan. Cualquier cosa que sea privada puede refactorizarse más fácilmente porque sabe que otros no confían en ella. Los métodos privados tienden a ser menos importantes en R en comparación con otros lenguajes de programación porque las jerarquías de objetos en R tienden a ser más simples.\n\n\n14.3.2 Campos activos\n \nLos campos activos le permiten definir componentes que parecen campos desde el exterior, pero se definen con funciones, como métodos. Los campos activos se implementan mediante enlaces activos (Sección 7.2.6). Cada enlace activo es una función que toma un único argumento: value. Si el argumento es missing(), se está recuperando el valor; de lo contrario, se está modificando.\nPor ejemplo, podría crear un campo activo random que devuelva un valor diferente cada vez que acceda a él:\n\nRando &lt;- R6::R6Class(\"Rando\", active = list(\n  random = function(value) {\n    if (missing(value)) {\n      runif(1)  \n    } else {\n      stop(\"Can't set `$random`\", call. = FALSE)\n    }\n  }\n))\nx &lt;- Rando$new()\nx$random\n#&gt; [1] 0.0808\nx$random\n#&gt; [1] 0.834\nx$random\n#&gt; [1] 0.601\n\n Los campos activos son especialmente útiles junto con los campos privados, ya que permiten implementar componentes que parecen campos desde el exterior pero proporcionan comprobaciones adicionales. Por ejemplo, podemos usarlos para crear un campo age de solo lectura y para asegurarnos de que name sea un vector de caracteres de longitud 1.\n\nPerson &lt;- R6Class(\"Person\", \n  private = list(\n    .age = NA,\n    .name = NULL\n  ),\n  active = list(\n    age = function(value) {\n      if (missing(value)) {\n        private$.age\n      } else {\n        stop(\"`$age` is read only\", call. = FALSE)\n      }\n    },\n    name = function(value) {\n      if (missing(value)) {\n        private$.name\n      } else {\n        stopifnot(is.character(value), length(value) == 1)\n        private$.name &lt;- value\n        self\n      }\n    }\n  ),\n  public = list(\n    initialize = function(name, age = NA) {\n      private$.name &lt;- name\n      private$.age &lt;- age\n    }\n  )\n)\n\nhadley4 &lt;- Person$new(\"Hadley\", age = 38)\nhadley4$name\n#&gt; [1] \"Hadley\"\nhadley4$name &lt;- 10\n#&gt; Error in (function (value) : is.character(value) is not TRUE\nhadley4$age &lt;- 20\n#&gt; Error: `$age` is read only\n\n\n\n14.3.3 Ejercicios\n\nCree una clase de cuenta bancaria que le impida establecer directamente el saldo de la cuenta, pero aún puede retirar y depositar. Lanza un error si intentas entrar en sobregiro.\nCree una clase con un campo $password de solo escritura. Debería tener el método $check_password(password) que devuelva TRUE o FALSE, pero no debería haber forma de ver la contraseña completa.\nExtienda la clase Rando con otro enlace activo que le permita acceder al valor aleatorio anterior. Asegúrese de que el enlace activo sea la única forma de acceder al valor.\n¿Pueden las subclases acceder a campos/métodos privados desde su padre? Haz un experimento para averiguarlo.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R6</span>"
    ]
  },
  {
    "objectID": "R6.html#sec-r6-semantics",
    "href": "R6.html#sec-r6-semantics",
    "title": "14  R6",
    "section": "14.4 Semántica de referencia",
    "text": "14.4 Semántica de referencia\n\nUna de las grandes diferencias entre R6 y la mayoría de los demás objetos es que tienen semántica de referencia. La consecuencia principal de la semántica de referencia es que los objetos no se copian cuando se modifican:\n\ny1 &lt;- Accumulator$new() \ny2 &lt;- y1\n\ny1$add(10)\nc(y1 = y1$sum, y2 = y2$sum)\n#&gt; y1 y2 \n#&gt; 10 10\n\nEn cambio, si desea una copia, deberá explícitamente $clone() el objeto:\n\ny1 &lt;- Accumulator$new() \ny2 &lt;- y1$clone()\n\ny1$add(10)\nc(y1 = y1$sum, y2 = y2$sum)\n#&gt; y1 y2 \n#&gt; 10  0\n\n($clone() no clona recursivamente objetos R6 anidados. Si quieres eso, tendrás que usar $clone(deep = TRUE).)\nHay otras tres consecuencias menos obvias:\n\nEs más difícil razonar sobre el código que usa objetos R6 porque necesita comprender más contexto.\nTiene sentido pensar en cuándo se elimina un objeto R6 y puede escribir $finalize() para complementar el $initialize().\nSi uno de los campos es un objeto R6, debe crearlo dentro $initialize(), no R6Class().\n\nEstas consecuencias se describen con más detalle a continuación.\n\n14.4.1 Razonamiento\nEn general, la semántica de referencia hace que sea más difícil razonar sobre el código. Tome este ejemplo muy simple:\n\nx &lt;- list(a = 1)\ny &lt;- list(b = 2)\n\nz &lt;- f(x, y)\n\nPara la gran mayoría de las funciones, sabes que la línea final solo modifica z.\nTome un ejemplo similar que usa una clase de referencia List imaginaria:\n\nx &lt;- List$new(a = 1)\ny &lt;- List$new(b = 2)\n\nz &lt;- f(x, y)\n\nLa línea final es mucho más difícil de razonar: si f() llama a métodos de x o y, podría modificarlos así como z. Este es el mayor inconveniente potencial de R6 y debe tener cuidado de evitarlo escribiendo funciones que devuelvan un valor o modifiquen sus entradas R6, pero no ambos. Dicho esto, hacer ambas cosas puede conducir a un código sustancialmente más simple en algunos casos, y discutiremos esto más adelante en la Sección 16.3.2).\n\n\n14.4.2 Finalizador\n \nUna propiedad útil de la semántica de referencia es que tiene sentido pensar cuándo se finaliza un objeto R6, es decir, cuándo se elimina. Esto no tiene sentido para la mayoría de los objetos porque la semántica de copiar al modificar significa que puede haber muchas versiones transitorias de un objeto, como se menciona en la Sección 2.6. Por ejemplo, lo siguiente crea dos objetos de factor: el segundo se crea cuando se modifican los niveles, dejando que el primero sea destruido por el recolector de basura.\n\nx &lt;- factor(c(\"a\", \"b\", \"c\"))\nlevels(x) &lt;- c(\"c\", \"b\", \"a\")\n\nDado que los objetos R6 no se copian al modificarse, solo se eliminan una vez, y tiene sentido pensar en $finalize() como un complemento de $initialize(). Los finalizadores generalmente juegan un papel similar a on.exit() (como se describe en la Sección 6.7.4), limpiando cualquier recurso creado por el inicializador. Por ejemplo, la siguiente clase envuelve un archivo temporal y lo elimina automáticamente cuando finaliza la clase.\n\nTemporaryFile &lt;- R6Class(\"TemporaryFile\", list(\n  path = NULL,\n  initialize = function() {\n    self$path &lt;- tempfile()\n  },\n  finalize = function() {\n    message(\"Cleaning up \", self$path)\n    unlink(self$path)\n  }\n))\n\nEl método finalize se ejecutará cuando se elimine el objeto (o más precisamente, por la primera recolección de elementos no utilizados después de que el objeto se haya desvinculado de todos los nombres) o cuando R salga. Esto significa que el finalizador se puede llamar de manera efectiva en cualquier parte de su código R y, por lo tanto, es casi imposible razonar sobre el código del finalizador que toca las estructuras de datos compartidas. Evite estos posibles problemas utilizando únicamente el finalizador para limpiar los recursos privados asignados por el inicializador.\n\ntf &lt;- TemporaryFile$new()\nrm(tf)\n#&gt; Cleaning up /tmp/Rtmpk73JdI/file155f31d8424bd\n\n\n\n14.4.3 Campos de R6\n\nUna consecuencia final de la semántica de referencia puede surgir donde no lo espera. Si usa una clase R6 como el valor predeterminado de un campo, ¡se compartirá entre todas las instancias del objeto! Toma el siguiente código: queremos crear una base de datos temporal cada vez que llamamos a TemporaryDatabase$new(), pero el código actual siempre usa la misma ruta.\n\nTemporaryDatabase &lt;- R6Class(\"TemporaryDatabase\", list(\n  con = NULL,\n  file = TemporaryFile$new(),\n  initialize = function() {\n    self$con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n  },\n  finalize = function() {\n    DBI::dbDisconnect(self$con)\n  }\n))\n\ndb_a &lt;- TemporaryDatabase$new()\ndb_b &lt;- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#&gt; [1] TRUE\n\n(Si está familiarizado con Python, esto es muy similar al problema del “argumento predeterminado mutable”).\nEl problema surge porque TemporaryFile$new() se llama solo una vez cuando se define la clase TemporaryDatabase. Para solucionar el problema, debemos asegurarnos de que se llame cada vez que se llame a TemporaryDatabase$new(), es decir, debemos ponerlo en $initialize():\n\nTemporaryDatabase &lt;- R6Class(\"TemporaryDatabase\", list(\n  con = NULL,\n  file = NULL,\n  initialize = function() {\n    self$file &lt;- TemporaryFile$new()\n    self$con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n  },\n  finalize = function() {\n    DBI::dbDisconnect(self$con)\n  }\n))\n\ndb_a &lt;- TemporaryDatabase$new()\ndb_b &lt;- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#&gt; [1] FALSE\n\n\n\n14.4.4 Ejercicios\n\nCree una clase que le permita escribir una línea en un archivo específico. Debe abrir una conexión al archivo en $initialize(), agregar una línea usando cat() en $append_line() y cerrar la conexión en $finalize().",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R6</span>"
    ]
  },
  {
    "objectID": "R6.html#sec-why-r6",
    "href": "R6.html#sec-why-r6",
    "title": "14  R6",
    "section": "14.5 ¿Por qué R6?",
    "text": "14.5 ¿Por qué R6?\n \nR6 es muy similar a un sistema OO incorporado llamado clases de referencia, o RC para abreviar. Prefiero R6 a RC porque:\n\nR6 es mucho más simple. Tanto R6 como RC están construidos sobre entornos, pero mientras que R6 usa S3, RC usa S4. Esto significa que para comprender completamente RC, debe comprender cómo funciona el S4 más complicado.\nR6 tiene documentación completa en línea en https://r6.r-lib.org.\nR6 tiene un mecanismo más simple para la subclasificación de paquetes cruzados, que simplemente funciona sin que tengas que pensar en ello. Para RC, lea los detalles en la sección “Métodos externos; Superclases entre paquetes” de ?setRefClass.\nRC mezcla variables y campos en la misma pila de entornos para que obtenga (field) y establezca (field &lt;&lt;- value) campos como valores regulares. R6 coloca los campos en un entorno separado para que obtenga (self$field) y establezca (self$field &lt;- value) con un prefijo. El enfoque R6 es más detallado, pero me gusta porque es más explícito.\nR6 es mucho más rápido que RC. En general, la velocidad de envío del método no es importante fuera de los micropuntos de referencia. Sin embargo, RC es bastante lento y cambiar de RC a R6 condujo a una mejora sustancial del rendimiento en el paquete brillante. Para obtener más detalles, consulte vignette(\"Rendimiento\", \"R6\").\nRC está vinculado a R. Eso significa que si se corrigen errores, solo puede aprovechar las correcciones al solicitar una versión más nueva de R. Esto dificulta los paquetes (como los del tidyverse) que necesitan funcionar en muchos R versiones.\nFinalmente, debido a que las ideas que subyacen en R6 y RC son similares, solo requerirá una pequeña cantidad de esfuerzo adicional para aprender RC si es necesario.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R6</span>"
    ]
  },
  {
    "objectID": "R6.html#footnotes",
    "href": "R6.html#footnotes",
    "title": "14  R6",
    "section": "",
    "text": "Eso significa que si está creando R6 en un paquete, solo necesita asegurarse de que esté listado en el campo Imports de DESCRIPCIÓN. No hay necesidad de importar el paquete a NAMESPACE.↩︎\nA diferencia de Python, R6 proporciona automáticamente la variable self y no forma parte de la firma del método.↩︎\nDebido a que R es un lenguaje tan flexible, técnicamente aún es posible acceder a valores privados, pero tendrá que esforzarse mucho más, profundizando en los detalles de la implementación de R6.↩︎",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R6</span>"
    ]
  },
  {
    "objectID": "S4.html",
    "href": "S4.html",
    "title": "15  S4",
    "section": "",
    "text": "15.1 Introducción\nS4 proporciona un enfoque formal para la programación orientada a objetos funcional. Las ideas subyacentes son similares a S3 (el tema del Capítulo 13), pero la implementación es mucho más estricta y utiliza funciones especializadas para crear clases (setClass()), genéricos (setGeneric()) y métodos (setMethod()). Además, S4 proporciona herencia múltiple (es decir, una clase puede tener varios padres) y envío múltiple (es decir, el envío del método puede usar la clase de varios argumentos).\nUn nuevo componente importante de S4 es la ranura, un componente con nombre del objeto al que se accede mediante el operador de subconjunto especializado @. El conjunto de ranuras y sus clases forma una parte importante de la definición de una clase S4.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "S4.html#introducción",
    "href": "S4.html#introducción",
    "title": "15  S4",
    "section": "",
    "text": "Estructura\n\nLa Sección 15.2 brinda una descripción general rápida de los componentes principales de S4: clases, genéricos y métodos.\nLa Sección 15.3 se sumerge en los detalles de las clases de S4, incluidos prototipos, constructores, ayudantes y validadores.\nLa Sección 15.4 le muestra cómo crear nuevos genéricos S4 y cómo proporcionar métodos a esos genéricos. También aprenderá acerca de las funciones de acceso que están diseñadas para permitir que los usuarios inspeccionen y modifiquen las ranuras de objetos de manera segura.\nLa Sección 15.5 se sumerge en los detalles completos del envío de métodos en S4. La idea básica es simple, pero rápidamente se vuelve más compleja una vez que se combinan la herencia múltiple y el envío múltiple.\nLa Sección 15.6 analiza la interacción entre S4 y S3 y le muestra cómo usarlos juntos.\n\n\n\nAprendiendo más\nAl igual que los otros capítulos de OO, el enfoque aquí será cómo funciona S4, no cómo implementarlo de manera más efectiva. Si desea usarlo en la práctica, hay dos desafíos principales:\n\nNo hay una referencia que responda a todas sus preguntas sobre S4.\nLa documentación integrada de R a veces choca con las mejores prácticas de la comunidad.\n\nA medida que avanza hacia un uso más avanzado, deberá reunir la información necesaria leyendo detenidamente la documentación, haciendo preguntas sobre StackOverflow y realizando experimentos. Algunas recomendaciones:\n\nLa comunidad de bioconductores es un usuario de S4 desde hace mucho tiempo y ha producido gran parte del mejor material sobre su uso efectivo. Comience con Clases y métodos de S4 impartido por Martin Morgan y Hervé Pagès, o busque uno más nuevo versión en [Materiales del curso de bioconductores] (https://bioconductor.org/help/course-materials/).\nMartin Morgan es un ex miembro de R-core y líder del proyecto de Bioconductor. Es un experto mundial en el uso práctico de S4 y recomiendo leer todo lo que ha escrito al respecto, comenzando con las preguntas que ha respondido en stackoverflow.\nJohn Chambers es el autor del sistema S4 y proporciona una descripción general de su motivación y contexto histórico en Programación orientada a objetos, programación funcional y R (Chambers 2014). Para una exploración más completa de S4, consulte su libro Software for Data Analysis (Chambers 2008).\n\n\n\nRequisitos previos\nTodas las funciones relacionadas con S4 viven en el paquete de métodos. Este paquete siempre está disponible cuando ejecuta R de forma interactiva, pero es posible que no esté disponible cuando ejecuta R en modo por lotes, es decir, desde Rscript1. Por esta razón, es una buena idea llamar a library(methods) siempre que use S4. Esto también indica al lector que utilizará el sistema de objetos S4.\n\nlibrary(methods)",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "S4.html#sec-s4-basics",
    "href": "S4.html#sec-s4-basics",
    "title": "15  S4",
    "section": "15.2 Lo escencial",
    "text": "15.2 Lo escencial\nComenzaremos con una descripción general rápida de los componentes principales de S4. Una clase de S4 se define llamando a setClass() con el nombre de la clase y una definición de sus ranuras, y los nombres y clases de los datos de la clase:\n\nsetClass(\"Person\", \n  slots = c(\n    name = \"character\", \n    age = \"numeric\"\n  )\n)\n\nUna vez que se define la clase, puede construir nuevos objetos a partir de ella llamando a new() con el nombre de la clase y un valor para cada ranura:\n\njohn &lt;- new(\"Person\", name = \"John Smith\", age = NA_real_)\n\n \nDado un objeto S4, puede ver su clase con is() y acceder a las ranuras con @ (equivalente a $) y slot() (equivalente a [[):\n\nis(john)\n#&gt; [1] \"Person\"\njohn@name\n#&gt; [1] \"John Smith\"\nslot(john, \"age\")\n#&gt; [1] NA\n\nEn general, solo debe usar @ en sus métodos. Si está trabajando con la clase de otra persona, busque funciones de accesorio que le permitan establecer y obtener valores de ranura de forma segura. Como desarrollador de una clase, también debe proporcionar sus propias funciones de acceso. Los accesores suelen ser genéricos de S4 que permiten que varias clases compartan la misma interfaz externa.\nAquí crearemos un setter y getter para el espacio age creando primero genéricos con setGeneric():\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\"))\n\nY luego definiendo métodos con setMethod():\n\nsetMethod(\"age\", \"Person\", function(x) x@age)\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  x\n})\n\nage(john) &lt;- 50\nage(john)\n#&gt; [1] 50\n\nSi está utilizando una clase S4 definida en un paquete, puede obtener ayuda con class?Person. Para obtener ayuda para un método, coloque ? delante de una llamada (por ejemplo, ?age(john)) y ? usará la clase de los argumentos para averiguar qué archivo de ayuda necesita.\nFinalmente, puede usar las funciones de sloop para identificar los objetos y genéricos de S4 que se encuentran en la naturaleza:\n\nsloop::otype(john)\n#&gt; [1] \"S4\"\nsloop::ftype(age)\n#&gt; [1] \"S4\"      \"generic\"\n\n\n15.2.1 Ejercicios\n\nlubridate::period() devuelve una clase S4. ¿Qué ranuras tiene? ¿Qué clase es cada ranura? ¿Qué accesorios proporciona?\n¿De qué otras formas puede encontrar ayuda para un método? Lea ?\"?\" y resuma los detalles.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "S4.html#sec-s4-classes",
    "href": "S4.html#sec-s4-classes",
    "title": "15  S4",
    "section": "15.3 Clases",
    "text": "15.3 Clases\n \nPara definir una clase S4, llama a setClass() con tres argumentos:\n\nLa clase nombre. Por convención, los nombres de clase de S4 usan UpperCamelCase.\nUn vector de caracteres con nombre que describe los nombres y las clases de las ranuras (campos). Por ejemplo, una persona puede estar representada por un nombre de personaje y una edad numérica: c(name = \"personaje\", age = \"numérico\"). La pseudoclase ANY permite que una ranura acepte objetos de cualquier tipo.\nUn prototipo, una lista de valores predeterminados para cada ranura. Técnicamente, el prototipo es opcional2, pero siempre debes proporcionarlo.\n\nEl siguiente código ilustra los tres argumentos mediante la creación de una clase Person con el carácter name y las ranuras numéricas age.\n\nsetClass(\"Person\", \n  slots = c(\n    name = \"character\", \n    age = \"numeric\"\n  ), \n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\nme &lt;- new(\"Person\", name = \"Hadley\")\nstr(me)\n#&gt; Formal class 'Person' [package \".GlobalEnv\"] with 2 slots\n#&gt;   ..@ name: chr \"Hadley\"\n#&gt;   ..@ age : num NA\n\n\n15.3.1 Herencia\n \nHay otro argumento importante para setClass(): contains. Esto especifica una clase (o clases) de las que heredar las ranuras y el comportamiento. Por ejemplo, podemos crear una clase Employee que herede de la clase Person, agregando un espacio adicional que describa su boss.\n\nsetClass(\"Employee\", \n  contains = \"Person\", \n  slots = c(\n    boss = \"Person\"\n  ),\n  prototype = list(\n    boss = new(\"Person\")\n  )\n)\n\nstr(new(\"Employee\"))\n#&gt; Formal class 'Employee' [package \".GlobalEnv\"] with 3 slots\n#&gt;   ..@ boss:Formal class 'Person' [package \".GlobalEnv\"] with 2 slots\n#&gt;   .. .. ..@ name: chr NA\n#&gt;   .. .. ..@ age : num NA\n#&gt;   ..@ name: chr NA\n#&gt;   ..@ age : num NA\n\nsetClass() tiene otros 9 argumentos pero están en desuso o no se recomiendan.\n\n\n15.3.2 Introspección\n \nPara determinar de qué clases hereda un objeto, usa is():\n\nis(new(\"Person\"))\n#&gt; [1] \"Person\"\nis(new(\"Employee\"))\n#&gt; [1] \"Employee\" \"Person\"\n\nPara probar si un objeto hereda de una clase específica, usa el segundo argumento de is():\n\nis(john, \"Person\")\n#&gt; [1] TRUE\n\n\n\n15.3.3 Redefinición\nEn la mayoría de los lenguajes de programación, la definición de clase ocurre en tiempo de compilación y la construcción de objetos ocurre más tarde, en tiempo de ejecución. En R, sin embargo, tanto la definición como la construcción ocurren en tiempo de ejecución. Cuando llamas a setClass(), estás registrando una definición de clase en una variable global (oculta). Al igual que con todas las funciones de modificación de estado, debe usar setClass() con cuidado. Es posible crear objetos no válidos si redefine una clase después de haber creado una instancia de un objeto:\n\nsetClass(\"A\", slots = c(x = \"numeric\"))\na &lt;- new(\"A\", x = 10)\n\nsetClass(\"A\", slots = c(a_different_slot = \"numeric\"))\na\n#&gt; An object of class \"A\"\n#&gt; Slot \"a_different_slot\":\n#&gt; Error in slot(object, what): no slot of name \"a_different_slot\" for this object of class \"A\"\n\nEsto puede causar confusión durante la creación interactiva de nuevas clases. (Las clases R6 tienen el mismo problema, como se describe en la Sección 14.2.2.)\n\n\n15.3.4 Ayudante\n \nnew() es un constructor de bajo nivel adecuado para que lo use usted, el desarrollador. Las clases orientadas al usuario siempre deben combinarse con un asistente fácil de usar. Un ayudante siempre debe:\n\nTener el mismo nombre que la clase, p. myclass().\nTenga una interfaz de usuario cuidadosamente diseñada con valores predeterminados cuidadosamente seleccionados y conversiones útiles.\nCree mensajes de error cuidadosamente elaborados y adaptados a un usuario final.\nTermine llamando a methods::new().\n\nLa clase Person es tan simple que un ayudante es casi superfluo, pero podemos usarlo para definir claramente el contrato: age es opcional pero name es obligatorio. También forzaremos la edad a un doble para que el ayudante también funcione cuando se pasa un número entero.\n\nPerson &lt;- function(name, age = NA) {\n  age &lt;- as.double(age)\n  \n  new(\"Person\", name = name, age = age)\n}\n\nPerson(\"Hadley\")\n#&gt; An object of class \"Person\"\n#&gt; Slot \"name\":\n#&gt; [1] \"Hadley\"\n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] NA\n\n\n\n15.3.5 Validador\n \nEl constructor verifica automáticamente que las ranuras tengan las clases correctas:\n\nPerson(mtcars)\n#&gt; Error in validObject(.Object): invalid class \"Person\" object: invalid object for slot \"name\" in class \"Person\": got class \"data.frame\", should be or extend class \"character\"\n\nDeberá implementar verificaciones más complicadas (es decir, verificaciones que involucren longitudes o múltiples ranuras) usted mismo. Por ejemplo, es posible que queramos dejar en claro que la clase Person es una clase vectorial y puede almacenar datos sobre varias personas. Eso no está claro actualmente porque @name y @age pueden tener diferentes longitudes:\n\nPerson(\"Hadley\", age = c(30, 37))\n#&gt; An object of class \"Person\"\n#&gt; Slot \"name\":\n#&gt; [1] \"Hadley\"\n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] 30 37\n\nPara hacer cumplir estas restricciones adicionales, escribimos un validador con setValidity(). Toma una clase y una función que devuelve TRUE si la entrada es válida y, de lo contrario, devuelve un vector de caracteres que describe los problemas:\n\nsetValidity(\"Person\", function(object) {\n  if (length(object@name) != length(object@age)) {\n    \"@name and @age must be same length\"\n  } else {\n    TRUE\n  }\n})\n\nAhora ya no podemos crear un objeto no válido:\n\nPerson(\"Hadley\", age = c(30, 37))\n#&gt; Error in validObject(.Object): invalid class \"Person\" object: @name and @age must be same length\n\nNB: El método de validez solo es llamado automáticamente por new(), por lo que aún puede crear un objeto no válido modificándolo:\n\nalex &lt;- Person(\"Alex\", age = 30)\nalex@age &lt;- 1:10\n\n\nPuedes verificar explícitamente la validez tú mismo llamando a validObject():\n\nvalidObject(alex)\n#&gt; Error in validObject(alex): invalid class \"Person\" object: @name and @age must be same length\n\nEn la Sección 15.4.4, usaremos validObject() para crear accesores que no pueden crear objetos no válidos.\n\n\n15.3.6 Ejercicios\n\nExtiende la clase Person con campos para que coincidan con utils::person(). Piense en qué ranuras necesitará, qué clase debe tener cada ranura y qué necesitará verificar en su método de validez.\n¿Qué sucede si define una nueva clase S4 que no tiene ranuras? (Sugerencia: lea acerca de las clases virtuales en ?setClass).\nImagine que iba a volver a implementar factores, fechas y marcos de datos en S4. Esboce las llamadas setClass() que usaría para definir las clases. Piense en slots y prototypes apropiados.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "S4.html#sec-s4-generics",
    "href": "S4.html#sec-s4-generics",
    "title": "15  S4",
    "section": "15.4 Genéricos y métodos",
    "text": "15.4 Genéricos y métodos\n \nEl trabajo de un genérico es realizar el envío de métodos, es decir, encontrar la implementación específica para la combinación de clases pasadas al genérico. Aquí aprenderá a definir métodos y genéricos de S4; luego, en la siguiente sección, exploraremos con precisión cómo funciona el envío de métodos de S4.\nPara crear un nuevo S4 genérico, llame a setGeneric() con una función que llame a standardGeneric():\n\nsetGeneric(\"myGeneric\", function(x) standardGeneric(\"myGeneric\"))\n\nPor convención, los nuevos genéricos de S4 deben usar lowerCamelCase.\nEs una mala práctica usar {} en el genérico, ya que desencadena un caso especial que es más costoso y, en general, es mejor evitarlo.\n\n# Don't do this!\nsetGeneric(\"myGeneric\", function(x) {\n  standardGeneric(\"myGeneric\")\n})\n\n\n15.4.1 Firma\n\nAl igual que setClass(), setGeneric() tiene muchos otros argumentos. Solo hay uno que debe conocer: signature. Esto le permite controlar los argumentos que se utilizan para el envío de métodos. Si no se proporciona signature, se utilizan todos los argumentos (excepto ...). Ocasionalmente, es útil eliminar argumentos del envío. Esto le permite requerir que los métodos proporcionen argumentos como verbose = TRUE o quiet = FALSE, pero no toman parte en el envío.\n\nsetGeneric(\"myGeneric\", \n  function(x, ..., verbose = TRUE) standardGeneric(\"myGeneric\"),\n  signature = \"x\"\n)\n\n\n\n15.4.2 Métodos\n\n \nUn genérico no es útil sin algunos métodos, y en S4 se definen métodos con setMethod(). Hay tres argumentos importantes: el nombre del genérico, el nombre de la clase y el método en sí.\n\nsetMethod(\"myGeneric\", \"Person\", function(x) {\n  # method implementation\n})\n\nMás formalmente, el segundo argumento de setMethod() se llama signature. En S4, a diferencia de S3, la firma puede incluir múltiples argumentos. Esto hace que el envío de métodos en S4 sea sustancialmente más complicado, pero evita tener que implementar el envío doble como un caso especial. Hablaremos más sobre el envío múltiple en la siguiente sección. setMethod() tiene otros argumentos, pero nunca debes usarlos.\nPara listar todos los métodos que pertenecen a un genérico, o que están asociados con una clase, use methods(\"generic\") o methods(class = \"class\"); para encontrar la implementación de un método específico, use selectMethod(\"generic\", \"class\").\n\n\n15.4.3 Mostrar método\n\n\nEl método S4 más comúnmente definido que controla la impresión es show(), que controla cómo aparece el objeto cuando se imprime. Para definir un método para un genérico existente, primero debe determinar los argumentos. Puede obtenerlos de la documentación o mirando los args() del genérico:\n\nargs(getGeneric(\"show\"))\n#&gt; function (object) \n#&gt; NULL\n\nNuestro método show necesita tener un solo argumento object:\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(is(object)[[1]], \"\\n\",\n      \"  Name: \", object@name, \"\\n\",\n      \"  Age:  \", object@age, \"\\n\",\n      sep = \"\"\n  )\n})\njohn\n#&gt; Person\n#&gt;   Name: John Smith\n#&gt;   Age:  50\n\n\n\n15.4.4 Accesorios\n\nLas ranuras deben considerarse un detalle de implementación interna: pueden cambiar sin previo aviso y el código de usuario debe evitar acceder a ellas directamente. En su lugar, todas las ranuras accesibles para el usuario deben ir acompañadas de un par de accesorios. Si la ranura es única para la clase, esto puede ser solo una función:\n\nperson_name &lt;- function(x) x@name\n\nSin embargo, por lo general, definirá un genérico para que varias clases puedan usar la misma interfaz:\n\nsetGeneric(\"name\", function(x) standardGeneric(\"name\"))\nsetMethod(\"name\", \"Person\", function(x) x@name)\n\nname(john)\n#&gt; [1] \"John Smith\"\n\nSi la ranura también se puede escribir, debe proporcionar una función de establecimiento. Siempre debe incluir validObject() en el setter para evitar que el usuario cree objetos no válidos.\n\nsetGeneric(\"name&lt;-\", function(x, value) standardGeneric(\"name&lt;-\"))\nsetMethod(\"name&lt;-\", \"Person\", function(x, value) {\n  x@name &lt;- value\n  validObject(x)\n  x\n})\n\nname(john) &lt;- \"Jon Smythe\"\nname(john)\n#&gt; [1] \"Jon Smythe\"\n\nname(john) &lt;- letters\n#&gt; Error in validObject(x): invalid class \"Person\" object: @name and @age must be same length\n\n(Si la notación name&lt;- no le resulta familiar, revise la Sección 6.8.)\n\n\n15.4.5 Ejercicios\n\nAgregue accesores age() para la clase Person.\nEn la definición de genérico, ¿por qué es necesario repetir dos veces el nombre del genérico?\n¿Por qué el método show() definido en la Sección 15.4.3 usa is(object)[[1]]? (Sugerencia: intente imprimir la subclase de empleado).\n¿Qué pasa si defines un método con nombres de argumentos diferentes al genérico?",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "S4.html#sec-s4-dispatch",
    "href": "S4.html#sec-s4-dispatch",
    "title": "15  S4",
    "section": "15.5 Método de envío",
    "text": "15.5 Método de envío\n \nEl envío de S4 es complicado porque S4 tiene dos características importantes:\n\nHerencia múltiple, es decir, una clase puede tener múltiples padres,\nEnvío múltiple, es decir, un genérico puede usar múltiples argumentos para elegir un método.\n\nEstas características hacen que S4 sea muy potente, pero también pueden dificultar la comprensión de qué método se seleccionará para una determinada combinación de entradas. En la práctica, mantenga el envío de métodos lo más simple posible evitando la herencia múltiple y reservando el envío múltiple solo cuando sea absolutamente necesario.\nPero es importante describir los detalles completos, por lo que aquí comenzaremos de manera simple con herencia única y despacho único, y avanzaremos hasta los casos más complicados. Para ilustrar las ideas sin atascarse en los detalles, usaremos un gráfico de clase imaginario basado en emoji:\n\n\n\n\n\n\n\n\n\nEmoji nos da nombres de clase muy compactos que evocan las relaciones entre las clases. Debería ser sencillo recordar que 😜 hereda de 😉 que hereda de 😶, y que 😎 hereda tanto de 🕶 como de 🙂.\n\n15.5.1 Envío único\n\nComencemos con el caso más simple: una función genérica que se distribuye en una sola clase con un solo padre. El método de envío aquí es simple, por lo que es un buen lugar para definir las convenciones gráficas que usaremos para los casos más complejos.\n\n\n\n\n\n\n\n\n\nHay dos partes en este diagrama:\n\nLa parte superior, f(...), define el alcance del diagrama. Aquí tenemos un genérico con un argumento, que tiene una jerarquía de clases de tres niveles de profundidad.\nLa parte inferior es el gráfico de métodos y muestra todos los métodos posibles que podrían definirse. Los métodos que existen, es decir, que se han definido con setMethod(), tienen un fondo gris.\n\nPara encontrar el método que se llama, comience con la clase más específica de los argumentos reales, luego siga las flechas hasta que encuentre un método que exista. Por ejemplo, si llamaste a la función con un objeto de la clase 😉, seguirías la flecha hacia la derecha para encontrar el método definido para la clase más general 😶. Si no se encuentra ningún método, el envío del método ha fallado y se genera un error. En la práctica, esto significa que siempre debe definir métodos definidos para los nodos terminales, es decir, los del extremo derecho.\n Hay dos pseudoclases para las que puede definir métodos. Estas se denominan pseudoclases porque en realidad no existen, pero le permiten definir comportamientos útiles. La primera pseudoclase es ANY que coincide con cualquier clase3. Por razones técnicas que veremos más adelante, el enlace al método ANY es más largo que los enlaces entre las otras clases:\n\n\n\n\n\n\n\n\n\n\nLa segunda pseudoclase es MISSING. Si define un método para esta pseudoclase, coincidirá siempre que falte el argumento. No es útil para envío único, pero es importante para funciones como + y - que usan envío doble y se comportan de manera diferente dependiendo de si tienen uno o dos argumentos.\n\n\n15.5.2 Herencia múltiple\n \nLas cosas se complican más cuando la clase tiene varios padres.\n\n\n\n\n\n\n\n\n\nEl proceso básico sigue siendo el mismo: comienza desde la clase real suministrada al genérico, luego sigue las flechas hasta encontrar un método definido. El problema es que ahora hay varias flechas a seguir, por lo que es posible que encuentre varios métodos. Si eso sucede, elige el método más cercano, es decir, requiere viajar con la menor cantidad de flechas.\nNB: Si bien el gráfico de métodos es una poderosa metáfora para comprender el envío de métodos, implementarlo de esta manera sería bastante ineficiente, por lo que el enfoque real que usa S4 es algo diferente. Puede leer los detalles en ?Methods_Details.\n¿Qué sucede si los métodos están a la misma distancia? Por ejemplo, imagina que hemos definido métodos para 🕶 y 🙂, y llamamos al genérico 😎. Tenga en cuenta que no se puede encontrar ningún método para la clase 😶, que resaltaré con un doble contorno rojo.\n\n\n\n\n\n\n\n\n\nEsto se llama método ambiguo, y en los diagramas lo ilustraré con un borde de puntos gruesos. Cuando esto sucede en R, recibirá una advertencia y se elegirá el método para la clase que aparece antes en el alfabeto (esto es efectivamente aleatorio y no se debe confiar en él). Cuando descubra una ambigüedad, siempre debe resolverla proporcionando un método más preciso:\n\n\n\n\n\n\n\n\n\nEl método alternativo ANY aún existe, pero las reglas son un poco más complejas. Como lo indican las líneas punteadas onduladas, el método ANY siempre se considera más lejano que un método para una clase real. Esto significa que nunca contribuirá a la ambigüedad.\n\n\n\n\n\n\n\n\n\nCon herencias múltiples, es difícil evitar simultáneamente la ambigüedad, asegurarse de que cada método de terminal tenga una implementación y minimizar la cantidad de métodos definidos (para beneficiarse de OOP). Por ejemplo, de las seis formas de definir solo dos métodos para esta llamada, solo una está libre de problemas. Por esta razón, recomiendo utilizar la herencia múltiple con sumo cuidado: deberá pensar detenidamente en el gráfico del método y planificar en consecuencia.\n\n\n\n\n\n\n\n\n\n\n\n15.5.3 Envío múltiple\n \nUna vez que comprenda la herencia múltiple, comprender el envío múltiple es sencillo. Sigue varias flechas de la misma manera que antes, pero ahora cada método se especifica mediante dos clases (separadas por una coma).\n\n\n\n\n\n\n\n\n\nNo voy a mostrar ejemplos de despacho en más de dos argumentos, pero puede seguir los principios básicos para generar sus propios gráficos de métodos.\nLa principal diferencia entre la herencia múltiple y el envío múltiple es que hay muchas más flechas a seguir. El siguiente diagrama muestra cuatro métodos definidos que producen dos casos ambiguos:\n\n\n\n\n\n\n\n\n\nEl envío múltiple tiende a ser menos complicado para trabajar que la herencia múltiple porque generalmente hay menos combinaciones de clases de terminales. En este ejemplo, solo hay uno. Eso significa que, como mínimo, puede definir un solo método y tener un comportamiento predeterminado para todas las entradas.\n\n\n15.5.4 Despacho múltiple y herencia múltiple\nPor supuesto, puede combinar envío múltiple con herencia múltiple:\n\n\n\n\n\n\n\n\n\nUn caso aún más complicado se despacha en dos clases, las cuales tienen herencia múltiple:\n\n\n\n\n\n\n\n\n\nA medida que el gráfico del método se vuelve más y más complicado, se vuelve más y más difícil predecir qué método se llamará dada una combinación de entradas, y se vuelve más y más difícil asegurarse de que no se ha introducido ambigüedad. Si tiene que dibujar diagramas para averiguar qué método se llamará realmente, es una fuerte indicación de que debe volver atrás y simplificar su diseño.\n\n\n15.5.5 Ejercicios\n\nDibuje el gráfico del método para f(😅, 😽).\nDibuje el gráfico del método para f(😃, 😉, 😙).\nTome el último ejemplo que muestra envío múltiple sobre dos clases que usan herencia múltiple. ¿Qué sucede si define un método para todas las clases de terminal? ¿Por qué el método de envío no nos ahorra mucho trabajo aquí?",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "S4.html#sec-s4-s3",
    "href": "S4.html#sec-s4-s3",
    "title": "15  S4",
    "section": "15.6 S4 y S3",
    "text": "15.6 S4 y S3\n \nAl escribir código S4, a menudo necesitará interactuar con clases y genéricos existentes de S3. Esta sección describe cómo las clases, los métodos y los genéricos de S4 interactúan con el código existente.\n\n15.6.1 Clases\n\nEn slots y contains puede usar clases S4, clases S3 o la clase implícita (Sección 13.7.1) de un tipo base. Para usar una clase S3, primero debe registrarla con setOldClass(). Llame a esta función una vez para cada clase de S3, dándole el atributo de clase. Por ejemplo, la base R ya proporciona las siguientes definiciones:\n\nsetOldClass(\"data.frame\")\nsetOldClass(c(\"ordered\", \"factor\"))\nsetOldClass(c(\"glm\", \"lm\"))\n\nSin embargo, generalmente es mejor ser más específico y proporcionar una definición completa de S4 con slots y un prototype:\n\nsetClass(\"factor\",\n  contains = \"integer\",\n  slots = c(\n    levels = \"character\"\n  ),\n  prototype = structure(\n    integer(),\n    levels = character()\n  )\n)\nsetOldClass(\"factor\", S4Class = \"factor\")\n\nPor lo general, estas definiciones las debe proporcionar el creador de la clase S3. Si intenta crear una clase S4 sobre una clase S3 proporcionada por un paquete, debe solicitar que el mantenedor del paquete agregue esta llamada a su paquete, en lugar de agregarla a su propio código.\nSi un objeto S4 hereda de una clase S3 o un tipo base, tendrá una ranura virtual especial llamada .Data. Esto contiene el tipo base subyacente o el objeto S3: \n\nRangedNumeric &lt;- setClass(\n  \"RangedNumeric\",\n  contains = \"numeric\",\n  slots = c(min = \"numeric\", max = \"numeric\"),\n  prototype = structure(numeric(), min = NA_real_, max = NA_real_)\n)\nrn &lt;- RangedNumeric(1:10, min = 1, max = 10)\nrn@min\n#&gt; [1] 1\nrn@.Data\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nEs posible definir métodos de S3 para genéricos de S4 y métodos de S4 para genéricos de S3 (siempre que haya llamado a setOldClass()). Sin embargo, es más complicado de lo que parece a primera vista, así que asegúrese de leer detenidamente ?Methods_for_S3.\n\n\n15.6.2 Genéricos\n\nAdemás de crear un nuevo genérico desde cero, también es posible convertir un genérico S3 existente en un genérico S4:\n\nsetGeneric(\"mean\")\n\nEn este caso, la función existente se convierte en el método predeterminado (ANY):\n\nselectMethod(\"mean\", \"ANY\")\n#&gt; Method Definition (Class \"derivedDefaultMethod\"):\n#&gt; \n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x56143cec6d00&gt;\n#&gt; &lt;environment: namespace:base&gt;\n#&gt; \n#&gt; Signatures:\n#&gt;         x    \n#&gt; target  \"ANY\"\n#&gt; defined \"ANY\"\n\nNB: setMethod() llamará automáticamente a setGeneric() si el primer argumento aún no es genérico, lo que le permite convertir cualquier función existente en un genérico S4. Está bien convertir un S3 genérico existente a S4, pero debe evitar convertir funciones regulares a genéricos S4 en paquetes porque eso requiere una coordinación cuidadosa si lo hacen varios paquetes.\n\n\n15.6.3 Ejercicios\n\n¿Cómo sería una definición completa de setOldClass() para un factor ordenado (es decir, agregar slots y prototype de la definición anterior)?\nDefina un método length para la clase Person.\n\n\n\n\n\nChambers, John M. 2008. Software for Data Analysis: Programming with R. Springer.\n\n\n———. 2014. «Object-oriented programming, functional programming and R». Statistical Science 29 (2): 167-80. https://projecteuclid.org/download/pdfview_1/euclid.ss/1408368569.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "S4.html#footnotes",
    "href": "S4.html#footnotes",
    "title": "15  S4",
    "section": "",
    "text": "Esta es una peculiaridad histórica introducida porque el paquete de métodos solía tardar mucho tiempo en cargarse y Rscript está optimizado para una invocación rápida de la línea de comandos.↩︎\n?setClass recomienda que evite el argumento prototype, pero esto generalmente se considera un mal consejo.↩︎\nLa pseudoclase ANY de S4 desempeña el mismo papel que la pseudoclase default de S3.↩︎",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>S4</span>"
    ]
  },
  {
    "objectID": "OO-tradeoffs.html",
    "href": "OO-tradeoffs.html",
    "title": "16  Compensaciones",
    "section": "",
    "text": "16.1 Introducción\nAhora conoce los tres conjuntos de herramientas OOP más importantes disponibles en R. Ahora que comprende su funcionamiento básico y los principios que los sustentan, podemos comenzar a comparar y contrastar los sistemas para comprender sus fortalezas y debilidades. Esto le ayudará a elegir el sistema que tiene más probabilidades de resolver nuevos problemas.\nEn general, al elegir un sistema OO, le recomiendo que utilice S3 de forma predeterminada. S3 es simple y se usa ampliamente en base R y CRAN. Si bien está lejos de ser perfecto, sus idiosincrasias se comprenden bien y existen enfoques conocidos para superar la mayoría de las deficiencias. Si tiene experiencia previa en programación, es probable que se incline hacia R6, porque le resultará familiar. Creo que deberías resistirte a esta tendencia por dos razones. En primer lugar, si usa R6, es muy fácil crear una API no idiomática que se sentirá muy extraña para los usuarios nativos de R y tendrá puntos débiles sorprendentes debido a la semántica de referencia. En segundo lugar, si se apega a R6, perderá el aprendizaje de una nueva forma de pensar sobre OOP que le brinda un nuevo conjunto de herramientas para resolver problemas.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Compensaciones</span>"
    ]
  },
  {
    "objectID": "OO-tradeoffs.html#introducción",
    "href": "OO-tradeoffs.html#introducción",
    "title": "16  Compensaciones",
    "section": "",
    "text": "Estructura\n\nLa Sección 16.2 compara S3 y S4. En resumen, S4 es más formal y tiende a requerir una planificación más anticipada. Eso lo hace más adecuado para grandes proyectos desarrollados por equipos, no individualmente.\nLa Sección 16.3 compara S3 y R6. Esta sección es bastante larga porque estos dos sistemas son fundamentalmente diferentes y hay una serie de compensaciones que debe tener en cuenta.\n\n\n\nRequisitos previos\nDebe estar familiarizado con S3, S4 y R6, como se explicó en los tres capítulos anteriores.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Compensaciones</span>"
    ]
  },
  {
    "objectID": "OO-tradeoffs.html#sec-s3-s4",
    "href": "OO-tradeoffs.html#sec-s3-s4",
    "title": "16  Compensaciones",
    "section": "16.2 S4 contra S3",
    "text": "16.2 S4 contra S3\n \nUna vez que haya dominado S3, S4 no es demasiado difícil de entender: las ideas subyacentes son las mismas, S4 es simplemente más formal, más estricto y más detallado. El rigor y la formalidad de S4 lo hacen ideal para equipos grandes. Dado que el propio sistema proporciona más estructura, hay menos necesidad de convenciones y los nuevos contribuyentes no necesitan tanta formación. S4 tiende a requerir un diseño más inicial que S3, y es más probable que esta inversión rinda frutos en proyectos más grandes donde hay más recursos disponibles.\nUn gran esfuerzo de equipo donde S4 se usa con buenos resultados es Bioconductor. Bioconductor es similar a CRAN: es una forma de compartir paquetes entre una audiencia más amplia. Bioconductor es más pequeño que CRAN (~1,300 versus ~10,000 paquetes, julio de 2017) y los paquetes tienden a estar más estrechamente integrados debido al dominio compartido y porque Bioconductor tiene un proceso de revisión más estricto. No se requieren paquetes de bioconductores para usar S4, pero la mayoría lo hará porque las estructuras de datos clave (por ejemplo, SummarizedExperiment, IRanges, DNAStringSet) se construyen usando S4.\nS4 también es una buena opción para sistemas complejos de objetos interrelacionados, y es posible minimizar la duplicación de código mediante la implementación cuidadosa de métodos. El mejor ejemplo de tal sistema es el paquete Matrix (Bates y Maechler 2018). Está diseñado para almacenar y calcular de manera eficiente con muchos tipos diferentes de matrices densas y dispersas. A partir de la versión 1.7.0, define clases 108, funciones genéricas 23 y métodos 1780, y para darle una idea de la complejidad, se muestra un pequeño subconjunto del gráfico de clase en Figura 16.1.\n\n\n\n\n\n\n\n\nFigura 16.1: Un pequeño subconjunto del gráfico de la clase Matrix que muestra la herencia de matrices dispersas. Cada clase concreta hereda de dos padres virtuales: uno que describe cómo se almacenan los datos (C = orientado a columnas, R = orientado a filas, T = etiquetado) y otro que describe cualquier restricción en la matriz (s = simétrico, t = triángulo, g = generales).\n\n\n\n\n\nEste dominio es una buena opción para S4 porque a menudo hay atajos computacionales para combinaciones específicas de matrices dispersas. S4 facilita proporcionar un método general que funcione para todas las entradas y luego proporcionar métodos más especializados donde las entradas permiten una implementación más eficiente. Esto requiere una planificación cuidadosa para evitar la ambigüedad en el envío de métodos, pero la planificación compensa con un mayor rendimiento.\nEl mayor desafío para usar S4 es la combinación de una mayor complejidad y la ausencia de una única fuente de documentación. S4 es un sistema complejo y su uso eficaz en la práctica puede resultar complicado. Esto no sería un gran problema si la documentación de S4 no estuviera dispersa en la documentación, los libros y los sitios web de R. S4 necesita un tratamiento de longitud de libro, pero ese libro (todavía) no existe. (La documentación para S3 no es mejor, pero la falta es menos dolorosa porque S3 es mucho más simple).",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Compensaciones</span>"
    ]
  },
  {
    "objectID": "OO-tradeoffs.html#sec-s3-r6",
    "href": "OO-tradeoffs.html#sec-s3-r6",
    "title": "16  Compensaciones",
    "section": "16.3 R6 contra S3",
    "text": "16.3 R6 contra S3\n \nR6 es un sistema OO profundamente diferente de S3 y S4 porque se basa en objetos encapsulados, en lugar de funciones genéricas. Además, los objetos R6 tienen semántica de referencia, lo que significa que se pueden modificar en su lugar. Estas dos grandes diferencias tienen una serie de consecuencias no obvias que exploraremos aquí:\n\nUn genérico es una función regular, por lo que vive en el espacio de nombres global. Un método R6 pertenece a un objeto, por lo que vive en un espacio de nombres local. Esto influye en cómo pensamos acerca de nombrar.\nLa semántica de referencia de R6 permite que los métodos devuelvan un valor y modifiquen un objeto simultáneamente. Esto resuelve un doloroso problema llamado “estado de subprocesamiento”.\nInvocas un método R6 usando $, que es un operador infijo. Si configura sus métodos correctamente, puede usar cadenas de llamadas a métodos como una alternativa a la canalización.\n\nEstas son compensaciones generales entre OOP funcional y encapsulado, por lo que también sirven como una discusión sobre el diseño del sistema en R versus Python.\n\n16.3.1 Espacio de nombres\nUna diferencia no obvia entre S3 y R6 es el espacio en el que se encuentran los métodos:\n\nLas funciones genéricas son globales: todos los paquetes comparten el mismo espacio de nombres.\nLos métodos encapsulados son locales: los métodos están vinculados a un solo objeto.\n\nLa ventaja de un espacio de nombres global es que varios paquetes pueden usar los mismos verbos para trabajar con diferentes tipos de objetos. Las funciones genéricas proporcionan una API uniforme que facilita la realización de acciones típicas con un nuevo objeto porque existen fuertes convenciones de nomenclatura. Esto funciona bien para el análisis de datos porque a menudo desea hacer lo mismo con diferentes tipos de objetos. En particular, esta es una de las razones por las que el sistema de modelado de R es tan útil: independientemente de dónde se haya implementado el modelo, siempre se trabaja con él usando el mismo conjunto de herramientas (summary(), predict(), … ).\nLa desventaja de un espacio de nombres global es que lo obliga a pensar más profundamente sobre la asignación de nombres. Desea evitar múltiples genéricos con el mismo nombre en diferentes paquetes porque requiere que el usuario escriba :: con frecuencia. Esto puede ser difícil porque los nombres de las funciones suelen ser verbos en inglés y los verbos suelen tener varios significados. Toma plot() por ejemplo:\n\nplot(data)       # plot some data\nplot(bank_heist) # plot a crime\nplot(land)       # create a new plot of land\nplot(movie)      # extract plot of a movie\n\nEn general, debe evitar los métodos que son homónimos del genérico original y, en su lugar, definir un nuevo genérico.\nEste problema no ocurre con los métodos R6 porque están en el ámbito del objeto. El siguiente código está bien, porque no implica que el método de trazado de dos objetos R6 diferentes tenga el mismo significado:\n\ndata$plot()\nbank_heist$plot()\nland$plot()\nmovie$plot()\n\nEstas consideraciones también se aplican a los argumentos a la genérica. Los genéricos de S3 deben tener los mismos argumentos centrales, lo que significa que generalmente tienen nombres no específicos como x o .data. Los genéricos de S3 generalmente necesitan ... para pasar argumentos adicionales a los métodos, pero esto tiene la desventaja de que los nombres de los argumentos mal escritos no generarán un error. En comparación, los métodos R6 pueden variar más ampliamente y usar nombres de argumentos más específicos y sugerentes.\nUna ventaja secundaria del espacio de nombres local es que crear un método R6 es muy económico. La mayoría de los lenguajes OO encapsulados lo alientan a crear muchos métodos pequeños, cada uno de los cuales hace una cosa bien con un nombre evocador. Crear un nuevo método S3 es más costoso, porque es posible que también deba crear uno genérico y pensar en los problemas de nombres descritos anteriormente. Eso significa que el consejo de crear muchos métodos pequeños no se aplica a S3. Todavía es una buena idea dividir el código en fragmentos pequeños y fáciles de entender, pero por lo general deberían ser solo funciones regulares, no métodos.\n\n\n16.3.2 Estado de enhebrado\n \nUn desafío de programar con S3 es cuando desea devolver un valor y modificar el objeto. Esto viola nuestra pauta de que se debe llamar a una función por su valor de retorno o por sus efectos secundarios, pero es necesario en algunos casos.\nPor ejemplo, imagina que quieres crear una pila de objetos. Una pila tiene dos métodos principales:\n\npush() agrega un nuevo objeto a la parte superior de la pila.\npop() devuelve el valor superior y lo elimina de la pila.\n\nLa implementación del constructor y el método push() es sencilla. Una pila contiene una lista de elementos, y empujar un objeto a la pila simplemente se agrega a esta lista.\n\nnew_stack &lt;- function(items = list()) {\n  structure(list(items = items), class = \"stack\")\n}\n\npush &lt;- function(x, y) {\n  x$items &lt;- c(x$items, list(y))\n  x\n}\n\n(No he creado un método real para push() porque hacerlo genérico solo haría que este ejemplo fuera más complicado sin ningún beneficio real).\nImplementar pop() es más desafiante porque tiene que devolver un valor (el objeto en la parte superior de la pila) y tener un efecto secundario (eliminar ese objeto de esa parte superior). Como no podemos modificar el objeto de entrada en S3, debemos devolver dos cosas: el valor y el objeto actualizado.\n\npop &lt;- function(x) {\n  n &lt;- length(x$items)\n  \n  item &lt;- x$items[[n]]\n  x$items &lt;- x$items[-n]\n  \n  list(item = item, x = x)\n}\n\nEsto conduce a un uso bastante incómodo:\n\ns &lt;- new_stack()\ns &lt;- push(s, 10)\ns &lt;- push(s, 20)\n\nout &lt;- pop(s)\nout$item\n#&gt; [1] 20\ns &lt;- out$x\ns\n#&gt; $items\n#&gt; $items[[1]]\n#&gt; [1] 10\n#&gt; \n#&gt; \n#&gt; attr(,\"class\")\n#&gt; [1] \"stack\"\n\nEste problema se conoce como estado de subprocesamiento o programación del acumulador, porque no importa qué tan profundamente se llame a pop(), debe enhebrar el objeto de pila modificado hasta donde vive.\n Una forma en que otros lenguajes de FP enfrentan este desafío es proporcionar un operador de asignación múltiple (o enlace de desestructuración) que le permite asignar múltiples valores en un solo paso. El paquete zeallot (Teetor 2018) proporciona asignaciones múltiples para R con %&lt;-%. Esto hace que el código sea más elegante, pero no resuelve el problema clave:\n\nlibrary(zeallot)\n\nc(value, s) %&lt;-% pop(s)\nvalue\n#&gt; [1] 10\n\nUna implementación R6 de una pila es más simple porque $pop() puede modificar el objeto en su lugar y devolver solo el valor más alto:\n\nStack &lt;- R6::R6Class(\"Stack\", list(\n  items = list(),\n  push = function(x) {\n    self$items &lt;- c(self$items, x)\n    invisible(self)\n  },\n  pop = function() {\n    item &lt;- self$items[[self$length()]]\n    self$items &lt;- self$items[-self$length()]\n    item\n  },\n  length = function() {\n    length(self$items)\n  }\n))\n\nEsto conduce a un código más natural:\n\ns &lt;- Stack$new()\ns$push(10)\ns$push(20)\ns$pop()\n#&gt; [1] 20\n\nEncontré un ejemplo de la vida real del estado de subprocesamiento en las escalas ggplot2. Las escalas son complejas porque necesitan combinar datos en cada faceta y cada capa. Originalmente usé clases S3, pero requería pasar datos de escala hacia y desde muchas funciones. Cambiar a R6 simplificó sustancialmente el código. Sin embargo, también introdujo algunos problemas porque olvidé llamar a $clone() al modificar un gráfico. Esto permitió que las parcelas independientes compartieran los mismos datos de escala, creando un error sutil que era difícil de rastrear.\n\n\n16.3.3 Encadenamiento de métodos\n \nLa canalización, |&gt;, es útil porque proporciona un operador infijo que facilita la composición de funciones de izquierda a derecha. Curiosamente, la tubería no es tan importante para los objetos R6 porque ya usan un operador infijo: $. Esto permite al usuario encadenar varias llamadas a métodos en una sola expresión, una técnica conocida como encadenamiento de métodos:\n\ns &lt;- Stack$new()\ns$\n  push(10)$\n  push(20)$\n  pop()\n#&gt; [1] 20\n\nEsta técnica se usa comúnmente en otros lenguajes de programación, como Python y JavaScript, y es posible con una convención: cualquier método R6 que se llame principalmente por sus efectos secundarios (generalmente modificando el objeto) debe devolver invisible(self).\nLa principal ventaja del encadenamiento de métodos es que puede obtener un autocompletado útil; la desventaja principal es que solo el creador de la clase puede agregar nuevos métodos (y no hay forma de usar el envío múltiple).\n\n\n\n\nBates, Douglas, y Martin Maechler. 2018. «Matrix: Sparse and Dense Matrix Classes and Methods». https://CRAN.R-project.org/package=Matrix.\n\n\nTeetor, Nathan. 2018. zeallot: multiple, unpacking, and destructuring assignment. https://CRAN.R-project.org/package=zeallot.",
    "crumbs": [
      "Programación orientada a objetos",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Compensaciones</span>"
    ]
  },
  {
    "objectID": "Meta.html#footnotes",
    "href": "Meta.html#footnotes",
    "title": "Introducción",
    "section": "",
    "text": "Mientras escribo este capítulo, el ordenado libro de evaluación es todavía un trabajo en progreso, pero para cuando lo lea, espero que esté terminado.↩︎",
    "crumbs": [
      "Metaprogramación",
      "Introducción"
    ]
  },
  {
    "objectID": "Big-picture.html",
    "href": "Big-picture.html",
    "title": "17  Panorama general",
    "section": "",
    "text": "17.1 Introducción\nLa metaprogramación es el tema más difícil de este libro porque reúne muchos temas que antes no estaban relacionados y lo obliga a lidiar con problemas en los que probablemente no había pensado antes. También necesitarás aprender mucho vocabulario nuevo, y al principio parecerá que cada término nuevo está definido por otros tres términos de los que no has oído hablar. Incluso si es un programador experimentado en otro idioma, es poco probable que sus habilidades existentes sean de mucha ayuda, ya que pocos lenguajes populares modernos exponen el nivel de metaprogramación que proporciona R. Así que no se sorprenda si se siente frustrado o confundido al principio; ¡Esta es una parte natural del proceso que le sucede a todos!\nPero creo que ahora es más fácil aprender metaprogramación que nunca. En los últimos años, la teoría y la práctica han madurado sustancialmente, brindando una base sólida junto con herramientas que le permiten resolver problemas comunes. En este capítulo, obtendrá una visión general de todas las piezas principales y cómo encajan entre sí.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#introducción",
    "href": "Big-picture.html#introducción",
    "title": "17  Panorama general",
    "section": "",
    "text": "Estructura\nCada sección de este capítulo presenta una gran idea nueva:\n\nLa Sección 17.2 muestra que el código son datos y le enseña cómo crear y modificar expresiones mediante la captura de código.\nLa Sección 17.3 describe la estructura del código en forma de árbol, llamada árbol de sintaxis abstracta.\nLa Sección 17.4 muestra cómo crear nuevas expresiones programáticamente.\nLa Sección 17.5) muestra cómo ejecutar expresiones evaluándolas en un entorno.\nLa Sección 17.6 ilustra cómo personalizar la evaluación proporcionando funciones personalizadas en un nuevo entorno.\nLa Sección 17.7 extiende esa personalización a las máscaras de datos, que desdibujan la línea entre los entornos y los data frames.\nLa Sección 17.8 introduce una nueva estructura de datos llamada quosure que hace que todo esto sea más simple y correcto.\n\n\n\nRequisitos previos\nEste capítulo presenta las grandes ideas usando rlang; aprenderá los equivalentes básicos en capítulos posteriores. También usaremos el paquete lobstr para explorar la estructura de árbol del código.\n\nlibrary(rlang)\nlibrary(lobstr)\n\nAsegúrese de que también está familiarizado con las estructuras de datos del entorno (Sección 7.2) y del data frame (Sección 3.6).",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#sec-code-data",
    "href": "Big-picture.html#sec-code-data",
    "title": "17  Panorama general",
    "section": "17.2 El código es datos",
    "text": "17.2 El código es datos\nLa primera gran idea es que el código es información: puede capturar código y calcularlo como puede hacerlo con cualquier otro tipo de información. La primera forma de capturar código es con rlang::expr(). Puedes pensar en expr() como si devolviera exactamente lo que pasas:\n\nexpr(mean(x, na.rm = TRUE))\n#&gt; mean(x, na.rm = TRUE)\nexpr(10 + 100 + 1000)\n#&gt; 10 + 100 + 1000\n\nMás formalmente, el código capturado se llama expresión. Una expresión no es un único tipo de objeto, sino un término colectivo para cualquiera de los cuatro tipos (llamada, símbolo, constante o lista de pares), sobre los que aprenderá más en el Capítulo 18.\nexpr() le permite capturar el código que ha escrito. Necesita una herramienta diferente para capturar el código pasado a una función porque expr() no funciona:\n\ncapture_it &lt;- function(x) {\n  expr(x)\n}\ncapture_it(a + b + c)\n#&gt; x\n\nAquí debe usar una función diseñada específicamente para capturar la entrada del usuario en un argumento de función: enexpr(). Piensa en “en” en el contexto de “enriquecer”: enexpr() toma un argumento mal evaluado y lo convierte en una expresión:\n\ncapture_it &lt;- function(x) {\n  enexpr(x)\n}\ncapture_it(a + b + c)\n#&gt; a + b + c\n\nComo capture_it() usa enexpr(), decimos que cita automáticamente su primer argumento. Aprenderá más sobre este término en la Sección 19.2.1.\nUna vez que haya capturado una expresión, puede inspeccionarla y modificarla. Las expresiones complejas se comportan como listas. Eso significa que puedes modificarlos usando [[ y $:\n\nf &lt;- expr(f(x = 1, y = 2))\n\n# Agregar un nuevo argumento\nf$z &lt;- 3\nf\n#&gt; f(x = 1, y = 2, z = 3)\n\n# Or eliminar un argumento\nf[[2]] &lt;- NULL\nf\n#&gt; f(y = 2, z = 3)\n\nEl primer elemento de la llamada es la función a llamar, lo que significa que el primer argumento está en la segunda posición. Conocerá los detalles completos en la Sección 18.3.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#sec-code-tree",
    "href": "Big-picture.html#sec-code-tree",
    "title": "17  Panorama general",
    "section": "17.3 El código es un árbol",
    "text": "17.3 El código es un árbol\nPara realizar manipulaciones más complejas con expresiones, debe comprender completamente su estructura. Detrás de escena, casi todos los lenguajes de programación representan el código como un árbol, a menudo llamado árbol de sintaxis abstracta, o AST para abreviar. R es inusual en el sentido de que realmente puede inspeccionar y manipular este árbol.\nUna herramienta muy conveniente para comprender la estructura en forma de árbol es lobstr::ast(). Dado algo de código, esta función muestra la estructura de árbol subyacente. Las llamadas a funciones forman las ramas del árbol y se muestran mediante rectángulos. Las hojas del árbol son símbolos (como a) y constantes (como \"b\").\n\nlobstr::ast(f(a, \"b\"))\n#&gt; █─f \n#&gt; ├─a \n#&gt; └─\"b\"\n\nLas llamadas a funciones anidadas crean árboles con ramificaciones más profundas:\n\nlobstr::ast(f1(f2(a, b), f3(1, f4(2))))\n#&gt; █─f1 \n#&gt; ├─█─f2 \n#&gt; │ ├─a \n#&gt; │ └─b \n#&gt; └─█─f3 \n#&gt;   ├─1 \n#&gt;   └─█─f4 \n#&gt;     └─2\n\nDebido a que todas las formas de función se pueden escribir en forma de prefijo (Sección 6.8.2), cada expresión R se puede mostrar de esta manera:\n\nlobstr::ast(1 + 2 * 3)\n#&gt; █─`+` \n#&gt; ├─1 \n#&gt; └─█─`*` \n#&gt;   ├─2 \n#&gt;   └─3\n\nMostrar el AST de esta manera es una herramienta útil para explorar la gramática de R, el tema de la Sección 18.4.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#sec-coding-code",
    "href": "Big-picture.html#sec-coding-code",
    "title": "17  Panorama general",
    "section": "17.4 El código puede generar código",
    "text": "17.4 El código puede generar código\nAdemás de ver el árbol a partir del código escrito por un humano, también puede usar el código para crear nuevos árboles. Hay dos herramientas principales: call2() y eliminación de comillas.\nrlang::call2() construye una llamada de función a partir de sus componentes: la función a llamar y los argumentos para llamarla.\n\ncall2(\"f\", 1, 2, 3)\n#&gt; f(1, 2, 3)\ncall2(\"+\", 1, call2(\"*\", 2, 3))\n#&gt; 1 + 2 * 3\n\ncall2() a menudo es conveniente para programar, pero es un poco torpe para el uso interactivo. Una técnica alternativa es construir árboles de código complejos combinando árboles de código más simples con una plantilla. expr() y enexpr() tienen soporte incorporado para esta idea a través de !! (pronunciado bang-bang), el operador sin comillas.\nLos detalles precisos son el tema de la Sección @ref(unquoting), pero básicamente !!x inserta el árbol de código almacenado en x en la expresión. Esto facilita la construcción de árboles complejos a partir de fragmentos simples:\n\nxx &lt;- expr(x + x)\nyy &lt;- expr(y + y)\n\nexpr(!!xx / !!yy)\n#&gt; (x + x)/(y + y)\n\nTenga en cuenta que la salida conserva la precedencia del operador, por lo que obtenemos (x + x) / (y + y) y no x + x / y + y (es decir, x + (x / y) + y). Esto es importante, especialmente si te has estado preguntando si no sería más fácil simplemente pegar cadenas.\nQuitar las comillas se vuelve aún más útil cuando lo envuelves en una función, primero usando enexpr() para capturar la expresión del usuario, luego expr() y !! para crear una nueva expresión usando una plantilla. El siguiente ejemplo muestra cómo puede generar una expresión que calcule el coeficiente de variación:\n\ncv &lt;- function(var) {\n  var &lt;- enexpr(var)\n  expr(sd(!!var) / mean(!!var))\n}\n\ncv(x)\n#&gt; sd(x)/mean(x)\ncv(x + y)\n#&gt; sd(x + y)/mean(x + y)\n\n(Esto no es muy útil aquí, pero poder crear este tipo de bloque de construcción es muy útil cuando se resuelven problemas más complejos.)\nEs importante destacar que esto funciona incluso cuando se le dan nombres de variables extraños:\n\ncv(`)`)\n#&gt; sd(`)`)/mean(`)`)\n\nTratar con nombres raros1 es otra buena razón para evitar paste() al generar código R. Puede pensar que se trata de una preocupación esotérica, pero no preocuparse por ello cuando la generación de código SQL en aplicaciones web condujo a ataques de inyección de SQL que, en conjunto, han costado miles de millones de dólares.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#sec-eval-intro",
    "href": "Big-picture.html#sec-eval-intro",
    "title": "17  Panorama general",
    "section": "17.5 Código de ejecución de evaluación",
    "text": "17.5 Código de ejecución de evaluación\nInspeccionar y modificar el código le brinda un conjunto de herramientas poderosas. Obtiene otro conjunto de herramientas poderosas cuando evalúa, es decir, ejecuta o ejecuta, una expresión. Evaluar una expresión requiere un entorno, que le dice a R qué significan los símbolos en la expresión. Aprenderá los detalles de la evaluación en el Capítulo 20.\nLa herramienta principal para evaluar expresiones es base::eval(), que toma una expresión y un entorno:\n\neval(expr(x + y), env(x = 1, y = 10))\n#&gt; [1] 11\neval(expr(x + y), env(x = 2, y = 100))\n#&gt; [1] 102\n\nSi omite el entorno, eval usa el entorno actual:\n\nx &lt;- 10\ny &lt;- 100\neval(expr(x + y))\n#&gt; [1] 110\n\nUna de las grandes ventajas de evaluar el código manualmente es que puede modificar el entorno. Hay dos razones principales para hacer esto:\n\nPara anular temporalmente las funciones para implementar un lenguaje específico de dominio.\nPara agregar una máscara de datos para que pueda hacer referencia a las variables en un data frame como si fueran variables en un entorno.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#sec-eval-funs",
    "href": "Big-picture.html#sec-eval-funs",
    "title": "17  Panorama general",
    "section": "17.6 Personalización de la evaluación con funciones",
    "text": "17.6 Personalización de la evaluación con funciones\nEl ejemplo anterior usó un entorno que vinculaba x e y a vectores. Es menos obvio que también vincula nombres a funciones, lo que le permite anular el comportamiento de las funciones existentes. Esta es una gran idea a la que volveremos en el Capítulo 21 donde exploro la generación de HTML y LaTeX desde R. El siguiente ejemplo le da una idea del poder. Aquí evalúo el código en un entorno especial donde * y + han sido anulados para trabajar con cadenas en lugar de números:\n\nstring_math &lt;- function(x) {\n  e &lt;- env(\n    caller_env(),\n    `+` = function(x, y) paste0(x, y),\n    `*` = function(x, y) strrep(x, y)\n  )\n\n  eval(enexpr(x), e)\n}\n\nname &lt;- \"Hadley\"\nstring_math(\"Hello \" + name)\n#&gt; [1] \"Hello Hadley\"\nstring_math((\"x\" * 2 + \"-y\") * 3)\n#&gt; [1] \"xx-yxx-yxx-y\"\n\ndplyr lleva esta idea al extremo, ejecutando código en un entorno que genera SQL para su ejecución en una base de datos remota:\n\nlibrary(dplyr)\n#&gt; \n#&gt; Attaching package: 'dplyr'\n#&gt; The following objects are masked from 'package:stats':\n#&gt; \n#&gt;     filter, lag\n#&gt; The following objects are masked from 'package:base':\n#&gt; \n#&gt;     intersect, setdiff, setequal, union\n\ncon &lt;- DBI::dbConnect(RSQLite::SQLite(), filename = \":memory:\")\nmtcars_db &lt;- copy_to(con, mtcars)\n\nmtcars_db %&gt;%\n  filter(cyl &gt; 2) %&gt;%\n  select(mpg:hp) %&gt;%\n  head(10) %&gt;%\n  show_query()\n#&gt; &lt;SQL&gt;\n#&gt; SELECT `mpg`, `cyl`, `disp`, `hp`\n#&gt; FROM `mtcars`\n#&gt; WHERE (`cyl` &gt; 2.0)\n#&gt; LIMIT 10\n\nDBI::dbDisconnect(con)",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#sec-eval-data",
    "href": "Big-picture.html#sec-eval-data",
    "title": "17  Panorama general",
    "section": "17.7 Personalización de la evaluación con datos",
    "text": "17.7 Personalización de la evaluación con datos\nReenlazar funciones es una técnica extremadamente poderosa, pero tiende a requerir una gran inversión. Una aplicación práctica más inmediata es modificar la evaluación para buscar variables en un data frame en lugar de un entorno. Esta idea impulsa las funciones base subset() y transform(), así como muchas funciones tidyverse como ggplot2::aes() y dplyr::mutate(). Es posible usar eval() para esto, pero hay algunas trampas potenciales (Sección 20.6), así que cambiaremos a rlang::eval_tidy() en su lugar.\nAdemás de la expresión y el entorno, eval_tidy() también toma una máscara de datos, que suele ser un data frame:\n\ndf &lt;- data.frame(x = 1:5, y = sample(5))\neval_tidy(expr(x + y), df)\n#&gt; [1] 6 6 4 6 8\n\nEvaluar con una máscara de datos es una técnica útil para el análisis interactivo porque le permite escribir x + y en lugar de df$x + df$y. Sin embargo, esa conveniencia tiene un costo: la ambigüedad. En la Sección 20.4 aprenderá cómo lidiar con la ambigüedad usando los pronombres especiales .data y .env.\nPodemos envolver este patrón en una función usando enexpr(). Esto nos da una función muy similar a base::with():\n\nwith2 &lt;- function(df, expr) {\n  eval_tidy(enexpr(expr), df)\n}\n\nwith2(df, x + y)\n#&gt; [1] 6 6 4 6 8\n\nDesafortunadamente, esta función tiene un error sutil y necesitamos una nueva estructura de datos para ayudar a solucionarlo.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#sec-quosure-intro",
    "href": "Big-picture.html#sec-quosure-intro",
    "title": "17  Panorama general",
    "section": "17.8 Quosures",
    "text": "17.8 Quosures\nPara hacer el problema más obvio, voy a modificar with2(). El problema básico aún ocurre sin esta modificación, pero es mucho más difícil de ver.\n\nwith2 &lt;- function(df, expr) {\n  a &lt;- 1000\n  eval_tidy(enexpr(expr), df)\n}\n\nPodemos ver el problema cuando usamos with2() para referirnos a una variable llamada a. Queremos que el valor de a provenga del enlace que podemos ver (10), no del enlace interno de la función (1000):\n\ndf &lt;- data.frame(x = 1:3)\na &lt;- 10\nwith2(df, x + a)\n#&gt; [1] 1001 1002 1003\n\nEl problema surge porque necesitamos evaluar la expresión capturada en el entorno donde fue escrita (donde a es 10), no el entorno dentro de with2() (donde a es 1000).\nAfortunadamente podemos resolver este problema usando una nueva estructura de datos: el quosure que agrupa una expresión con un entorno. eval_tidy() sabe cómo trabajar con quosures, así que todo lo que tenemos que hacer es cambiar enexpr() por enquo():\n\nwith2 &lt;- function(df, expr) {\n  a &lt;- 1000\n  eval_tidy(enquo(expr), df)\n}\n\nwith2(df, x + a)\n#&gt; [1] 11 12 13\n\nSiempre que utilice una máscara de datos, siempre debe utilizar enquo() en lugar de enexpr(). Este es el tema del Capítulo 20.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Big-picture.html#footnotes",
    "href": "Big-picture.html#footnotes",
    "title": "17  Panorama general",
    "section": "",
    "text": "Más técnicamente, estos se denominan nombres no sintácticos y son el tema de la Sección 2.2.1.↩︎",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Panorama general</span>"
    ]
  },
  {
    "objectID": "Expressions.html",
    "href": "Expressions.html",
    "title": "18  Expresiones",
    "section": "",
    "text": "18.1 Introducción\nPara calcular el lenguaje, primero necesitamos entender su estructura. Eso requiere un vocabulario nuevo, algunas herramientas nuevas y algunas formas nuevas de pensar sobre el código R. El primero de ellos es la distinción entre una operación y su resultado. Toma el siguiente código, que multiplica una variable x por 10 y guarda el resultado en una nueva variable llamada y. No funciona porque no hemos definido una variable llamada x:\ny &lt;- x * 10\n#&gt; Error in eval(expr, envir, enclos): object 'x' not found\nSería bueno si pudiéramos capturar la intención del código sin ejecutarlo. En otras palabras, ¿cómo podemos separar nuestra descripción de la acción de la acción misma?\nUna forma es usar rlang::expr():\nz &lt;- rlang::expr(y &lt;- x * 10)\nz\n#&gt; y &lt;- x * 10\nexpr() devuelve una expresión, un objeto que captura la estructura del código sin evaluarlo (es decir, ejecutarlo). Si tiene una expresión, puede evaluarla con base::eval():\nx &lt;- 4\neval(z)\ny\n#&gt; [1] 40\nEl enfoque de este capítulo son las estructuras de datos que subyacen a las expresiones. Dominar este conocimiento le permitirá inspeccionar y modificar el código capturado y generar código con código. Volveremos a expr() en el Capítulo 19, ya eval() en el Capítulo 20.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Expressions.html#introducción",
    "href": "Expressions.html#introducción",
    "title": "18  Expresiones",
    "section": "",
    "text": "Estructura\n\nLa Sección 18.2 introduce la idea del árbol de sintaxis abstracta (AST) y revela la estructura de árbol que subyace en todo el código R.\nLa Sección 18.3 se sumerge en los detalles de las estructuras de datos que sustentan el AST: constantes, símbolos y llamadas, que se conocen colectivamente como expresiones.\nLa Sección 18.4 cubre el análisis, el acto de convertir la secuencia lineal de caracteres en código en AST, y usa esa idea para explorar algunos detalles de la gramática de R.\nLa Sección 18.5 le muestra cómo puede usar funciones recursivas para calcular en el lenguaje, escribiendo funciones que calculan con expresiones.\nLa Sección 18.6 vuelve a tres estructuras de datos más especializadas: listas de pares, argumentos perdidos y vectores de expresión.\n\n\n\nRequisitos previos\nAsegúrese de haber leído la descripción general de la metaprogramación en el Capítulo 17 para obtener una descripción general amplia de la motivación y el vocabulario básico. También necesitará el paquete rlang para capturar y calcular expresiones, y el paquete lobstr para visualizarlos.\n\nlibrary(rlang)\nlibrary(lobstr)",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Expressions.html#sec-ast",
    "href": "Expressions.html#sec-ast",
    "title": "18  Expresiones",
    "section": "18.2 Árboles de sintaxis abstracta",
    "text": "18.2 Árboles de sintaxis abstracta\n \nLas expresiones también se denominan árboles de sintaxis abstracta (AST) porque la estructura del código es jerárquica y se puede representar naturalmente como un árbol. Comprender esta estructura de árbol es crucial para inspeccionar y modificar expresiones (es decir, metaprogramación).\n\n18.2.1 Dibujo\n\nComenzaremos presentando algunas convenciones para dibujar AST, comenzando con una simple llamada que muestra sus componentes principales: f(x, \"y\", 1). Dibujaré árboles de dos maneras1:\n\nA “mano” (es decir, con OmniGraffle):\n\n\n\n\n\n\n\n\n\nCon lobstr::ast():\n\nlobstr::ast(f(x, \"y\", 1))\n#&gt; █─f \n#&gt; ├─x \n#&gt; ├─\"y\" \n#&gt; └─1\n\n\nAmbos enfoques comparten convenciones tanto como sea posible:\n\nLas hojas del árbol son símbolos, como f y x, o constantes, como 1 o \"y\". Los símbolos se dibujan en púrpura y tienen esquinas redondeadas. Las constantes tienen bordes negros y esquinas cuadradas. Las cadenas y los símbolos se confunden fácilmente, por lo que las cadenas siempre se escriben entre comillas.\nLas ramas del árbol son objetos de llamada, que representan llamadas de función y se dibujan como rectángulos naranjas. El primer hijo (f) es la función que se llama; el segundo hijo y los subsiguientes (x, \"y\" y 1) son los argumentos de esa función.\n\nLos colores se mostrarán cuando usted llame a ast(), pero no aparecen en el libro por razones técnicas complicadas.\nEl ejemplo anterior solo contenía una llamada de función, lo que lo convierte en un árbol muy poco profundo. La mayoría de las expresiones contendrán considerablemente más llamadas, creando árboles con múltiples niveles. Por ejemplo, considere el AST para f(g(1, 2), h(3, 4, i())):\n\n\n\n\n\n\n\n\n\n\nlobstr::ast(f(g(1, 2), h(3, 4, i())))\n#&gt; █─f \n#&gt; ├─█─g \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─█─h \n#&gt;   ├─3 \n#&gt;   ├─4 \n#&gt;   └─█─i\n\nPuede leer los diagramas dibujados a mano de izquierda a derecha (ignorando la posición vertical) y los diagramas dibujados por langosta de arriba a abajo (ignorando la posición horizontal). La profundidad dentro del árbol está determinada por el anidamiento de las llamadas a funciones. Esto también determina el orden de evaluación, ya que la evaluación generalmente procede de lo más profundo a lo más superficial, pero esto no está garantizado debido a la evaluación diferida (Sección 6.5). También tenga en cuenta la aparición de i(), una llamada de función sin argumentos; es una rama con una sola hoja (símbolo).\n\n\n18.2.2 Componentes sin código\n\nEs posible que se haya preguntado qué hace que estos árboles de sintaxis abstractos. Son abstractos porque solo capturan detalles estructurales importantes del código, no espacios en blanco ni comentarios:\n\nast(\n  f(x,  y)  # important!\n)\n#&gt; █─f \n#&gt; ├─x \n#&gt; └─y\n\nSolo hay un lugar donde los espacios en blanco afectan el AST:\n\nlobstr::ast(y &lt;- x)\n#&gt; █─`&lt;-` \n#&gt; ├─y \n#&gt; └─x\nlobstr::ast(y &lt; -x)\n#&gt; █─`&lt;` \n#&gt; ├─y \n#&gt; └─█─`-` \n#&gt;   └─x\n\n\n\n18.2.3 Llamadas infijas\n\nCada llamada en R se puede escribir en forma de árbol porque cualquier llamada se puede escribir en forma de prefijo (Sección 6.8.1). Tome y &lt;- x * 10 de nuevo: ¿cuáles son las funciones que se están llamando? No es tan fácil de detectar como f(x, 1) porque esta expresión contiene dos llamadas infijas: &lt;- y *. Eso significa que estas dos líneas de código son equivalentes:\n\ny &lt;- x * 10\n`&lt;-`(y, `*`(x, 10))\n\nY ambas tienen este AST2:\n\n\n\n\n\n\n\n\n\n\nlobstr::ast(y &lt;- x * 10)\n#&gt; █─`&lt;-` \n#&gt; ├─y \n#&gt; └─█─`*` \n#&gt;   ├─x \n#&gt;   └─10\n\nRealmente no hay diferencia entre los AST, y si genera una expresión con llamadas de prefijo, R aún la imprimirá en forma de infijo:\n\nexpr(`&lt;-`(y, `*`(x, 10)))\n#&gt; y &lt;- x * 10\n\nEl orden en que se aplican los operadores infijos se rige por un conjunto de reglas llamadas precedencia de operadores, y usaremos lobstr::ast() para explorarlas en la Sección 18.4.1.\n\n\n18.2.4 Ejercicios\n\nReconstruya el código representado por los árboles a continuación:\n\n#&gt; █─f \n#&gt; └─█─g \n#&gt;   └─█─h\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─x \n#&gt; │   └─y \n#&gt; └─z\n\nDibuja los siguientes árboles a mano y luego verifica tus respuestas con lobstr::ast().\n\nf(g(h(i(1, 2, 3))))\nf(1, g(2, h(3, i())))\nf(g(1, 2), h(3, i(4, 5)))\n\n¿Qué está pasando con los AST a continuación? (Sugerencia: lea atentamente ?\"^\".)\n\nlobstr::ast(`x` + `y`)\n#&gt; █─`+` \n#&gt; ├─x \n#&gt; └─y\nlobstr::ast(x ** y)\n#&gt; █─`^` \n#&gt; ├─x \n#&gt; └─y\nlobstr::ast(1 -&gt; x)\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─1\n\n¿Qué está pasando con los AST a continuación? (Sugerencia: lea atentamente la Sección 6.2.1.)\n\nlobstr::ast(function(x = 1, y = 2) {})\n#&gt; █─`function` \n#&gt; ├─█─x = 1 \n#&gt; │ └─y = 2 \n#&gt; ├─█─`{` \n#&gt; └─&lt;inline srcref&gt;\n\n¿Cómo se ve el árbol de llamadas de una instrucción if con múltiples condiciones else if? ¿Por qué?",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Expressions.html#sec-expression-details",
    "href": "Expressions.html#sec-expression-details",
    "title": "18  Expresiones",
    "section": "18.3 Expresiones",
    "text": "18.3 Expresiones\n \nEn conjunto, las estructuras de datos presentes en el AST se denominan expresiones. Una expresión es cualquier miembro del conjunto de tipos base creados mediante el código de análisis: escalares constantes, símbolos, objetos de llamada y listas de pares. Estas son las estructuras de datos utilizadas para representar el código capturado de expr(), y is_expression(expr(...)) siempre es verdadero. Las constantes, los símbolos y los objetos de llamada son los más importantes y se analizan a continuación. Las listas de pares y los símbolos vacíos son más especializados y volveremos a ellos en las secciones Sección 18.6.1 y Sección 18.6.2.\nNB: En la documentación base de R, “expresión” se usa para significar dos cosas. Además de la definición anterior, expresión también se usa para referirse al tipo de objeto devuelto por expression() y parse(), que son básicamente listas de expresiones como se define anteriormente. En este libro llamaré a estos vectores de expresión, y regresaré a ellos en la Sección 18.6.3.\n\n18.3.1 Constantes\n \nLas constantes escalares son el componente más simple del AST. Más precisamente, una constante es NULL o un vector atómico de longitud 1 (o escalar, Sección 3.2.1) como TRUE, 1L, 2.5 o \"x\". Puedes probar una constante con rlang::is_syntactic_literal().\nLas constantes son autocomillas en el sentido de que la expresión utilizada para representar una constante es la misma constante:\n\nidentical(expr(TRUE), TRUE)\n#&gt; [1] TRUE\nidentical(expr(1), 1)\n#&gt; [1] TRUE\nidentical(expr(2L), 2L)\n#&gt; [1] TRUE\nidentical(expr(\"x\"), \"x\")\n#&gt; [1] TRUE\n\n\n\n18.3.2 Simbolos\n \nUn símbolo representa el nombre de un objeto como x, mtcars o mean. En la base R, los términos símbolo y nombre se usan indistintamente (es decir, is.name() es idéntico a is.symbol()), pero en este libro usé símbolo de manera consistente porque “nombre” tiene muchos otros significados.\nPuede crear un símbolo de dos maneras: capturando el código que hace referencia a un objeto con expr(), o convirtiendo una cadena en un símbolo con rlang::sym():\n\nexpr(x)\n#&gt; x\nsym(\"x\")\n#&gt; x\n\n\nPuede volver a convertir un símbolo en una cadena con as.character() o rlang::as_string(). as_string() tiene la ventaja de indicar claramente que obtendrá un vector de caracteres de longitud 1.\n\nas_string(expr(x))\n#&gt; [1] \"x\"\n\nPuede reconocer un símbolo porque está impreso sin comillas, str() le dice que es un símbolo, y is.symbol() es TRUE:\n\nstr(expr(x))\n#&gt;  symbol x\nis.symbol(expr(x))\n#&gt; [1] TRUE\n\nEl tipo de símbolo no está vectorizado, es decir, un símbolo siempre tiene una longitud de 1. Si desea varios símbolos, deberá ponerlos en una lista usando (p. ej.) rlang::syms().\n\n\n18.3.3 Llamadas\n \nUn objeto de llamada representa una llamada de función capturada. Los objetos de llamada son un tipo especial de lista donde el primer componente especifica la función a llamar (generalmente un símbolo), y los elementos restantes son los argumentos para esa llamada. Los objetos de llamada crean ramas en el AST, porque las llamadas se pueden anidar dentro de otras llamadas.\nPuede identificar un objeto de llamada cuando se imprime porque parece una llamada de función. Confusamente typeof() y str() imprimen “lenguaje” para los objetos de llamada, pero is.call() devuelve TRUE:\n\nlobstr::ast(read.table(\"important.csv\", row.names = FALSE))\n#&gt; █─read.table \n#&gt; ├─\"important.csv\" \n#&gt; └─row.names = FALSE\nx &lt;- expr(read.table(\"important.csv\", row.names = FALSE))\n\ntypeof(x)\n#&gt; [1] \"language\"\nis.call(x)\n#&gt; [1] TRUE\n\n\n18.3.3.1 Subconjunto\n\nLas llamadas generalmente se comportan como listas, es decir, puede usar herramientas estándar de creación de subconjuntos. El primer elemento del objeto de llamada es la función a llamar, que suele ser un símbolo:\n\nx[[1]]\n#&gt; read.table\nis.symbol(x[[1]])\n#&gt; [1] TRUE\n\nEl resto de los elementos son los argumentos:\n\nas.list(x[-1])\n#&gt; [[1]]\n#&gt; [1] \"important.csv\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] FALSE\n\nPuede extraer argumentos individuales con [[ o, si se nombra, $:\n\nx[[2]]\n#&gt; [1] \"important.csv\"\nx$row.names\n#&gt; [1] FALSE\n\nPuede determinar la cantidad de argumentos en un objeto de llamada restando 1 de su longitud:\n\nlength(x) - 1\n#&gt; [1] 2\n\nExtraer argumentos específicos de las llamadas es un desafío debido a las reglas flexibles de R para la coincidencia de argumentos: potencialmente podría estar en cualquier ubicación, con el nombre completo, con un nombre abreviado o sin nombre. Para solucionar este problema, puede usar rlang::call_standardise() que estandariza todos los argumentos para usar el nombre completo: \n\nrlang::call_standardise(x)\n#&gt; Warning: `call_standardise()` is deprecated as of rlang 0.4.11\n#&gt; This warning is displayed once every 8 hours.\n#&gt; read.table(file = \"important.csv\", row.names = FALSE)\n\n(NB: Si la función usa ... no es posible estandarizar todos los argumentos).\nLas llamadas se pueden modificar de la misma forma que las listas:\n\nx$header &lt;- TRUE\nx\n#&gt; read.table(\"important.csv\", row.names = FALSE, header = TRUE)\n\n\n\n18.3.3.2 Posición de la función\n\nEl primer elemento del objeto de llamada es la posición de la función. Contiene la función que se llamará cuando se evalúe el objeto, y generalmente es un símbolo 3:\n\nlobstr::ast(foo())\n#&gt; █─foo\n\nMientras que R le permite rodear el nombre de la función con comillas, el analizador lo convierte en un símbolo:\n\nlobstr::ast(\"foo\"())\n#&gt; █─foo\n\nSin embargo, a veces la función no existe en el entorno actual y es necesario realizar algunos cálculos para recuperarla: por ejemplo, si la función está en otro paquete, es un método de un objeto R6 o es creada por una fábrica de funciones. En este caso, la posición de la función será ocupada por otra llamada:\n\nlobstr::ast(pkg::foo(1))\n#&gt; █─█─`::` \n#&gt; │ ├─pkg \n#&gt; │ └─foo \n#&gt; └─1\nlobstr::ast(obj$foo(1))\n#&gt; █─█─`$` \n#&gt; │ ├─obj \n#&gt; │ └─foo \n#&gt; └─1\nlobstr::ast(foo(1)(2))\n#&gt; █─█─foo \n#&gt; │ └─1 \n#&gt; └─2\n\n\n\n\n\n\n\n\n\n\n\n\n18.3.3.3 Construyendo\n \nPuede construir un objeto de llamada a partir de sus componentes utilizando rlang::call2(). El primer argumento es el nombre de la función a llamar (ya sea como una cadena, un símbolo u otra llamada). Los argumentos restantes se pasarán a la llamada:\n\ncall2(\"mean\", x = expr(x), na.rm = TRUE)\n#&gt; mean(x = x, na.rm = TRUE)\ncall2(expr(base::mean), x = expr(x), na.rm = TRUE)\n#&gt; base::mean(x = x, na.rm = TRUE)\n\nLas llamadas de infijo creadas de esta manera aún se imprimen como de costumbre.\n\ncall2(\"&lt;-\", expr(x), 10)\n#&gt; x &lt;- 10\n\nUsar call2() para crear expresiones complejas es un poco torpe. Aprenderás otra técnica en el Capítulo 19.\n\n\n\n18.3.4 Resumen\nLa siguiente tabla resume la apariencia de los diferentes subtipos de expresión en str() y typeof():\n\n\n\n\n\n\n\n\n\nstr()\ntypeof()\n\n\n\n\nconstante escalar\nlogi/int/num/chr\nlogical/integer/double/character\n\n\nSímbolo\nsymbol\nsymbol\n\n\nObjeto de llamada\nlanguage\nlanguage\n\n\nLista de pares\nLista de pares punteados\npairlist\n\n\nVector de expresión\nexpression()\nexpression\n\n\n\nTanto base R como rlang proporcionan funciones para probar cada tipo de entrada, aunque los tipos cubiertos son ligeramente diferentes. Puede distinguirlas fácilmente porque todas las funciones básicas comienzan con is. y las funciones rlang comienzan con is_.\n\n\n\n\n\n\nbase\nrlang\n\n\n\n\nScalar constant\n—\nis_syntactic_literal()\n\n\nSymbol\nis.symbol()\nis_symbol()\n\n\nCall object\nis.call()\nis_call()\n\n\nPairlist\nis.pairlist()\nis_pairlist()\n\n\nExpression vector\nis.expression()\n—\n\n\n\n\n\n18.3.5 Ejercicios\n\n¿Cuáles dos de los seis tipos de vectores atómicos no pueden aparecer en una expresión? ¿Por qué? De manera similar, ¿por qué no puedes crear una expresión que contenga un vector atómico de longitud mayor que uno?\n¿Qué sucede cuando crea un subconjunto de un objeto de llamada para eliminar el primer elemento? p.ej. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. ¿Por qué?\nDescriba las diferencias entre los siguientes objetos de llamada.\n\nx &lt;- 1:10\n\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)\n\nrlang::call_standardise() no funciona tan bien para las siguientes llamadas. ¿Por qué? ¿Qué hace especial a mean()?\n\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n#&gt; mean(x = 1:10, na.rm = TRUE)\ncall_standardise(quote(mean(n = T, 1:10)))\n#&gt; mean(x = 1:10, n = T)\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n#&gt; mean(x = 1:10, , TRUE)\n\n¿Por qué este código no tiene sentido?\n\nx &lt;- expr(foo(x = 1))\nnames(x) &lt;- c(\"x\", \"y\")\n\nConstruya la expresión if(x &gt; 1) \"a\" else \"b\" utilizando varias llamadas a call2(). ¿Cómo refleja la estructura del código la estructura del AST?",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Expressions.html#sec-grammar",
    "href": "Expressions.html#sec-grammar",
    "title": "18  Expresiones",
    "section": "18.4 Análisis y gramática",
    "text": "18.4 Análisis y gramática\n\nHemos hablado mucho sobre las expresiones y el AST, pero no sobre cómo se crean las expresiones a partir del código que escribe (como \"x + y\"). El proceso mediante el cual un lenguaje informático toma una cadena y construye una expresión se denomina análisis sintáctico y se rige por un conjunto de reglas conocido como gramática. En esta sección, usaremos lobstr::ast() para explorar algunos de los detalles de la gramática de R, y luego mostraremos cómo puede transformar de un lado a otro entre expresiones y cadenas.\n\n18.4.1 Predecencia de operadores\n\nLas funciones infijas introducen dos fuentes de ambigüedad. La primera fuente de ambigüedad surge de las funciones infijas: ¿qué produce 1 + 2 * 3? ¿Obtienes 9 (es decir, (1 + 2) * 3), o 7 (es decir, 1 + (2 * 3))? En otras palabras, ¿cuál de los dos posibles árboles de análisis de abajo usa R?\n\n\n\n\n\n\n\n\n\nLos lenguajes de programación usan convenciones llamadas precedencia de operadores para resolver esta ambigüedad. Podemos usar ast() para ver qué hace R:\n\nlobstr::ast(1 + 2 * 3)\n#&gt; █─`+` \n#&gt; ├─1 \n#&gt; └─█─`*` \n#&gt;   ├─2 \n#&gt;   └─3\n\nPredicting the precedence of arithmetic operations is usually easy because it’s drilled into you in school and is consistent across the vast majority of programming languages.\nPredecir la precedencia de otros operadores es más difícil. Hay un caso particularmente sorprendente en R: ! tiene una precedencia mucho menor (es decir, se une con menos fuerza) de lo que cabría esperar. Esto le permite escribir operaciones útiles como:\n\nlobstr::ast(!x %in% y)\n#&gt; █─`!` \n#&gt; └─█─`%in%` \n#&gt;   ├─x \n#&gt;   └─y\n\nR tiene más de 30 operadores infijos divididos en 18 grupos de precedencia. Si bien los detalles se describen en ?Syntax, muy pocas personas han memorizado el orden completo. Si hay alguna confusión, ¡use paréntesis!\n\nlobstr::ast((1 + 2) * 3)\n#&gt; █─`*` \n#&gt; ├─█─`(` \n#&gt; │ └─█─`+` \n#&gt; │   ├─1 \n#&gt; │   └─2 \n#&gt; └─3\n\nTenga en cuenta la aparición de los paréntesis en el AST como una llamada a la función (.\n\n\n18.4.2 Asociatividad\nLa segunda fuente de ambigüedad se presenta por el uso repetido de la misma función de infijo. Por ejemplo, ¿es ‘1 + 2 + 3’ equivalente a ‘(1 + 2) + 3’ o a ‘1 + (2 + 3)’? Esto normalmente no importa porque x + (y + z) == (x + y) + z, es decir, la suma es asociativa, pero es necesaria porque algunas clases de S3 definen + de forma no asociativa. Por ejemplo, ggplot2 sobrecarga + para construir una trama compleja a partir de piezas simples; esto no es asociativo porque las capas anteriores se dibujan debajo de las capas posteriores (es decir, geom_point() + geom_smooth() no produce el mismo gráfico que geom_smooth() + geom_point()).\nEn R, la mayoría de los operadores son asociativos a la izquierda, es decir, las operaciones de la izquierda se evalúan primero:\n\nlobstr::ast(1 + 2 + 3)\n#&gt; █─`+` \n#&gt; ├─█─`+` \n#&gt; │ ├─1 \n#&gt; │ └─2 \n#&gt; └─3\n\nHay dos excepciones: exponenciación y asignación.\n\nlobstr::ast(2^2^3)\n#&gt; █─`^` \n#&gt; ├─2 \n#&gt; └─█─`^` \n#&gt;   ├─2 \n#&gt;   └─3\nlobstr::ast(x &lt;- y &lt;- z)\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─█─`&lt;-` \n#&gt;   ├─y \n#&gt;   └─z\n\n\n\n18.4.3 Analizar y desanalizar\n \nLa mayoría de las veces, escribe código en la consola y R se encarga de convertir los caracteres que ha escrito en un AST. Pero ocasionalmente tiene código almacenado en una cadena y desea analizarlo usted mismo. Puedes hacerlo usando rlang::parse_expr():\n\nx1 &lt;- \"y &lt;- x + 10\"\nx1\n#&gt; [1] \"y &lt;- x + 10\"\nis.call(x1)\n#&gt; [1] FALSE\n\nx2 &lt;- rlang::parse_expr(x1)\nx2\n#&gt; y &lt;- x + 10\nis.call(x2)\n#&gt; [1] TRUE\n\nparse_expr() siempre devuelve una sola expresión. Si tiene varias expresiones separadas por ; o \\n, deberá usar rlang::parse_exprs(). Devuelve una lista de expresiones:\n\nx3 &lt;- \"a &lt;- 1; a + 1\"\nrlang::parse_exprs(x3)\n#&gt; [[1]]\n#&gt; a &lt;- 1\n#&gt; \n#&gt; [[2]]\n#&gt; a + 1\n\nSi se encuentra trabajando con cadenas que contienen código con mucha frecuencia, debe reconsiderar su proceso. Lea el Capítulo 19 y considere si puede generar expresiones utilizando la cuasicita de manera más segura.\n\n\nEl equivalente básico de parse_exprs() es parse(). Es un poco más difícil de usar porque está especializado para analizar código R almacenado en archivos. Debe proporcionar su cadena al argumento texto y devolverá un vector de expresión (Sección 18.6.3). Recomiendo convertir la salida en una lista:\n\nas.list(parse(text = x1))\n#&gt; [[1]]\n#&gt; y &lt;- x + 10\n\n\n \nLo contrario de analizar es deparsear: dada una expresión, desea la cadena que la generaría. Esto sucede automáticamente cuando imprime una expresión, y puede obtener la cadena con rlang::expr_text():\n\nz &lt;- expr(y &lt;- x + 10)\nexpr_text(z)\n#&gt; [1] \"y &lt;- x + 10\"\n\nEl análisis y la eliminación no son perfectamente simétricos porque el análisis genera un árbol de sintaxis abstracto. Esto significa que perdemos los acentos graves en los nombres, comentarios y espacios en blanco ordinarios:\n\ncat(expr_text(expr({\n  # This is a comment\n  x &lt;-             `x` + 1\n})))\n#&gt; {\n#&gt;     x &lt;- x + 1\n#&gt; }\n\n\n\nTenga cuidado al usar el equivalente base R, deparse(): devuelve un vector de caracteres con un elemento para cada línea. Siempre que lo use, recuerde que la longitud de la salida puede ser mayor que uno y planifique en consecuencia.\n\n\n\n18.4.4 Ejercicios\n\nR usa paréntesis de dos maneras ligeramente diferentes, como se ilustra en estas dos llamadas:\n\nf((1))\n`(`(1 + 1)\n\nCompare y contraste los dos usos haciendo referencia al AST.\n= también se puede utilizar de dos maneras. Construya un ejemplo simple que muestre ambos usos.\n¿-2^2 produce 4 o -4? ¿Por qué?\n¿Qué devuelve !1 + !1? ¿Por qué?\n¿Por qué x1 &lt;- x2 &lt;- x3 &lt;- 0 funciona? Describe las dos razones.\nCompara los AST de x + y %+% z y x ^ y %+% z. ¿Qué has aprendido sobre la precedencia de las funciones de infijo personalizadas?\n¿Qué sucede si llamas a parse_expr() con una cadena que genera múltiples expresiones? p.ej. parse_expr(\"x + 1; y + 1\")\n¿Qué sucede si intenta analizar una expresión no válida? p.ej. \"a +\" o \"f())\".\ndeparse() produce vectores cuando la entrada es larga. Por ejemplo, la siguiente llamada produce un vector de longitud dos:\n\nexpr &lt;- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + \n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\n\ndeparse(expr)\n\n¿Qué hace expr_text() en su lugar?\npairwise.t.test() asume que deparse() siempre devuelve un vector de un carácter de longitud. ¿Puedes construir una entrada que viole esta expectativa? ¿Lo que sucede?",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Expressions.html#sec-ast-funs",
    "href": "Expressions.html#sec-ast-funs",
    "title": "18  Expresiones",
    "section": "18.5 Walking AST con funciones recursivas",
    "text": "18.5 Walking AST con funciones recursivas\n \nPara concluir el capítulo, voy a utilizar todo lo que ha aprendido sobre los AST para resolver problemas más complicados. La inspiración proviene del paquete de herramientas de código base, que proporciona dos funciones interesantes:\n\nfindGlobals() localiza todas las variables globales utilizadas por una función. Esto puede ser útil si desea verificar que su función no dependa inadvertidamente de variables definidas en su entorno principal.\ncheckUsage() comprueba una variedad de problemas comunes, incluidas las variables locales no utilizadas, los parámetros no utilizados y el uso de coincidencias de argumentos parciales.\n\nObtener todos los detalles de estas funciones correctamente es complicado, por lo que no desarrollaremos completamente las ideas. En su lugar, nos centraremos en la gran idea subyacente: la recursividad en el AST. Las funciones recursivas se ajustan naturalmente a las estructuras de datos de tipo árbol porque una función recursiva se compone de dos partes que corresponden a las dos partes del árbol:\n\nEl caso recursivo maneja los nodos en el árbol. Por lo general, hará algo con cada hijo de un nodo, por lo general llamando a la función recursiva nuevamente, y luego combinará los resultados nuevamente. Para las expresiones, deberá manejar llamadas y listas de pares (argumentos de función).\nEl caso base maneja las hojas del árbol. Los casos base aseguran que la función eventualmente termine, resolviendo directamente los casos más simples. Para las expresiones, debe manejar símbolos y constantes en el caso base.\n\nPara que este patrón sea más fácil de ver, necesitaremos dos funciones auxiliares. Primero definimos expr_type() que devolverá “constante” para constante, “símbolo” para símbolos, “call”, para llamadas, “pairlist” para listas de pares y el “tipo” de cualquier otra cosa:\n\nexpr_type &lt;- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nexpr_type(expr(\"a\"))\n#&gt; [1] \"constant\"\nexpr_type(expr(x))\n#&gt; [1] \"symbol\"\nexpr_type(expr(f(1, 2)))\n#&gt; [1] \"call\"\n\nCombinaremos esto con un contenedor alrededor de la función de cambio:\n\nswitch_expr &lt;- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\n\nCon estas dos funciones en la mano, podemos escribir una plantilla básica para cualquier función que recorra el AST usando switch() (Sección 5.2.3):\n\nrecurse_call &lt;- function(x) {\n  switch_expr(x,\n    # Casos base\n    symbol = ,\n    constant = ,\n\n    # Casos recursivos\n    call = ,\n    pairlist =\n  )\n}\n\nPor lo general, resolver el caso base es fácil, así que lo haremos primero y luego verificaremos los resultados. Los casos recursivos son más complicados y, a menudo, requerirán alguna programación funcional.\n\n18.5.1 Encontrar F y T\nComenzaremos con una función que determina si otra función usa las abreviaturas lógicas T y F porque usarlas a menudo se considera una mala práctica de codificación. Nuestro objetivo es devolver TRUE si la entrada contiene una abreviatura lógica y FALSE en caso contrario.\nPrimero encontremos el tipo de T versus TRUE:\n\nexpr_type(expr(TRUE))\n#&gt; [1] \"constant\"\n\nexpr_type(expr(T))\n#&gt; [1] \"symbol\"\n\nTRUE se analiza como un vector lógico de longitud uno, mientras que T se analiza como un nombre. Esto nos dice cómo escribir nuestros casos base para la función recursiva: una constante nunca es una abreviatura lógica, y un símbolo es una abreviatura si es “F” o “T”:\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\")\n  )\n}\n\nlogical_abbr_rec(expr(TRUE))\n#&gt; [1] FALSE\nlogical_abbr_rec(expr(T))\n#&gt; [1] TRUE\n\nHe escrito la función logical_abbr_rec() asumiendo que la entrada será una expresión, ya que esto simplificará la operación recursiva. Sin embargo, cuando se escribe una función recursiva, es común escribir un contenedor que proporciona valores predeterminados o hace que la función sea un poco más fácil de usar. Aquí normalmente crearemos un envoltorio que cita su entrada (aprenderemos más sobre eso en el próximo capítulo), por lo que no necesitamos usar expr() cada vez.\n\nlogical_abbr &lt;- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nlogical_abbr(T)\n#&gt; [1] TRUE\nlogical_abbr(FALSE)\n#&gt; [1] FALSE\n\nA continuación, debemos implementar los casos recursivos. Aquí queremos hacer lo mismo para las llamadas y para las listas de pares: aplique recursivamente la función a cada subcomponente y devuelva TRUE si algún subcomponente contiene una abreviatura lógica. Esto se facilita con purrr::some(), que itera sobre una lista y devuelve TRUE si la función de predicado es verdadera para cualquier elemento.\n\nlogical_abbr_rec &lt;- function(x) {\n  switch_expr(x,\n    # Casos base\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Casos recursivos\n    call = ,\n    pairlist = purrr::some(x, logical_abbr_rec)\n  )\n}\n\nlogical_abbr(mean(x, na.rm = T))\n#&gt; [1] TRUE\nlogical_abbr(function(x, na.rm = T) FALSE)\n#&gt; [1] TRUE\n\n\n\n18.5.2 Encontrar todas las variables creadas por asignación\nlogical_abbr() es relativamente simple: solo devuelve un solo TRUE o FALSE. La siguiente tarea, enumerar todas las variables creadas por asignación, es un poco más complicada. Comenzaremos de manera simple y luego haremos que la función sea progresivamente más rigurosa. \nComenzamos mirando el AST para la asignación:\n\nast(x &lt;- 10)\n#&gt; █─`&lt;-` \n#&gt; ├─x \n#&gt; └─10\n\nLa asignación es un objeto de llamada donde el primer elemento es el símbolo &lt;-, el segundo es el nombre de la variable y el tercero es el valor a asignar.\nA continuación, debemos decidir qué estructura de datos vamos a utilizar para los resultados. Aquí creo que será más fácil si devolvemos un vector de caracteres. Si devolvemos símbolos, necesitaremos usar una list() y eso hace las cosas un poco más complicadas.\nCon eso en la mano, podemos comenzar implementando los casos base y proporcionando un envoltorio útil alrededor de la función recursiva. Aquí los casos base son sencillos porque sabemos que ni un símbolo ni una constante representan una asignación.\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = ,\n    symbol = character()\n  )\n}\nfind_assign &lt;- function(x) find_assign_rec(enexpr(x))\n\nfind_assign(\"x\")\n#&gt; character(0)\nfind_assign(x)\n#&gt; character(0)\n\nA continuación implementamos los casos recursivos. Esto es más fácil gracias a una función que debería existir en purrr, pero actualmente no existe. flat_map_chr() espera que .f devuelva un vector de caracteres de longitud arbitraria y aplana todos los resultados en un solo vector de caracteres.\n\n\nflat_map_chr &lt;- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nflat_map_chr(letters[1:3], ~ rep(., sample(3, 1)))\n#&gt; [1] \"a\" \"b\" \"b\" \"b\" \"c\" \"c\" \"c\"\n\nEl caso recursivo para las listas de pares es sencillo: iteramos sobre cada elemento de la lista de pares (es decir, cada argumento de función) y combinamos los resultados. El caso de las llamadas es un poco más complejo: si se trata de una llamada a &lt;- entonces deberíamos devolver el segundo elemento de la llamada:\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    # Casos base\n    constant = ,\n    symbol = character(),\n\n    # Casos recursivos\n    pairlist = flat_map_chr(as.list(x), find_assign_rec),\n    call = {\n      if (is_call(x, \"&lt;-\")) {\n        as_string(x[[2]])\n      } else {\n        flat_map_chr(as.list(x), find_assign_rec)\n      }\n    }\n  )\n}\n\nfind_assign(a &lt;- 1)\n#&gt; [1] \"a\"\nfind_assign({\n  a &lt;- 1\n  {\n    b &lt;- 2\n  }\n})\n#&gt; [1] \"a\" \"b\"\n\nAhora necesitamos hacer que nuestra función sea más robusta al presentar ejemplos destinados a romperla. ¿Qué sucede cuando asignamos a la misma variable varias veces?\n\nfind_assign({\n  a &lt;- 1\n  a &lt;- 2\n})\n#&gt; [1] \"a\" \"a\"\n\nEs más fácil arreglar esto en el nivel de la función contenedora:\n\nfind_assign &lt;- function(x) unique(find_assign_rec(enexpr(x)))\n\nfind_assign({\n  a &lt;- 1\n  a &lt;- 2\n})\n#&gt; [1] \"a\"\n\n¿Qué sucede si tenemos llamadas anidadas a &lt;-? Actualmente solo devolvemos el primero. Eso es porque cuando ocurre &lt;- terminamos inmediatamente la recursividad.\n\nfind_assign({\n  a &lt;- b &lt;- c &lt;- 1\n})\n#&gt; [1] \"a\"\n\nEn su lugar, tenemos que adoptar un enfoque más riguroso. Creo que es mejor mantener la función recursiva enfocada en la estructura de árbol, así que voy a extraer find_assign_call() en una función separada.\n\nfind_assign_call &lt;- function(x) {\n  if (is_call(x, \"&lt;-\") && is_symbol(x[[2]])) {\n    lhs &lt;- as_string(x[[2]])\n    children &lt;- as.list(x)[-1]\n  } else {\n    lhs &lt;- character()\n    children &lt;- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec &lt;- function(x) {\n  switch_expr(x,\n    # Casos base\n    constant = ,\n    symbol = character(),\n\n    # Casos recursivos\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign(a &lt;- b &lt;- c &lt;- 1)\n#&gt; [1] \"a\" \"b\" \"c\"\nfind_assign(system.time(x &lt;- print(y &lt;- 5)))\n#&gt; [1] \"x\" \"y\"\n\nLa versión completa de esta función es bastante complicada, es importante recordar que la escribimos trabajando a nuestro modo escribiendo componentes simples.\n\n\n18.5.3 Ejercicios\n\nlogical_abbr() devuelve TRUE para T(1, 2, 3). ¿Cómo podrías modificar logical_abbr_rec() para que ignore las llamadas a funciones que usan T o F?\nlogical_abbr() trabaja con expresiones. Actualmente falla cuando le das una función. ¿Por qué? ¿Cómo podrías modificar logical_abbr() para que funcione? ¿Sobre qué componentes de una función necesitará recurrir?\n\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})\n\nModifique find_assign para detectar también la asignación usando funciones de reemplazo, es decir, names(x) &lt;- y.\nEscriba una función que extraiga todas las llamadas a una función específica.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Expressions.html#sec-expression-special",
    "href": "Expressions.html#sec-expression-special",
    "title": "18  Expresiones",
    "section": "18.6 Estructuras de datos especializadas",
    "text": "18.6 Estructuras de datos especializadas\nHay dos estructuras de datos y un símbolo especial que debemos cubrir en aras de la exhaustividad. No suelen ser importantes en la práctica.\n\n18.6.1 Listas de pares\n\nLas listas de pares son un remanente del pasado de R y han sido reemplazadas por listas en casi todas partes. El único lugar donde es probable que vea listas de pares en R4 es cuando trabaja con llamadas a la función función, ya que los argumentos formales de una función se almacenan en una lista de pares:\n\nf &lt;- expr(function(x, y = 10) x + y)\n\nargs &lt;- f[[2]]\nargs\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\n#&gt; [1] 10\ntypeof(args)\n#&gt; [1] \"pairlist\"\n\nAfortunadamente, cada vez que encuentre una lista de pares, puede tratarla como una lista normal:\n\npl &lt;- pairlist(x = 1, y = 2)\nlength(pl)\n#&gt; [1] 2\npl$x\n#&gt; [1] 1\n\nDetrás de escena, las listas de pares se implementan utilizando una estructura de datos diferente, una lista vinculada en lugar de una matriz. Eso hace que subdividir una lista de pares sea mucho más lento que subdividir una lista, pero esto tiene poco impacto práctico.\n\n\n18.6.2 Argumentos faltantes\n \nEl símbolo especial que necesita un poco más de discusión es el símbolo vacío, que se usa para representar argumentos faltantes (¡no valores faltantes!). Solo necesita preocuparse por el símbolo faltante si está creando funciones mediante programación con argumentos faltantes; volveremos a eso en la Sección 19.4.3.\nPuedes crear un símbolo vacío con missing_arg() (o expr()):\n\nmissing_arg()\ntypeof(missing_arg())\n#&gt; [1] \"symbol\"\n\nUn símbolo vacío no imprime nada, así que puedes comprobar si tienes uno con rlang::is_missing():\n\nis_missing(missing_arg())\n#&gt; [1] TRUE\n\nLos encontrará en la naturaleza en funciones formales:\n\nf &lt;- expr(function(x, y = 10) x + y)\nargs &lt;- f[[2]]\nis_missing(args[[1]])\n#&gt; [1] TRUE\n\nEsto es particularmente importante para ... que siempre está asociado con un símbolo vacío:\n\nf &lt;- expr(function(...) list(...))\nargs &lt;- f[[2]]\nis_missing(args[[1]])\n#&gt; [1] TRUE\n\nEl símbolo vacío tiene una propiedad peculiar: si lo vincula a una variable, luego accede a esa variable, obtendrá un error:\n\nm &lt;- missing_arg()\nm\n#&gt; Error in eval(expr, envir, enclos): argument \"m\" is missing, with no default\n\n¡Pero no lo hará si lo almacena dentro de otra estructura de datos!\n\nms &lt;- list(missing_arg(), missing_arg())\nms[[1]]\n\nSi necesita preservar la falta de una variable, rlang::maybe_missing() suele ser útil. Le permite referirse a una variable potencialmente faltante sin desencadenar el error. Consulte la documentación para casos de uso y más detalles.\n\n\n18.6.3 Vectores de expresión\n \nFinalmente, necesitamos discutir brevemente el vector de expresión. Los vectores de expresión solo son producidos por dos funciones base: expression() y parse():\n\nexp1 &lt;- parse(text = c(\"\nx &lt;- 4\nx\n\"))\nexp2 &lt;- expression(x &lt;- 4, x)\n\ntypeof(exp1)\n#&gt; [1] \"expression\"\ntypeof(exp2)\n#&gt; [1] \"expression\"\n\nexp1\n#&gt; expression(x &lt;- 4, x)\nexp2\n#&gt; expression(x &lt;- 4, x)\n\nAl igual que las llamadas y las listas de pares, los vectores de expresión se comportan como listas:\n\nlength(exp1)\n#&gt; [1] 2\nexp1[[1]]\n#&gt; x &lt;- 4\n\nConceptualmente, un vector de expresión es solo una lista de expresiones. La única diferencia es que llamar a eval() en una expresión evalúa cada expresión individual. No creo que esta ventaja merezca la introducción de una nueva estructura de datos, por lo que en lugar de vectores de expresión, solo uso listas de expresiones.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Expressions.html#footnotes",
    "href": "Expressions.html#footnotes",
    "title": "18  Expresiones",
    "section": "",
    "text": "Para un código más complejo, también puede usar el visor de árboles de RStudio, que no obedece a las mismas convenciones gráficas, pero le permite explorar de forma interactiva grandes AST. Pruébelo con View(expr(f(x, \"y\", 1))).↩︎\nLos nombres de las funciones sin prefijo no son sintácticos, por lo que los rodeo con ``, como en la Sección 2.2.1.↩︎\nCuriosamente, también puede ser un número, como en la expresión 3(). Pero esta llamada siempre fallará en la evaluación porque un número no es una función.↩︎\nSi está trabajando en C, encontrará listas de pares con más frecuencia. Por ejemplo, los objetos de llamada también se implementan mediante listas de pares.↩︎",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Expresiones</span>"
    ]
  },
  {
    "objectID": "Quotation.html",
    "href": "Quotation.html",
    "title": "19  Cuasicita",
    "section": "",
    "text": "19.1 Introducción\nAhora que comprende la estructura de árbol del código R, es hora de volver a una de las ideas fundamentales que hacen que ‘expr()’ y ‘ast()’ funcionen: citar (poner entre comillas). En una evaluación ordenada, todas las funciones de comillas son en realidad funciones de cuasicita porque también admiten la eliminación de comillas. Donde citar es el acto de capturar una expresión no evaluada, no citar es la capacidad de evaluar selectivamente partes de una expresión entrecomillada. En conjunto, esto se llama cuasicitar. La cuasicita facilita la creación de funciones que combinan código escrito por el autor de la función con código escrito por el usuario de la función. Esto ayuda a resolver una amplia variedad de problemas desafiantes.\nLa cuasicita es uno de los tres pilares de la evaluación ordenada. Aprenderá sobre los otros dos (cuotas y máscara de datos) en el Capítulo 20. Cuando se usa sola, la cuasicita es más útil para la programación, particularmente para generar código. Pero cuando se combina con otras técnicas, la evaluación ordenada se convierte en una poderosa herramienta para el análisis de datos.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#introducción",
    "href": "Quotation.html#introducción",
    "title": "19  Cuasicita",
    "section": "",
    "text": "Estructura\n\nLa Sección 19.2 motiva el desarrollo de la cuasicita con una función, cement(), que funciona como paste() pero cita automáticamente sus argumentos para que usted no tenga que hacerlo.\nLa Sección 19.3 le brinda las herramientas para citar expresiones, ya sea que provengan de usted o del usuario, o si usa herramientas rlang o base R.\nLa Sección 19.4 introduce la mayor diferencia entre las funciones de citar de rlang y la función de citar base: quitar las comillas con !! y !!!.\nLa Sección 19.5 analiza las tres técnicas principales sin comillas que utilizan las funciones base de R para deshabilitar el comportamiento de comillas.\nLa Sección 19.6 explora otro lugar donde puedes usar !!!, funciones que toman .... También presenta el operador especial :=, que le permite cambiar dinámicamente los nombres de los argumentos.\nLa Sección 19.7 algunos usos prácticos de las comillas para resolver problemas que naturalmente requieren cierta generación de código.\nLa Sección 19.8 termina con un poco de historia de la cuasicitación para aquellos que estén interesados.\n\n\n\nRequisitos previos\nAsegúrese de haber leído la descripción general de metaprogramación en el Capítulo 17 para obtener una descripción general amplia de la motivación y el vocabulario básico, y que esté familiarizado con la estructura de árbol de las expresiones como se describe en la Sección 18.3.\nEn cuanto al código, usaremos principalmente las herramientas de rlang, pero al final del capítulo también verá algunas aplicaciones poderosas junto con purrr.\n\nlibrary(rlang)\nlibrary(purrr)\n\n\n\nTrabajo relacionado\n \nLas funciones de citar tienen profundas conexiones con las macros de Lisp. Pero las macros generalmente se ejecutan en tiempo de compilación, que no existe en R, y siempre ingresan y generan AST. Consulte Lumley (2001) para conocer un enfoque para implementarlas en R. Las funciones de citar están más estrechamente relacionadas con las funciones más esotéricas de Lisp fexprs, donde todos los argumentos se citan por defecto. Es útil conocer estos términos cuando se busca trabajo relacionado en otros lenguajes de programación.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#sec-quasi-motivation",
    "href": "Quotation.html#sec-quasi-motivation",
    "title": "19  Cuasicita",
    "section": "19.2 Motivación",
    "text": "19.2 Motivación\nComenzaremos con un ejemplo concreto que ayuda a motivar la necesidad de eliminar las comillas y, por lo tanto, de las cuasicitas. Imagina que estás creando muchas cadenas uniendo palabras:\n\npaste(\"Good\", \"morning\", \"Hadley\")\n#&gt; [1] \"Good morning Hadley\"\npaste(\"Good\", \"afternoon\", \"Alice\")\n#&gt; [1] \"Good afternoon Alice\"\n\nEstás harto y cansado de escribir todas esas comillas y, en cambio, solo quieres usar palabras simples. Con ese fin, ha escrito la siguiente función. (No se preocupe por la implementación por ahora; aprenderá sobre las piezas más adelante).\n\ncement &lt;- function(...) {\n  args &lt;- ensyms(...)\n  paste(purrr::map(args, as_string), collapse = \" \")\n}\n\ncement(Good, morning, Hadley)\n#&gt; [1] \"Good morning Hadley\"\ncement(Good, afternoon, Alice)\n#&gt; [1] \"Good afternoon Alice\"\n\nFormalmente, esta función cita todas sus entradas. Puede pensar en ello como poner automáticamente comillas alrededor de cada argumento. Eso no es exactamente cierto ya que los objetos intermedios que genera son expresiones, no cadenas, pero es una aproximación útil y el significado raíz del término “cita”.\nEsta función es buena porque ya no necesitamos escribir comillas. El problema viene cuando queremos usar variables. Es fácil usar variables con paste(): simplemente no las rodee con comillas.\n\nname &lt;- \"Hadley\"\ntime &lt;- \"morning\"\n\npaste(\"Good\", time, name)\n#&gt; [1] \"Good morning Hadley\"\n\nObviamente, esto no funciona con cement() porque cada entrada se cita automáticamente:\n\ncement(Good, time, name)\n#&gt; [1] \"Good time name\"\n\nNecesitamos alguna forma de dejar de citar explícitamente la entrada para decirle a cement() que elimine las comillas automáticas. Aquí necesitamos que time y name se traten de manera diferente a Good. Cuasicitación nos da una herramienta estándar para hacerlo: !!, llamado “sin comillas”, y pronunciado bang-bang. !! le dice a una función de comillas que elimine las comillas implícitas:\n\ncement(Good, !!time, !!name)\n#&gt; [1] \"Good morning Hadley\"\n\nEs útil comparar cement() y paste() directamente. paste() evalúa sus argumentos, por lo que debemos citar donde sea necesario; cement() cita sus argumentos, por lo que debemos eliminar las comillas donde sea necesario.\n\npaste(\"Good\", time, name)\ncement(Good, !!time, !!name)\n\n\n19.2.1 Vocabulario\n \nLa distinción entre argumentos citados y evaluados es importante:\n\nUn argumento evaluado obedece las reglas de evaluación usuales de R.\nUn argumento citado es capturado por la función y lo procesa de manera personalizada.\n\npaste() evalúa todos sus argumentos; cement() cita todos sus argumentos.\nSi alguna vez no está seguro de si un argumento se cita o se evalúa, intente ejecutar el código fuera de la función. Si no funciona o hace algo diferente, entonces se cita ese argumento. Por ejemplo, puede usar esta técnica para determinar que se cita el primer argumento de library():\n\n# Funciona\nlibrary(MASS)\n\n# Falla\nMASS\n#&gt; Error in eval(expr, envir, enclos): object 'MASS' not found\n\nHablar sobre si un argumento se cita o se evalúa es una forma más precisa de establecer si una función utiliza o no una evaluación no estándar (NSE). A veces usaré “función de comillas” como abreviatura de una función que cita uno o más argumentos, pero en general, hablaré de argumentos citados, ya que ese es el nivel en el que se aplica la diferencia.\n\n\n19.2.2 Ejercicios\n\nPara cada función en el siguiente código base de R, identifique qué argumentos se citan y cuáles se evalúan.\n\nlibrary(MASS)\n\nmtcars2 &lt;- subset(mtcars, cyl == 4)\n\nwith(mtcars2, sum(vs))\nsum(mtcars2$am)\n\nrm(mtcars2)\n\nPara cada función en el siguiente código tidyverse, identifique qué argumentos se citan y cuáles se evalúan.\n\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl &lt;- mtcars %&gt;%\n  group_by(cyl) %&gt;%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) + geom_point()",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#sec-quoting",
    "href": "Quotation.html#sec-quoting",
    "title": "19  Cuasicita",
    "section": "19.3 Citar",
    "text": "19.3 Citar\n\nLa primera parte de la cuasicita es la cita: capturar una expresión sin evaluarla. Necesitaremos un par de funciones porque la expresión se puede proporcionar directa o indirectamente, a través de un argumento de función evaluado de forma perezosa. Comenzaré con las funciones de citar de rlang, luego regresaré a las proporcionadas por la base R.\n\n19.3.1 Captura de expresiones\n \nHay cuatro funciones de citar importantes. Para la exploración interactiva, el más importante es expr(), que captura su argumento exactamente como se proporciona:\n\nexpr(x + y)\n#&gt; x + y\nexpr(1 / 2 / 3)\n#&gt; 1/2/3\n\n(Recuerde que los espacios en blanco y los comentarios no forman parte de la expresión, por lo que no serán capturados por una función de comillas.)\nexpr() es excelente para la exploración interactiva, porque captura lo que usted, el desarrollador, escribió. No es tan útil dentro de una función:\n\nf1 &lt;- function(x) expr(x)\nf1(a + b + c)\n#&gt; x\n\n\nNecesitamos otra función para resolver este problema: enexpr(). Esto captura lo que la persona que llama proporcionó a la función mirando el objeto de promesa interno que impulsa la evaluación perezosa. (Sección 6.5.1).\n\nf2 &lt;- function(x) enexpr(x)\nf2(a + b + c)\n#&gt; a + b + c\n\n(Se llama “en”-expr() por analogía para enriquecer. Enriquecer a alguien lo hace más rico; enexpr() un argumento lo convierte en una expresión.)\nPara capturar todos los argumentos en ..., use enexprs().\n\nf &lt;- function(...) enexprs(...)\nf(x = 1, y = 10 * z)\n#&gt; $x\n#&gt; [1] 1\n#&gt; \n#&gt; $y\n#&gt; 10 * z\n\nFinalmente, exprs() es útil de forma interactiva para hacer una lista de expresiones:\n\nexprs(x = x ^ 2, y = y ^ 3, z = z ^ 4)\n# Forma abreviada de\n# list(x = expr(x ^ 2), y = expr(y ^ 3), z = expr(z ^ 4))\n\nEn resumen, use enexpr() y enexprs() para capturar las expresiones suministradas como argumentos por el usuario. Usa expr() y exprs() para capturar expresiones que tú proporcionas.\n\n\n19.3.2 Captura de símbolos\n \nA veces, solo desea permitir que el usuario especifique un nombre de variable, no una expresión arbitraria. En este caso, puede usar ensym() o ensyms(). Estas son variantes de enexpr() y enexprs() que comprueban que la expresión capturada es un símbolo o una cadena (que se convierte en un símbolo1). ensym() y ensyms() arrojan un error si se les da algo más.\n\nf &lt;- function(...) ensyms(...)\nf(x)\n#&gt; [[1]]\n#&gt; x\nf(\"x\")\n#&gt; [[1]]\n#&gt; x\n\n\n\n19.3.3 Con R base\n \nCada función rlang descrita anteriormente tiene un equivalente en base R. Su principal diferencia es que los equivalentes base no admiten la eliminación de comillas (de lo que hablaremos muy pronto). Esto las convierte en funciones de citar, en lugar de funciones de cuasicitación.\nEl equivalente básico de expr() es quote():\n\nquote(x + y)\n#&gt; x + y\n\nLa función base más cercana a enexpr() es substitute():\n\nf3 &lt;- function(x) substitute(x)\nf3(x + y)\n#&gt; x + y\n\n\nLa base equivalente a exprs() es alist():\n\nalist(x = 1, y = x + 2)\n#&gt; $x\n#&gt; [1] 1\n#&gt; \n#&gt; $y\n#&gt; x + 2\n\nEl equivalente a enexprs() es una característica no documentada de substitute()2:\n\nf &lt;- function(...) as.list(substitute(...()))\nf(x = 1, y = 10 * z)\n#&gt; $x\n#&gt; [1] 1\n#&gt; \n#&gt; $y\n#&gt; 10 * z\n\nHay otras dos importantes funciones de citar base que cubriremos en otra parte:\n\nbquote() proporciona una forma limitada de cuasicitación, y se analiza en la Sección 19.5.\n~, la fórmula, es una función de citar que también captura el entorno. Es la inspiración para quosures, el tema del próximo capítulo, y se discute en Sección 20.3.4.\n\n\n\n19.3.4 Sustitución\n\nLa mayoría de las veces verá que se usa substitute() para capturar argumentos no evaluados. Sin embargo, además de citar, substitute() también hace sustitución (¡como sugiere su nombre!). Si le da una expresión, en lugar de un símbolo, sustituirá los valores de los símbolos definidos en el entorno actual.\n\nf4 &lt;- function(x) substitute(x * 2)\nf4(a + b + c)\n#&gt; (a + b + c) * 2\n\nCreo que esto hace que el código sea difícil de entender, porque si se saca de contexto, no se puede saber si el objetivo de substitute(x + y) es reemplazar x, y o ambos. Si desea usar substitute() para la sustitución, le recomiendo que use el segundo argumento para dejar claro su objetivo:\n\nsubstitute(x * y * z, list(x = 10, y = quote(a + b)))\n#&gt; 10 * (a + b) * z\n\n\n\n19.3.5 Resumen\nAl citar (es decir, capturar código), hay dos distinciones importantes:\n\n¿Lo proporciona el desarrollador del código o el usuario del código? En otras palabras, ¿es fijo (suministrado en el cuerpo de la función) o variable (suministrado a través de un argumento)?\n¿Quieres capturar una sola expresión o múltiples expresiones?\n\nEsto conduce a una tabla de funciones de 2 \\(\\times\\) 2 para rlang, Tabla 19.1, y para R base, Tabla 19.2.\n\n\n\nTabla 19.1: Funciones de cuasicitar de rlang\n\n\n\n\n\n\nDesarrollador\nUsario\n\n\n\n\nUno\nexpr()\nenexpr()\n\n\nMuchos\nexprs()\nenexprs()\n\n\n\n\n\n\n\n\n\nTabla 19.2: Fuciones de cuasicitar de R base\n\n\n\n\n\n\nDesarrollador\nUsario\n\n\n\n\nUno\nquote()\nsubstitute()\n\n\nMuchos\nalist()\nas.list(substitute(...()))\n\n\n\n\n\n\n\n\n19.3.6 Ejercicios\n\n¿Cómo se implementa expr()? Mira su código fuente.\nCompara y contrasta las siguientes dos funciones. ¿Puedes predecir la salida antes de ejecutarlos?\n\nf1 &lt;- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 &lt;- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(a + b, c + d)\nf2(a + b, c + d)\n\n¿Qué sucede si intenta usar enexpr() con una expresión (es decir, enexpr(x + y)? ¿Qué sucede si enexpr() recibe un argumento faltante?\n¿En qué se diferencian exprs(a) y exprs(a = )? Piensa tanto en la entrada como en la salida.\n¿Cuáles son otras diferencias entre exprs() y alist()? Lea la documentación de los argumentos con nombre de exprs() para averiguarlo.\nLa documentación para substitute() dice:\n\nLa sustitución se lleva a cabo examinando cada componente del árbol de análisis de la siguiente manera:\n\nSi no es un símbolo enlazado en env, no cambia.\nSi es un objeto de promesa (es decir, un argumento formal para una función), el espacio de expresión de la promesa reemplaza al símbolo.\nSi es una variable ordinaria, se sustituye su valor, a menos que env sea .GlobalEnv, en cuyo caso el símbolo no se modifica.\n\n\nCree ejemplos que ilustren cada uno de los casos anteriores.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#sec-unquoting",
    "href": "Quotation.html#sec-unquoting",
    "title": "19  Cuasicita",
    "section": "19.4 Remover cita",
    "text": "19.4 Remover cita\n \nHasta ahora, solo ha visto ventajas relativamente pequeñas de las funciones de citar de rlang sobre las funciones de citar de base R: tienen un esquema de nomenclatura más consistente. La gran diferencia es que las funciones de comillas de rlang son en realidad funciones de cuasicita porque también pueden quitar las comillas.\nQuitar las comillas le permite evaluar de forma selectiva partes de la expresión que, de lo contrario, se citarían, lo que le permite fusionar AST con una plantilla AST. Dado que las funciones base no usan la eliminación de comillas, en su lugar usan una variedad de otras técnicas, que aprenderá en la Sección 19.5.\nQuitar las comillas te permite evaluar selectivamente el código dentro de expr(), de modo que expr(!!x) sea equivalente a x. En el Capítulo 20, aprenderá sobre otra evaluación inversa. Esto sucede fuera de expr(), por lo que eval(expr(x)) es equivalente a x.\n\n19.4.1 Remover cita de un argumento\n\nUse !! para eliminar las comillas de un solo argumento en una llamada de función. !! toma una sola expresión, la evalúa y alinea el resultado en el AST.\n\nx &lt;- expr(-1)\nexpr(f(!!x, y))\n#&gt; f(-1, y)\n\nCreo que esto es más fácil de entender con un diagrama. !! introduce un marcador de posición en el AST, que se muestra con bordes punteados. Aquí, el marcador de posición x se reemplaza por un AST, ilustrado por una conexión punteada.\n\n\n\n\n\n\n\n\n\nAdemás de llamar a objetos, !! también funciona con símbolos y constantes:\n\na &lt;- sym(\"y\")\nb &lt;- 1\nexpr(f(!!a, !!b))\n#&gt; f(y, 1)\n\n\n\n\n\n\n\n\n\n\nSi el lado derecho de !! es una llamada de función, !! lo evaluará e insertará los resultados:\n\nmean_rm &lt;- function(var) {\n  var &lt;- ensym(var)\n  expr(mean(!!var, na.rm = TRUE))\n}\nexpr(!!mean_rm(x) + !!mean_rm(y))\n#&gt; mean(x, na.rm = TRUE) + mean(y, na.rm = TRUE)\n\n!! conserva la precedencia del operador porque funciona con expresiones.\n\nx1 &lt;- expr(x + 1)\nx2 &lt;- expr(x + 2)\n\nexpr(!!x1 / !!x2)\n#&gt; (x + 1)/(x + 2)\n\n\n\n\n\n\n\n\n\n\nSi simplemente pegáramos el texto de las expresiones juntas, terminaríamos con x + 1 / x + 2, que tiene un AST muy diferente:\n\n\n\n\n\n\n\n\n\n\n\n19.4.2 Remover citas de una función\n\n!! se usa más comúnmente para reemplazar los argumentos de una función, pero también puede usarlo para reemplazar la función. El único desafío aquí es la precedencia de los operadores: expr(!!f(x, y)) elimina las comillas del resultado de f(x, y), por lo que necesita un par de paréntesis extra.\n\nf &lt;- expr(foo)\nexpr((!!f)(x, y))\n#&gt; foo(x, y)\n\nEsto también funciona cuando f es una llamada:\n\nf &lt;- expr(pkg::foo)\nexpr((!!f)(x, y))\n#&gt; pkg::foo(x, y)\n\n\n\n\n\n\n\n\n\n\nDebido a la gran cantidad de paréntesis involucrados, puede ser más claro usar rlang::call2():\n\nf &lt;- expr(pkg::foo)\ncall2(f, expr(x), expr(y))\n#&gt; pkg::foo(x, y)\n\n\n\n19.4.3 Remover cita de un argumento faltante\n \nMuy ocasionalmente, es útil quitar las comillas de un argumento faltante (Sección 18.6.2), pero el enfoque ingenuo no funciona:\n\narg &lt;- missing_arg()\nexpr(foo(!!arg, !!arg))\n#&gt; Error in eval(expr, envir, enclos): argument \"arg\" is missing, with no default\n\nPuedes solucionar esto con el ayudante rlang::maybe_missing():\n\nexpr(foo(!!maybe_missing(arg), !!maybe_missing(arg)))\n#&gt; foo(, )\n\n\n\n19.4.4 Remover cita de formas especiales\n \nHay algunas formas especiales en las que quitar las comillas es un error de sintaxis. Tome $ por ejemplo: siempre debe ir seguido del nombre de una variable, no de otra expresión. Esto significa que intentar quitar las comillas con $ fallará con un error de sintaxis:\nexpr(df$!!x)\n#&gt; Error: unexpected '!' in \"expr(df$!\"\nPara que la eliminación de comillas funcione, deberá usar la forma de prefijo (Sección 6.8.1):\n\nx &lt;- expr(x)\nexpr(`$`(df, !!x))\n#&gt; df$x\n\n\n\n19.4.5 Remover cita de muchos argumentos\n\n \n!! es un reemplazo uno a uno. !!! (llamado “remover cita en conjunto”, y pronunciado bang-bang-bang) es un reemplazo de uno a muchos. Toma una lista de expresiones y las inserta en la ubicación del !!!:\n\n\nxs &lt;- exprs(1, a, -b)\nexpr(f(!!!xs, y))\n#&gt; f(1, a, -b, y)\n\n# O con nombres\nys &lt;- set_names(xs, c(\"a\", \"b\", \"c\"))\nexpr(f(!!!ys, d = 4))\n#&gt; f(a = 1, b = a, c = -b, d = 4)\n\n\n\n\n\n\n\n\n\n\n!!! se puede usar en cualquier función rlang que tome ... independientemente de si se cita o evalúa ... o no. Volveremos a esto en la Sección 19.6; por ahora tenga en cuenta que esto puede ser útil en call2().\n\ncall2(\"f\", !!!xs, expr(y))\n#&gt; f(1, a, -b, y)\n\n\n\n19.4.6 La ficción educada de !!\nHasta ahora hemos actuado como si !! y !!! fueran operadores de prefijos regulares como +, - y !. No lo son. Desde la perspectiva de R, !! y !!! son simplemente la aplicación repetida de !:\n\n!!TRUE\n#&gt; [1] TRUE\n!!!TRUE\n#&gt; [1] FALSE\n\n!! y !!! se comportan especialmente dentro de todas las funciones de citar impulsadas por rlang, donde se comportan como operadores reales con precedencia equivalente a + y - unarios. Esto requiere un trabajo considerable dentro de rlang, pero significa que puedes escribir !!x + !!y en lugar de (!!x) + (!!y).\nLa mayor desventaja3 de usar un operador falso es que puede obtener errores silenciosos al usar incorrectamente !! fuera de las funciones de cuasicitas. La mayoría de las veces esto no es un problema porque ‘!!’ se usa típicamente para eliminar las comillas de expresiones o quóstulas. Dado que el operador de negación no admite expresiones, obtendrá un error de tipo de argumento en este caso:\n\nx &lt;- quote(variable)\n!!x\n#&gt; Error in !x: invalid argument type\n\nPero puede obtener resultados incorrectos en silencio cuando trabaja con valores numéricos:\n\ndf &lt;- data.frame(x = 1:5)\ny &lt;- 100\nwith(df, x + !!y)\n#&gt; [1] 2 3 4 5 6\n\nDados estos inconvenientes, es posible que se pregunte por qué introdujimos una nueva sintaxis en lugar de usar llamadas a funciones normales. De hecho, las primeras versiones de la evaluación ordenada usaban llamadas a funciones como UQ() y UQS(). Sin embargo, en realidad no son llamadas de función, y fingir que lo son conduce a un modo mental engañoso. Elegimos !! y !!! como la solución menos mala:\n\nSon visualmente fuertes y no se parecen a la sintaxis existente. Cuando vea !!x o !!!x, está claro que algo inusual está sucediendo.\nAnulan una parte de la sintaxis que rara vez se usa, ya que la doble negación no es un patrón común en R4. Si lo necesita, puede agregar paréntesis !(!x).\n\n\n\n19.4.7 AST no estándar\n\nSin comillas, es fácil crear AST no estándar, es decir, AST que contienen componentes que no son expresiones. (También es posible crear AST no estándar manipulando directamente los objetos subyacentes, pero es más difícil hacerlo accidentalmente). Estos son válidos y ocasionalmente útiles, pero su uso correcto está más allá del alcance de este libro. Sin embargo, es importante aprender acerca de ellos, porque se pueden dividir y, por lo tanto, imprimir de manera engañosa.\nPor ejemplo, si alinea objetos más complejos, sus atributos no se imprimen. Esto puede conducir a resultados confusos:\n\nx1 &lt;- expr(class(!!data.frame(x = 10)))\nx1\n#&gt; class(list(x = 10))\neval(x1)\n#&gt; [1] \"data.frame\"\n\nTienes dos herramientas principales para reducir esta confusión: rlang::expr_print() y lobstr::ast():\n\nexpr_print(x1)\n#&gt; class(&lt;df[,1]&gt;)\nlobstr::ast(!!x1)\n#&gt; █─class \n#&gt; └─&lt;inline data.frame&gt;\n\nOtro caso confuso surge si alinea una secuencia de enteros:\n\nx2 &lt;- expr(f(!!c(1L, 2L, 3L, 4L, 5L)))\nx2\n#&gt; f(1:5)\nexpr_print(x2)\n#&gt; f(&lt;int: 1L, 2L, 3L, 4L, 5L&gt;)\nlobstr::ast(!!x2)\n#&gt; █─f \n#&gt; └─&lt;inline integer&gt;\n\nTambién es posible crear AST regulares que no se pueden generar a partir del código debido a la precedencia del operador. En este caso, R imprimirá paréntesis que no existen en el AST:\n\nx3 &lt;- expr(1 + !!expr(2 + 3))\nx3\n#&gt; 1 + (2 + 3)\n\nlobstr::ast(!!x3)\n#&gt; █─`+` \n#&gt; ├─1 \n#&gt; └─█─`+` \n#&gt;   ├─2 \n#&gt;   └─3\n\n\n\n19.4.8 Ejercicios\n\nDados los siguientes componentes:\n\nxy &lt;- expr(x + y)\nxz &lt;- expr(x + z)\nyz &lt;- expr(y + z)\nabc &lt;- exprs(a, b, c)\n\nUtilice la cuasicita para construir las siguientes llamadas:\n\n(x + y) / (y + z)\n-(x + z) ^ (y + z)\n(x + y) + (y + z) - (x + y)\natan2(x + y, y + z)\nsum(x + y, x + y, y + z)\nsum(a, b, c)\nmean(c(a, b, c), na.rm = TRUE)\nfoo(a = x + y, b = y + z)\n\nLas siguientes dos llamadas imprimen lo mismo, pero en realidad son diferentes:\n\n(a &lt;- expr(mean(1:10)))\n#&gt; mean(1:10)\n(b &lt;- expr(mean(!!(1:10))))\n#&gt; mean(1:10)\nidentical(a, b)\n#&gt; [1] FALSE\n\n¿Cual es la diferencia? ¿Cuál es más natural?",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#sec-base-nonquote",
    "href": "Quotation.html#sec-base-nonquote",
    "title": "19  Cuasicita",
    "section": "19.5 No citar",
    "text": "19.5 No citar\n\n\nBase R tiene una función que implementa la cuasicita: bquote(). Utiliza .() para quitar las comillas:\n\nxyz &lt;- bquote((x + y + z))\nbquote(-.(xyz) / 2)\n#&gt; -(x + y + z)/2\n\nbquote() no es utilizado por ninguna otra función en la base R y ha tenido un impacto relativamente pequeño en cómo se escribe el código R. Existen tres desafíos para el uso efectivo de bquote():\n\nSolo se usa fácilmente con su código; es difícil aplicarlo a un código arbitrario proporcionado por un usuario.\nNo proporciona un operador de empalme sin comillas que le permita quitar las comillas de varias expresiones almacenadas en una lista.\nCarece de la capacidad de manejar código acompañado de un entorno, lo cual es crucial para funciones que evalúan código en el contexto de un marco de datos, como subset() y amigos.\n\nLas funciones base que citan un argumento usan alguna otra técnica para permitir la especificación indirecta. Los enfoques de Base R desactivan selectivamente las comillas, en lugar de usar la eliminación de comillas, por lo que las llamo técnicas sin comillas.\nHay cuatro formas básicas que se ven en la base R:\n\nUn par de funciones de citar y no citar. Por ejemplo, $ tiene dos argumentos y el segundo argumento está entrecomillado. Esto es más fácil de ver si escribe en forma de prefijo: mtcars$cyl es equivalente a `$`(mtcars, cyl). Si quiere referirse a una variable indirectamente, use [[, ya que toma el nombre de una variable como una cadena.\n\nx &lt;- list(var = 1, y = 2)\nvar &lt;- \"y\"\n\nx$var\n#&gt; [1] 1\nx[[var]]\n#&gt; [1] 2\n\nHay otras tres funciones de citar estrechamente relacionadas con $: subset(), transform() y with(). Estos se ven como envoltorios alrededor de $ solo adecuados para uso interactivo, por lo que todos tienen la misma alternativa sin comillas: [\n&lt;-/assign() y ::/getExportedValue() work similarly to $/[. \nUn par de argumentos entre comillas y sin comillas. Por ejemplo, rm() le permite proporcionar nombres de variables simples en ..., o un vector de caracteres de nombres de variables en list:\n\nx &lt;- 1\nrm(x)\n\ny &lt;- 2\nvars &lt;- c(\"y\", \"vars\")\nrm(list = vars)\n\ndata() y save() funcionan de forma similar. \nUn argumento que controla si un argumento diferente está entre comillas o no. Por ejemplo, en library(), el argumento character.only controla el comportamiento de las comillas del primer argumento, package:\n\nlibrary(MASS)\n\npkg &lt;- \"MASS\"\nlibrary(pkg, character.only = TRUE)\n\ndemo(), detach(), example(), y require() funcionan de manera similar. \nCitar si falla la evaluación. Por ejemplo, el primer argumento de help() no está entrecomillado si se evalúa como una cadena; si la evaluación falla, se cita el primer argumento.\n\n# Muestra ayuda para var\nhelp(var)\n\nvar &lt;- \"mean\"\n# Muestra ayuda para la media\nhelp(var)\n\nvar &lt;- 10\n# Muestra ayuda para var\nhelp(var)\n\nls(), page(), y match.fun() funcionan de manera similar. \n\n\nOtra clase importante de funciones de citar son las funciones básicas de modelado y trazado, que siguen las llamadas reglas de evaluación estándar no estándar: http://developer.r-project.org/nonstandard-eval.pdf. Por ejemplo, lm() cita los argumentos weight y subset, y cuando se usa con un argumento de fórmula, la función de trazado cita los argumentos estéticos (col, cex, etc.). Toma el siguiente código: solo necesitamos col = Species en lugar de col = iris$Species.\n\npalette(RColorBrewer::brewer.pal(3, \"Set1\"))\nplot(\n  Sepal.Length ~ Petal.Length, \n  data = iris, \n  col = Species, \n  pch = 20, \n  cex = 2\n)\n\n\n\n\n\n\n\n\nEstas funciones no tienen opciones integradas para la especificación indirecta, pero aprenderá a simular la eliminación de comillas en la Sección 20.6.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#sec-tidy-dots",
    "href": "Quotation.html#sec-tidy-dots",
    "title": "19  Cuasicita",
    "section": "19.6 ... (dot-dot-dot)",
    "text": "19.6 ... (dot-dot-dot)\n\n\n\n!!! es útil porque no es raro tener una lista de expresiones que desea insertar en una llamada. Resulta que este patrón es común en otros lugares. Considere los siguientes dos problemas motivadores:\n\n¿Qué haces si los elementos que quieres poner en ... ya están almacenados en una lista? Por ejemplo, imagina que tienes una lista de data frames y deseas juntarlos con rbind():\n\ndfs &lt;- list(\n  a = data.frame(x = 1, y = 2),\n  b = data.frame(x = 3, y = 4)\n)\n\nPodrías resolver este caso específico con rbind(dfs$a, dfs$b), pero ¿cómo generalizas esa solución a una lista de longitud arbitraria?\n¿Qué hace si desea proporcionar el nombre del argumento indirectamente? Por ejemplo, imagine que desea crear un marco de datos de una sola columna donde el nombre de la columna se especifica en una variable:\n\nvar &lt;- \"x\"\nval &lt;- c(4, 3, 9)\n\nEn este caso, podría crear un marco de datos y luego cambiar los nombres (es decir, setNames(data.frame(val), var)), pero esto parece poco elegante. ¿Cómo podemos hacerlo mejor?\n\nUna forma de pensar en estos problemas es trazar paralelos explícitos con la cuasicitar:\n\nLa vinculación de filas de varios marcos de datos es como el empalme sin comillas: queremos incorporar elementos individuales de la lista en la llamada:\n\ndplyr::bind_rows(!!!dfs)\n#&gt;   x y\n#&gt; 1 1 2\n#&gt; 2 3 4\n\nCuando se usa en este contexto, el comportamiento de !!! se conoce como “salpicar” en Ruby, Go, PHP y Julia. Está estrechamente relacionado con *args (star-args) y **kwarg (star-star-kwargs) en Python, que a veces se denomina desempaquetado de argumentos. \nEl segundo problema es como quitar las comillas del lado izquierdo de =: en lugar de interpretar literalmente var, queremos usar el valor almacenado en la variable llamada var:\n\ntibble::tibble(!!var := val)\n#&gt; # A tibble: 3 × 1\n#&gt;       x\n#&gt;   &lt;dbl&gt;\n#&gt; 1     4\n#&gt; 2     3\n#&gt; 3     9\n\nTenga en cuenta el uso de := (pronunciado dos puntos-igual) en lugar de =. Desafortunadamente, necesitamos esta nueva operación porque la gramática de R no permite expresiones como nombres de argumentos:\n\ntibble::tibble(!!var = value)\n#&gt; Error: unexpected '=' in \"tibble::tibble(!!var =\"\n\n:= es como un órgano vestigial: es reconocido por el analizador de R, pero no tiene ningún código asociado. Parece un = pero permite expresiones en ambos lados, lo que lo convierte en una alternativa más flexible que =. Se usa en data.table por razones similares. \n\n\nBase R adopta un enfoque diferente, al que volveremos en la Sección 19.6.4.\nDecimos que las funciones que admiten estas herramientas, sin citar argumentos, tienen puntos ordenados5. Para obtener un comportamiento de puntos ordenados en su propia función, todo lo que necesita hacer es usar list2().\n\n19.6.1 Ejemplos\n\nUn lugar en el que podríamos usar list2() es crear un contenedor alrededor de attributes() que nos permita establecer atributos de manera flexible:\n\nset_attr &lt;- function(.x, ...) {\n  attr &lt;- rlang::list2(...)\n  attributes(.x) &lt;- attr\n  .x\n}\n\nattrs &lt;- list(x = 1, y = 2)\nattr_name &lt;- \"z\"\n\n1:10 %&gt;%\n  set_attr(w = 0, !!!attrs, !!attr_name := 3) %&gt;% \n  str()\n#&gt;  int [1:10] 1 2 3 4 5 6 7 8 9 10\n#&gt;  - attr(*, \"w\")= num 0\n#&gt;  - attr(*, \"x\")= num 1\n#&gt;  - attr(*, \"y\")= num 2\n#&gt;  - attr(*, \"z\")= num 3\n\n\n\n19.6.2 exec()\n¿Qué sucede si desea utilizar esta técnica con una función que no tiene puntos ordenados? Una opción es usar rlang::exec() para llamar a una función con algunos argumentos suministrados directamente (en ...) y otros indirectamente (en una lista):\n\n# Directamente\nexec(\"mean\", x = 1:10, na.rm = TRUE, trim = 0.1)\n#&gt; [1] 5.5\n\n# Indirectamente\nargs &lt;- list(x = 1:10, na.rm = TRUE, trim = 0.1)\nexec(\"mean\", !!!args)\n#&gt; [1] 5.5\n\n# Ambos\nparams &lt;- list(na.rm = TRUE, trim = 0.1)\nexec(\"mean\", x = 1:10, !!!params)\n#&gt; [1] 5.5\n\nrlang::exec() también hace posible proporcionar nombres de argumentos indirectamente:\n\narg_name &lt;- \"na.rm\"\narg_val &lt;- TRUE\nexec(\"mean\", 1:10, !!arg_name := arg_val)\n#&gt; [1] 5.5\n\nY finalmente, es útil si tiene un vector de nombres de funciones o una lista de funciones que desea llamar con los mismos argumentos:\n\nx &lt;- c(runif(10), NA)\nfuns &lt;- c(\"mean\", \"median\", \"sd\")\n\npurrr::map_dbl(funs, exec, x, na.rm = TRUE)\n#&gt; [1] 0.444 0.482 0.298\n\nexec() está estrechamente relacionado con call2(); donde call2() devuelve una expresión, exec() la evalúa.\n\n\n19.6.3 dots_list()\n\nlist2() proporciona otra característica útil: de forma predeterminada, ignorará cualquier argumento vacío al final. Esto es útil en funciones como tibble::tibble() porque significa que puedes cambiar fácilmente el orden de las variables sin preocuparte por la coma final:\n\n# Puede mover fácilmente x a la primera entrada:\ntibble::tibble(\n  y = 1:5,\n  z = 3:-1,\n  x = 5:1,\n)\n\n# Necesita eliminar la coma de z y agregar una coma a x\ndata.frame(\n  y = 1:5,\n  z = 3:-1,\n  x = 5:1\n)\n\nlist2() es un envoltorio alrededor de rlang::dots_list() con los valores predeterminados establecidos en las configuraciones más utilizadas. Puedes tener más control llamando a dots_list() directamente:\n\n.ignore_empty le permite controlar exactamente qué argumentos se ignoran. El valor predeterminado ignora un solo argumento final para obtener el comportamiento descrito anteriormente, pero puede optar por ignorar todos los argumentos faltantes o ninguno.\n.homonyms controla lo que sucede si varios argumentos usan el mismo nombre:\n\nstr(dots_list(x = 1, x = 2))\n#&gt; List of 2\n#&gt;  $ x: num 1\n#&gt;  $ x: num 2\nstr(dots_list(x = 1, x = 2, .homonyms = \"first\"))\n#&gt; List of 1\n#&gt;  $ x: num 1\nstr(dots_list(x = 1, x = 2, .homonyms = \"last\"))\n#&gt; List of 1\n#&gt;  $ x: num 2\nstr(dots_list(x = 1, x = 2, .homonyms = \"error\"))\n#&gt; Error:\n#&gt; ! Arguments in `...` must have unique names.\n#&gt; ✖ Multiple arguments named `x` at positions 1 and 2.\n\nSi hay argumentos vacíos que no se ignoran, .preserve_empty controla qué hacer con ellos. El valor predeterminado arroja un error; establecer .preserve_empty = TRUE en su lugar devuelve los símbolos que faltan. Esto es útil si estás usando dots_list() para generar llamadas a funciones.\n\n\n\n19.6.4 Con R base\n \nBase R proporciona una navaja suiza para resolver estos problemas: do.call(). do.call() tiene dos argumentos principales. El primer argumento, qué, da una función para llamar. El segundo argumento, args, es una lista de argumentos para pasar a esa función, por lo que do.call(\"f\", list(x, y, z)) es equivalente a f(x, y, z).\n\ndo.call() da una solución directa a rbind() juntando muchos marcos de datos:\n\ndo.call(\"rbind\", dfs)\n#&gt;   x y\n#&gt; a 1 2\n#&gt; b 3 4\n\nCon un poco más de trabajo, podemos usar do.call() para resolver el segundo problema. Primero creamos una lista de argumentos, luego le damos un nombre y luego usamos do.call():\n\nargs &lt;- list(val)\nnames(args) &lt;- var\n\ndo.call(\"data.frame\", args)\n#&gt;   x\n#&gt; 1 4\n#&gt; 2 3\n#&gt; 3 9\n\n\nAlgunas funciones básicas (incluidas interaction(), expand.grid(), options() y par()) usan un truco para evitar do.call(): si el primer componente de ... es una lista, tomarán sus componentes en lugar de mirar los otros elementos de .... La implementación se parece a esto:\n\nf &lt;- function(...) {\n  dots &lt;- list(...)\n  if (length(dots) == 1 && is.list(dots[[1]])) {\n    dots &lt;- dots[[1]]\n  }\n  \n  # Hacer algo\n  ...\n}\n\nOtro método para evitar do.call() se encuentra en la función RCurl::getURL() escrita por Duncan Temple Lang. getURL() toma tanto ... como .dots, que se concatenan entre sí y se parece a esto:\n\nf &lt;- function(..., .dots) {\n  dots &lt;- c(list(...), .dots)\n  # Hacer algo\n}\n\nEn el momento en que lo descubrí, encontré esta técnica particularmente convincente, por lo que puede verla utilizada en todo el tidyverse. Ahora, sin embargo, prefiero el enfoque descrito anteriormente.\n\n\n19.6.5 Ejercicios\n\nA continuación se muestra una forma de implementar exec(). Describa cómo funciona. ¿Cuáles son las ideas clave?\n\nexec &lt;- function(f, ..., .env = caller_env()) {\n  args &lt;- list2(...)\n  do.call(f, args, envir = .env)\n}\n\nLea atentamente el código fuente de interaction(), expand.grid() y par(). Compare y contraste las técnicas que usan para cambiar entre puntos y comportamiento de lista.\nExplique el problema con esta definición de set_attr()\n\nset_attr &lt;- function(x, ...) {\n  attr &lt;- rlang::list2(...)\n  attributes(x) &lt;- attr\n  x\n}\nset_attr(1:10, x = 10)\n#&gt; Error in attributes(x) &lt;- attr: attributes must be named",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#sec-expr-case-studies",
    "href": "Quotation.html#sec-expr-case-studies",
    "title": "19  Cuasicita",
    "section": "19.7 Casos de estudio",
    "text": "19.7 Casos de estudio\nPara concretar las ideas de la cuasicitación, esta sección contiene algunos pequeños estudios de casos que la utilizan para resolver problemas reales. Algunos de los estudios de casos también usan purrr: encuentro que la combinación de cuasicitación y programación funcional es particularmente elegante.\n\n19.7.1 lobstr::ast()\n\nLa cuasicita nos permite resolver un molesto problema con lobstr::ast(): ¿qué sucede si ya capturamos la expresión?\n\nz &lt;- expr(foo(x, y))\nlobstr::ast(z)\n#&gt; z\n\nDebido a que ast() cita su primer argumento, podemos usar !!:\n\nlobstr::ast(!!z)\n#&gt; █─foo \n#&gt; ├─x \n#&gt; └─y\n\n\n\n19.7.2 Map-reduce para generar código\nQuasiquotation nos brinda herramientas poderosas para generar código, particularmente cuando se combina con purrr::map() y purrr::reduce(). Por ejemplo, suponga que tiene un modelo lineal especificado por los siguientes coeficientes:\n\nintercept &lt;- 10\ncoefs &lt;- c(x1 = 5, x2 = -4)\n\nY quieres convertirlo en una expresión como 10 + (x1 * 5) + (x2 * -4). Lo primero que debemos hacer es convertir el vector de nombres de personajes en una lista de símbolos. rlang::syms() está diseñado precisamente para este caso:\n\ncoef_sym &lt;- syms(names(coefs))\ncoef_sym\n#&gt; [[1]]\n#&gt; x1\n#&gt; \n#&gt; [[2]]\n#&gt; x2\n\nA continuación, debemos combinar cada nombre de variable con su coeficiente. Podemos hacer esto combinando rlang::expr() con purrr::map2():\n\nsummands &lt;- map2(coef_sym, coefs, ~ expr((!!.x * !!.y)))\nsummands\n#&gt; [[1]]\n#&gt; (x1 * 5)\n#&gt; \n#&gt; [[2]]\n#&gt; (x2 * -4)\n\nEn este caso, el intercepto también es parte de la suma, aunque no implica una multiplicación. Simplemente podemos agregarlo al comienzo del vector summands:\n\nsummands &lt;- c(intercept, summands)\nsummands\n#&gt; [[1]]\n#&gt; [1] 10\n#&gt; \n#&gt; [[2]]\n#&gt; (x1 * 5)\n#&gt; \n#&gt; [[3]]\n#&gt; (x2 * -4)\n\nFinalmente, necesitamos reducir (Sección 9.5) los términos individuales en una sola suma sumando las piezas:\n\neq &lt;- reduce(summands, ~ expr(!!.x + !!.y))\neq\n#&gt; 10 + (x1 * 5) + (x2 * -4)\n\nPodríamos hacer esto aún más general al permitir que el usuario proporcione el nombre del coeficiente y, en lugar de asumir muchas variables diferentes, indexar en una sola.\n\nvar &lt;- expr(y)\ncoef_sym &lt;- map(seq_along(coefs), ~ expr((!!var)[[!!.x]]))\ncoef_sym\n#&gt; [[1]]\n#&gt; y[[1L]]\n#&gt; \n#&gt; [[2]]\n#&gt; y[[2L]]\n\nY termine envolviendo esto en una función:\n\nlinear &lt;- function(var, val) {\n  var &lt;- ensym(var)\n  coef_name &lt;- map(seq_along(val[-1]), ~ expr((!!var)[[!!.x]]))\n\n  summands &lt;- map2(val[-1], coef_name, ~ expr((!!.x * !!.y)))\n  summands &lt;- c(val[[1]], summands)\n\n  reduce(summands, ~ expr(!!.x + !!.y))\n}\n\nlinear(x, c(10, 5, -4))\n#&gt; 10 + (5 * x[[1L]]) + (-4 * x[[2L]])\n\nTenga en cuenta el uso de ensym(): queremos que el usuario proporcione el nombre de una sola variable, no una expresión más compleja.\n\n\n19.7.3 Cortar un arreglo\n\nUna herramienta ocasionalmente útil que falta en la base R es la capacidad de extraer una porción de una matriz dada una dimensión y un índice. Por ejemplo, nos gustaría escribir slice(x, 2, 1) para extraer el primer segmento a lo largo de la segunda dimensión, es decir, x[, 1, ]. Este es un problema moderadamente desafiante porque requiere trabajar con argumentos faltantes.\nTendremos que generar una llamada con varios argumentos faltantes. Primero generamos una lista de argumentos faltantes con rep() y missing_arg(), luego quitamos las comillas y los empalmamos en una llamada:\n\nindices &lt;- rep(list(missing_arg()), 3)\nexpr(x[!!!indices])\n#&gt; x[, , ]\n\nLuego usamos la asignación de subconjuntos para insertar el índice en la posición deseada:\n\nindices[[2]] &lt;- 1\nexpr(x[!!!indices])\n#&gt; x[, 1, ]\n\nLuego envolvemos esto en una función, usando un par de stopifnot()s para aclarar la interfaz:\n\nslice &lt;- function(x, along, index) {\n  stopifnot(length(along) == 1)\n  stopifnot(length(index) == 1)\n    \n  nd &lt;- length(dim(x))\n  indices &lt;- rep(list(missing_arg()), nd)\n  indices[[along]] &lt;- index\n  \n  expr(x[!!!indices])\n}\n\nx &lt;- array(sample(30), c(5, 2, 3))\nslice(x, 1, 3)\n#&gt; x[3, , ]\nslice(x, 2, 2)\n#&gt; x[, 2, ]\nslice(x, 3, 1)\n#&gt; x[, , 1]\n\nUn slice() real evaluaría la llamada generada (Capítulo 20), pero aquí creo que es más esclarecedor ver el código que se genera, ya que esa es la parte difícil del desafío.\n\n\n19.7.4 Creación de funciones\n \nOtra poderosa aplicación de las citas es la creación de funciones “a mano”, usando rlang::new_function(). Es una función que crea una función a partir de sus tres componentes (Sección 6.2.1): argumentos, cuerpo y (opcionalmente) un entorno:\n\nnew_function(\n  exprs(x = , y = ), \n  expr({x + y})\n)\n#&gt; function (x, y) \n#&gt; {\n#&gt;     x + y\n#&gt; }\n\nNB: Los argumentos vacíos en exprs() generan argumentos sin valores predeterminados.\nUn uso de new_function() es como una alternativa a las fábricas de funciones con argumentos escalares o de símbolos. Por ejemplo, podríamos escribir una función que genere funciones que eleven una función a la potencia de un número.\n\npower &lt;- function(exponent) {\n  new_function(\n    exprs(x = ), \n    expr({\n      x ^ !!exponent\n    }), \n    caller_env()\n  )\n}\npower(0.5)\n#&gt; function (x) \n#&gt; {\n#&gt;     x^0.5\n#&gt; }\n\nOtra aplicación de new_function() es para funciones que funcionan como graphics::curve(), que te permite trazar una expresión matemática sin crear una función:\n\ncurve(sin(exp(4 * x)), n = 1000)\n\n\n\n\n\n\n\n\nEn este código, x es un pronombre: no representa un solo valor concreto, sino que es un marcador de posición que varía en el rango de la gráfica. Una forma de implementar curve() es convertir esa expresión en una función con un solo argumento, x, y luego llamar a esa función:\n\ncurve2 &lt;- function(expr, xlim = c(0, 1), n = 100) {\n  expr &lt;- enexpr(expr)\n  f &lt;- new_function(exprs(x = ), expr)\n  \n  x &lt;- seq(xlim[1], xlim[2], length = n)\n  y &lt;- f(x)\n\n  plot(x, y, type = \"l\", ylab = expr_text(expr))\n}\ncurve2(sin(exp(4 * x)), n = 1000)\n\nLas funciones como curve() que usan una expresión que contiene un pronombre se conocen como funciones anafóricas6.\n\n\n19.7.5 Ejercicios\n\nEn el ejemplo del modelo lineal, podríamos reemplazar expr() en reduce(summands, ~ expr(!!.x + !!.y)) con call2(): reduce(summands, call2 , \"+\"). Compare y contraste los dos enfoques. ¿Cuál crees que es más fácil de leer?\nVuelva a implementar la transformación de Box-Cox definida a continuación usando la eliminación de comillas y new_function():\n\nbc &lt;- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}\n\nVuelva a implementar el compose() simple definido a continuación usando quasiquotation y new_function():\n\ncompose &lt;- function(f, g) {\n  function(...) f(g(...))\n}",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#sec-history",
    "href": "Quotation.html#sec-history",
    "title": "19  Cuasicita",
    "section": "19.8 Historia",
    "text": "19.8 Historia\nLa idea de la cuasicita es antigua. Fue desarrollado por primera vez por el filósofo Willard van Orman Quine7 a principios de la década de 1940. Es necesario en filosofía porque ayuda a delinear con precisión el uso y la mención de palabras, es decir, distinguir entre el objeto y las palabras que usamos para referirnos a ese objeto.\nQuasiquotation se utilizó por primera vez en un lenguaje de programación, Lisp, a mediados de la década de 1970 (Bawden 1999). Lisp tiene una función de comillas `, y usa , para quitar las comillas. La mayoría de los lenguajes con herencia Lisp se comportan de manera similar. Por ejemplo, Racket (` y @), Clojure (` y ~) y Julia (: y @) tienen herramientas de cuasicitación que difieren solo ligeramente de Lisp . Estos idiomas tienen una función de comillas simples y debe llamarla explícitamente.\nEn R, sin embargo, muchas funciones citan una o más entradas. Esto introduce ambigüedad (porque necesita leer la documentación para determinar si un argumento se cita o no), pero permite un código de exploración de datos conciso y elegante. En base R, solo una función admite la cuasicita: bquote(), escrita en 2003 por Thomas Lumley. Sin embargo, bquote() tiene algunas limitaciones importantes que le impidieron tener un gran impacto en el código R (Sección 19.5).\nMi intento de resolver estas limitaciones condujo al paquete lazyeval (2014-2015). Desafortunadamente, mi análisis del problema estaba incompleto y aunque lazyeval resolvió algunos problemas, creó otros. No fue hasta que comencé a trabajar con Lionel Henry en el problema que todas las piezas finalmente encajaron y creamos el marco de evaluación ordenado completo (2017). A pesar de la novedad de la evaluación ordenada, la enseño aquí porque es una teoría rica y poderosa que, una vez dominada, hace que muchos problemas difíciles sean mucho más fáciles.\n\n\n\n\nBawden, Alan. 1999. «Quasiquotation in Lisp». En PEPM ’99, 4-12. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.309.227.\n\n\nLumley, Thomas. 2001. «Programmer’s niche: Macros in R». R News 1 (3): 11-13. https://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Quotation.html#footnotes",
    "href": "Quotation.html#footnotes",
    "title": "19  Cuasicita",
    "section": "",
    "text": "Esto es por compatibilidad con la base R, que le permite proporcionar una cadena en lugar de un símbolo en muchos lugares: \"x\" &lt;- 1, \"foo\"(x, y), c(\"x\" = 1).↩︎\nDescubierto por Peter Meilstrup y descrito en R-devel el 2018-08-13.↩︎\nAntes de R 3.5.1, había otra desventaja importante: el analizador de R trataba !!x como !(!x). Esta es la razón por la que en las versiones antiguas de R es posible que vea paréntesis adicionales al imprimir expresiones. La buena noticia es que estos paréntesis no son reales y pueden ignorarse con seguridad la mayor parte del tiempo. La mala noticia es que se volverán reales si vuelves a analizar esa salida impresa en código R. Estas funciones de ida y vuelta no funcionarán como se espera, ya que !(!x) no elimina las comillas.↩︎\nA diferencia de, por ejemplo, Javascript, donde !!x es un atajo de uso común para convertir un número entero en un número lógico.↩︎\nEs cierto que este no es el nombre más creativo, pero sugiere claramente que es algo que se agregó a R después del hecho.↩︎\nAnaphoric proviene del término lingüístico “anáfora”, una expresión que depende del contexto. Las funciones anafóricas se encuentran en Arc (un lenguaje parecido a Lisp), Perl, y Clojure.↩︎\nEs posible que esté familiarizado con el nombre Quine de “quines”, programas de computadora que devuelven una copia de su propia fuente cuando se ejecutan.↩︎",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Cuasicita</span>"
    ]
  },
  {
    "objectID": "Evaluation.html",
    "href": "Evaluation.html",
    "title": "20  Evaluación",
    "section": "",
    "text": "20.1 Introducción\nEl inverso de la cita de cara al usuario es la no cita: le da al usuario la capacidad de evaluar selectivamente partes de un argumento citado de otro modo. El complemento de cotización para el desarrollador es la evaluación: esto le da al desarrollador la capacidad de evaluar expresiones citadas en entornos personalizados para lograr objetivos específicos.\nEste capítulo comienza con una discusión de la evaluación en su forma más pura. Aprenderá cómo eval() evalúa una expresión en un entorno, y luego cómo se puede usar para implementar una serie de importantes funciones básicas de R. Una vez que tenga los conceptos básicos bajo su cinturón, aprenderá las extensiones a la evaluación que se necesitan para la solidez. Hay dos grandes ideas nuevas:\nJuntos, la cuasicotización, las cuotas y las máscaras de datos forman lo que llamamos evaluación ordenada, o evaluación ordenada para abreviar. Tidy eval proporciona un enfoque basado en principios para la evaluación no estándar que hace posible el uso de dichas funciones de forma interactiva e integrada con otras funciones. La evaluación ordenada es la implicación práctica más importante de toda esta teoría, por lo que dedicaremos un poco de tiempo a explorar las implicaciones. El capítulo termina con una discusión de los enfoques relacionados más cercanos en base R, y cómo puede programar alrededor de sus inconvenientes.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Evaluation.html#introducción",
    "href": "Evaluation.html#introducción",
    "title": "20  Evaluación",
    "section": "",
    "text": "El quosure: una estructura de datos que captura una expresión junto con su entorno asociado, como se encuentra en los argumentos de función.\nLa máscara de datos, que facilita la evaluación de una expresión en el contexto de un marco de datos. Esto introduce una posible ambigüedad de evaluación que luego resolveremos con pronombres de datos.\n\n\n\nEstructura\n\nLa Sección 20.2 analiza los aspectos básicos de la evaluación usando eval() y muestra cómo puede usarlo para implementar funciones clave como local() y source().\nLa Sección 20.3 introduce una nueva estructura de datos, el quosure, que combina una expresión con un entorno. Aprenderá cómo capturar cuotas de promesas y evaluarlas usando rlang::eval_tidy().\nLa Sección 20.4 extiende la evaluación con la máscara de datos, lo que hace que sea trivial entremezclar símbolos vinculados en un entorno con variables que se encuentran en un marco de datos.\nLa Sección 20.5 muestra cómo usar la evaluación ordenada en la práctica, centrándose en el patrón común de citar y quitar las comillas, y cómo manejar la ambigüedad con los pronombres.\nLa Sección 20.6 vuelve a la evaluación en base R, analiza algunas de las desventajas y muestra cómo usar la cuasicita y la evaluación para envolver funciones que usan NSE.\n\n\n\nRequisitos previos\nDeberá estar familiarizado con el contenido del Capítulo 18 y el Capítulo 19, así como con la estructura de datos del entorno (Sección 7.2) y el entorno de la persona que llama (Sección 7.5).\nSeguiremos usando rlang y purrr.\n\nlibrary(rlang)\nlibrary(purrr)",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Evaluation.html#sec-eval",
    "href": "Evaluation.html#sec-eval",
    "title": "20  Evaluación",
    "section": "20.2 Conceptos básicos de evaluación",
    "text": "20.2 Conceptos básicos de evaluación\n \nAquí exploraremos los detalles de eval() que mencionamos brevemente en el último capítulo. Tiene dos argumentos clave: expr y env. El primer argumento, expr, es el objeto a evaluar, típicamente un símbolo o expresión1. Ninguna de las funciones de evaluación cita sus entradas, por lo que normalmente las usará con expr() o similar:\n\nx &lt;- 10\neval(expr(x))\n#&gt; [1] 10\n\ny &lt;- 2\neval(expr(x + y))\n#&gt; [1] 12\n\nEl segundo argumento, env, proporciona el entorno en el que debe evaluarse la expresión, es decir, dónde buscar los valores de x, y y +. De forma predeterminada, este es el entorno actual, es decir, el entorno de llamada de eval(), pero puede anularlo si lo desea:\n\neval(expr(x + y), env(x = 1000))\n#&gt; [1] 1002\n\nEl primer argumento se evalúa, no se cita, lo que puede generar resultados confusos una vez si usa un entorno personalizado y se olvida de citar manualmente:\n\neval(print(x + 1), env(x = 1000))\n#&gt; [1] 11\n#&gt; [1] 11\n\neval(expr(print(x + 1)), env(x = 1000))\n#&gt; [1] 1001\n\nAhora que ha visto los conceptos básicos, exploremos algunas aplicaciones. Nos centraremos principalmente en las funciones básicas de R que podría haber usado antes, volviendo a implementar los principios subyacentes usando rlang.\n\n20.2.1 Aplicar: local()\n\nA veces, desea realizar una parte del cálculo que crea algunas variables intermedias. Las variables intermedias no tienen un uso a largo plazo y podrían ser bastante grandes, por lo que preferiría no mantenerlas. Un enfoque es limpiar lo que ensucia usando rm(); otra es envolver el código en una función y simplemente llamarlo una vez. Un enfoque más elegante es usar local():\n\n# Limpiar variables creadas anteriormente\nrm(x, y)\n\nfoo &lt;- local({\n  x &lt;- 10\n  y &lt;- 200\n  x + y\n})\n\nfoo\n#&gt; [1] 210\nx\n#&gt; Error in eval(expr, envir, enclos): object 'x' not found\ny\n#&gt; Error in eval(expr, envir, enclos): object 'y' not found\n\nLa esencia de local() es bastante simple y se vuelve a implementar a continuación. Capturamos la expresión de entrada y creamos un nuevo entorno en el que evaluarla. Este es un nuevo entorno (por lo que la asignación no afecta el entorno existente) con el entorno de la persona que llama como padre (para que expr aún pueda acceder a las variables en ese entorno). Esto emula efectivamente la ejecución de expr como si estuviera dentro de una función (es decir, tiene un alcance léxico, Sección 6.4).\n\nlocal2 &lt;- function(expr) {\n  env &lt;- env(caller_env())\n  eval(enexpr(expr), env)\n}\n\nfoo &lt;- local2({\n  x &lt;- 10\n  y &lt;- 200\n  x + y\n})\n\nfoo\n#&gt; [1] 210\nx\n#&gt; Error in eval(expr, envir, enclos): object 'x' not found\ny\n#&gt; Error in eval(expr, envir, enclos): object 'y' not found\n\nComprender cómo funciona base::local() es más difícil, ya que usa eval() y substitute() juntos de formas bastante complicadas. Descubrir exactamente lo que está pasando es una buena práctica si realmente quiere comprender las sutilezas de substitute() y las funciones base eval(), por lo que se incluyen en los ejercicios a continuación.\n\n\n20.2.2 Aplicar: source()\n\nPodemos crear una versión simple de source() combinando eval() con parse_expr() de la Sección 18.4.3. Leemos el archivo desde el disco, usamos parse_expr() para analizar la cadena en una lista de expresiones y luego usamos eval() para evaluar cada elemento a su vez. Esta versión evalúa el código en el entorno de la persona que llama e invisiblemente devuelve el resultado de la última expresión en el archivo como base::source().\n\nsource2 &lt;- function(path, env = caller_env()) {\n  file &lt;- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs &lt;- parse_exprs(file)\n\n  res &lt;- NULL\n  for (i in seq_along(exprs)) {\n    res &lt;- eval(exprs[[i]], env)\n  }\n\n  invisible(res)\n}\n\nLa ‘source()’ real es considerablemente más complicada porque puede hacer eco de entrada y salida, y tiene muchas otras configuraciones que controlan su comportamiento.\n\nVectores de expresión \nbase::eval() tiene un comportamiento especial para la expresión vectores, evaluando cada componente a su vez. Esto lo convierte en una implementación muy compacta de source2() porque base::parse() también devuelve un objeto de expresión:\n\nsource3 &lt;- function(file, env = parent.frame()) {\n  lines &lt;- parse(file)\n  res &lt;- eval(lines, envir = env)\n  invisible(res)\n}\n\nMientras que source3() es considerablemente más conciso que source2(), esta es la única ventaja de los vectores de expresión. En general, no creo que este beneficio compense el costo de introducir una nueva estructura de datos y, por lo tanto, este libro evita el uso de vectores de expresión.\n\n\n\n20.2.3 Gotcha: function()\n \nHay un pequeño inconveniente que debe tener en cuenta si está utilizando eval() y expr() para generar funciones:\n\nx &lt;- 10\ny &lt;- 20\nf &lt;- eval(expr(function(x, y) !!x + !!y))\nf\n#&gt; function(x, y) !!x + !!y\n\nEsta función no parece funcionar, pero lo hace:\n\nf()\n#&gt; [1] 30\n\nEsto se debe a que, si está disponible, las funciones imprimen su atributo srcref (Sección 6.2.1), y debido a que srcref es una característica base de R, no reconoce las cuasicita.\nPara solucionar este problema, utilice new_function() (Sección 19.7.4) o elimine el atributo srcref:\n\nattr(f, \"srcref\") &lt;- NULL\nf\n#&gt; function (x, y) \n#&gt; 10 + 20\n\n\n\n20.2.4 Ejercicios\n\nLea atentamente la documentación de source(). ¿Qué entorno usa por defecto? ¿Qué sucede si proporciona local = TRUE? ¿Cómo se proporciona un entorno personalizado?\nPrediga los resultados de las siguientes líneas de código:\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n\nComplete los cuerpos de función a continuación para volver a implementar get() usando sym() y eval(), y assign() usando sym(), expr() y eval (). No se preocupe por las múltiples formas de elegir un entorno que admiten get() y assign(); suponga que el usuario lo proporciona explícitamente.\n\n# el nombre es una cadena\nget2 &lt;- function(name, env) {}\nassign2 &lt;- function(name, value, env) {}\n\nModifique source2() para que devuelva el resultado de todas las expresiones, no solo la última. ¿Puedes eliminar el bucle for?\nPodemos hacer que base::local() sea un poco más fácil de entender al distribuirlo en varias líneas:\n\nlocal3 &lt;- function(expr, envir = new.env()) {\n  call &lt;- substitute(eval(quote(expr), envir))\n  eval(call, envir = parent.frame())\n}\n\nExplique cómo funciona local() en palabras. (Sugerencia: es posible que desee print(call) para ayudar a comprender qué está haciendo substitute(), y lea la documentación para recordar de qué entorno se heredará new.env()).",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Evaluation.html#sec-quosures",
    "href": "Evaluation.html#sec-quosures",
    "title": "20  Evaluación",
    "section": "20.3 Quosures",
    "text": "20.3 Quosures\n\nCasi todos los usos de eval() implican tanto una expresión como un entorno. Este acoplamiento es tan importante que necesitamos una estructura de datos que pueda contener ambas piezas. Base R no tiene tal estructura 2, por lo que rlang llena el espacio con quosure, un objeto que contiene una expresión y un entorno. El nombre es un acrónimo de cita y cierre, porque un quosure cita la expresión y encierra el entorno. Quosures cosifica el objeto de promesa interna (Sección 6.5.1) en algo con lo que puede programar.\nEn esta sección, aprenderá cómo crear y manipular quosures, y un poco sobre cómo se implementan.\n\n20.3.1 Creando\n\nHay tres formas de crear quosures:\n\nUse enquo() y enquos() para capturar expresiones proporcionadas por el usuario. La gran mayoría de las cuotas deben crearse de esta manera.\n\nfoo &lt;- function(x) enquo(x)\nfoo(a + b)\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^a + b\n#&gt; env:  global\n\n\nquo() y quos() existen para coincidir con expr() y exprs(), pero se incluyen solo para completar y se necesitan muy raramente. Si te encuentras usándolos, piensa cuidadosamente si expr() y quitar las comillas cuidadosamente pueden eliminar la necesidad de capturar el entorno.\n\nquo(x + y + z)\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + y + z\n#&gt; env:  global\n\n\nnew_quosure() crear un quosure a partir de sus componentes: una expresión y un entorno. Esto rara vez se necesita en la práctica, pero es útil para el aprendizaje, por lo que se usa mucho en este capítulo.\n\nnew_quosure(expr(x + y), env(x = 1, y = 10))\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + y\n#&gt; env:  0x5638267622c0\n\n\n\n\n20.3.2 Evaluando\n \nLas cuotas se combinan con una nueva función de evaluación eval_tidy() que toma una única cuota en lugar de un par expresión-entorno. Es fácil de usar:\n\nq1 &lt;- new_quosure(expr(x + y), env(x = 1, y = 10))\neval_tidy(q1)\n#&gt; [1] 11\n\nPara este caso simple, eval_tidy(q1) es básicamente un atajo para eval(get_expr(q1), get_env(q1)). Sin embargo, tiene dos características importantes de las que aprenderá más adelante en el capítulo: admite quósures anidados (Sección 20.3.5) y pronombres (Sección 20.4.2).\n\n\n20.3.3 Puntos\n\nLos quosures suelen ser solo una conveniencia: hacen que el código sea más limpio porque solo tiene un objeto para pasar, en lugar de dos. Sin embargo, son esenciales cuando se trata de trabajar con ... porque es posible que cada argumento pasado a ... se asocie con un entorno diferente. En el siguiente ejemplo, tenga en cuenta que ambos quosures tienen la misma expresión, x, pero un entorno diferente:\n\nf &lt;- function(...) {\n  x &lt;- 1\n  g(..., f = x)\n}\ng &lt;- function(...) {\n  enquos(...)\n}\n\nx &lt;- 0\nqs &lt;- f(global = x)\nqs\n#&gt; &lt;list_of&lt;quosure&gt;&gt;\n#&gt; \n#&gt; $global\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x\n#&gt; env:  global\n#&gt; \n#&gt; $f\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x\n#&gt; env:  0x5638239a2fd0\n\nEso significa que cuando los evalúas, obtienes los resultados correctos:\n\nmap_dbl(qs, eval_tidy)\n#&gt; global      f \n#&gt;      0      1\n\nEvaluar correctamente los elementos de ... fue una de las motivaciones originales para el desarrollo de quosures.\n\n\n20.3.4 Bajo el capó\n \nQuosures se inspiró en las fórmulas de R, porque las fórmulas capturan una expresión y un entorno:\n\nf &lt;- ~runif(3)\nstr(f)\n#&gt; Class 'formula'  language ~runif(3)\n#&gt;   ..- attr(*, \".Environment\")=&lt;environment: R_GlobalEnv&gt;\n\nUna versión anterior de la evaluación ordenada usaba fórmulas en lugar de quosures, ya que una característica atractiva de ~ es que proporciona citas con una sola pulsación de tecla. Desafortunadamente, sin embargo, no hay una forma limpia de hacer que ~ sea una función de cuasicomillas.\nLas cuotas son una subclase de fórmulas:\n\nq4 &lt;- new_quosure(expr(x + y + z))\nclass(q4)\n#&gt; [1] \"quosure\" \"formula\"\n\nlo que significa que, bajo el capó, las coyunturas, como las fórmulas, son objetos de llamada:\n\nis_call(q4)\n#&gt; [1] TRUE\n\nq4[[1]]\n#&gt; Warning: Subsetting quosures with `[[` is deprecated as of rlang 0.4.0\n#&gt; Please use `quo_get_expr()` instead.\n#&gt; This warning is displayed once every 8 hours.\n#&gt; `~`\nq4[[2]]\n#&gt; x + y + z\n\ncon un atributo que almacena el entorno:\n\nattr(q4, \".Environment\")\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nSi necesita extraer la expresión o el entorno, no confíe en estos detalles de implementación. En su lugar, utilice get_expr() y get_env():\n\nget_expr(q4)\n#&gt; x + y + z\nget_env(q4)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n\n20.3.5 Cuosuras anidadas\n\nEs posible usar cuasicomillas para incrustar una quosure en una expresión. Esta es una herramienta avanzada, y la mayoría de las veces no necesita pensar en ella porque simplemente funciona, pero hablo de ella aquí para que pueda detectar quosures anidados en la naturaleza y no confundirse. Tome este ejemplo, que alinea dos quosures en una expresión:\n\nq2 &lt;- new_quosure(expr(x), env(x = 1))\nq3 &lt;- new_quosure(expr(x), env(x = 10))\n\nx &lt;- expr(!!q2 + !!q3)\n\nSe evalúa correctamente con eval_tidy():\n\neval_tidy(x)\n#&gt; [1] 11\n\nSin embargo, si lo imprime, solo verá las ‘x’, con la herencia de su fórmula filtrándose:\n\nx\n#&gt; (~x) + ~x\n\nPuede obtener una mejor visualización con rlang::expr_print() (Sección 19.4.7):\n\nexpr_print(x)\n#&gt; (^x) + (^x)\n\nCuando usa expr_print() en la consola, los quosures se colorean de acuerdo con su entorno, lo que facilita detectar cuándo los símbolos están vinculados a diferentes variables.\n\n\n20.3.6 Ejercicios\n\nPredecir lo que devolverá cada uno de los siguientes quosures si se evalúan.\n\nq1 &lt;- new_quosure(expr(x), env(x = 1))\nq1\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x\n#&gt; env:  0x5638258b6ad0\n\nq2 &lt;- new_quosure(expr(x + !!q1), env(x = 10))\nq2\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + (^x)\n#&gt; env:  0x563825a48430\n\nq3 &lt;- new_quosure(expr(x + !!q2), env(x = 100))\nq3\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + (^x + (^x))\n#&gt; env:  0x563825daa8b0\n\nEscriba una función enenv() que capture el entorno asociado con un argumento. (Sugerencia: esto solo debería requerir dos llamadas de función).",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Evaluation.html#sec-data-masks",
    "href": "Evaluation.html#sec-data-masks",
    "title": "20  Evaluación",
    "section": "20.4 Máscaras de datos",
    "text": "20.4 Máscaras de datos\n\nEn esta sección, aprenderá sobre la máscara de datos, un marco de datos donde el código evaluado buscará primero definiciones de variables. La máscara de datos es la idea clave que impulsa funciones básicas como with(), subset() y transform(), y se usa en todo el tidyverse en paquetes como dplyr y ggplot2.\n\n20.4.1 Lo escencial\n\nLa máscara de datos le permite combinar variables de un entorno y un marco de datos en una sola expresión. Usted proporciona la máscara de datos como segundo argumento para eval_tidy():\n\nq1 &lt;- new_quosure(expr(x * y), env(x = 100))\ndf &lt;- data.frame(y = 1:10)\n\neval_tidy(q1, df)\n#&gt;  [1]  100  200  300  400  500  600  700  800  900 1000\n\nEste código es un poco difícil de seguir porque hay mucha sintaxis ya que estamos creando cada objeto desde cero. Es más fácil ver lo que está pasando si hacemos un pequeño envoltorio. Llamo a esto with2() porque es equivalente a base::with(). \n\nwith2 &lt;- function(data, expr) {\n  expr &lt;- enquo(expr)\n  eval_tidy(expr, data)\n}\n\nAhora podemos reescribir el código anterior de la siguiente manera:\n\nx &lt;- 100\nwith2(df, x * y)\n#&gt;  [1]  100  200  300  400  500  600  700  800  900 1000\n\nbase::eval() tiene una funcionalidad similar, aunque no lo llama máscara de datos. En su lugar, puede proporcionar un marco de datos al segundo argumento y un entorno al tercero. Eso da la siguiente implementación de with():\n\nwith3 &lt;- function(data, expr) {\n  expr &lt;- substitute(expr)\n  eval(expr, data, caller_env())\n}\n\n\n\n20.4.2 Pronombres\n \nEl uso de una máscara de datos introduce ambigüedad. Por ejemplo, en el siguiente código no puede saber si x vendrá de la máscara de datos o del entorno, a menos que sepa qué variables se encuentran en df.\n\nwith2(df, x)\n\nEso hace que el código sea más difícil de razonar (porque necesita conocer más contexto), lo que puede introducir errores. Para resolver ese problema, la máscara de datos proporciona dos pronombres: .data y .env.\n\n.data$x siempre se refiere a x en la máscara de datos.\n.env$x siempre se refiere a x en el entorno.\n\n\nx &lt;- 1\ndf &lt;- data.frame(x = 2)\n\nwith2(df, .data$x)\n#&gt; [1] 2\nwith2(df, .env$x)\n#&gt; [1] 1\n\nTambién puede crear subconjuntos de .data y .env usando [[, p. .data[[\"x\"]]. De lo contrario, los pronombres son objetos especiales y no debe esperar que se comporten como marcos de datos o entornos. En particular, arrojan un error si no se encuentra el objeto:\n\nwith2(df, .data$y)\n#&gt; Error in `.data$y`:\n#&gt; ! Column `y` not found in `.data`.\n\n\n\n20.4.3 Aplicar: subset()\nExploraremos la evaluación ordenada en el contexto de base::subset(), porque es una función simple pero poderosa que facilita un desafío común de manipulación de datos. Si no lo ha usado antes, subset(), como dplyr::filter(), proporciona una manera conveniente de seleccionar filas de un marco de datos. Le das algunos datos, junto con una expresión que se evalúa en el contexto de esos datos. Esto reduce considerablemente la cantidad de veces que necesita escribir el nombre del marco de datos:\n\nsample_df &lt;- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))\n\n# Abreviatura para sample_df[sample_df$a &gt;= 4, ]\nsubset(sample_df, a &gt;= 4)\n#&gt;   a b c\n#&gt; 4 4 2 4\n#&gt; 5 5 1 1\n\n# Abreviatura para sample_df[sample_df$b == sample_df$c, ]\nsubset(sample_df, b == c)\n#&gt;   a b c\n#&gt; 1 1 5 5\n#&gt; 5 5 1 1\n\nEl núcleo de nuestra versión de subset(), subset2(), es bastante simple. Toma dos argumentos: un marco de datos, data, y una expresión, row. Evaluamos row usando df como una máscara de datos, luego usamos los resultados para dividir el marco de datos con [. He incluido una verificación muy simple para garantizar que el resultado sea un vector lógico; el código real haría más para crear un error informativo.\n\nsubset2 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  rows_val &lt;- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\nsubset2(sample_df, b == c)\n#&gt;   a b c\n#&gt; 1 1 5 5\n#&gt; 5 5 1 1\n\n\n\n20.4.4 Aplicar: transform\n\nUna situación más complicada es base::transform(), que te permite agregar nuevas variables a un marco de datos, evaluando sus expresiones en el contexto de las variables existentes:\n\ndf &lt;- data.frame(x = c(2, 3, 1), y = runif(3))\ntransform(df, x = -x, y2 = 2 * y)\n#&gt;    x      y    y2\n#&gt; 1 -2 0.0808 0.162\n#&gt; 2 -3 0.8343 1.669\n#&gt; 3 -1 0.6008 1.202\n\nDe nuevo, nuestro propio transform2() requiere poco código. Capturamos el ... no evaluado con enquos(...), y luego evaluamos cada expresión usando un bucle for. El código real haría más comprobaciones de errores para garantizar que cada entrada tenga un nombre y se evalúe como un vector de la misma longitud que data.\n\ntransform2 &lt;- function(.data, ...) {\n  dots &lt;- enquos(...)\n\n  for (i in seq_along(dots)) {\n    name &lt;- names(dots)[[i]]\n    dot &lt;- dots[[i]]\n\n    .data[[name]] &lt;- eval_tidy(dot, .data)\n  }\n\n  .data\n}\n\ntransform2(df, x2 = x * 2, y = -y)\n#&gt;   x       y x2\n#&gt; 1 2 -0.0808  4\n#&gt; 2 3 -0.8343  6\n#&gt; 3 1 -0.6008  2\n\nNB: Llamé al primer argumento .data para evitar problemas si los usuarios intentaran crear una variable llamada data. Todavía tendrán problemas si intentan crear una variable llamada .data, pero esto es mucho menos probable. Este es el mismo razonamiento que lleva a los argumentos .x y .f a map() (Sección 9.2.4).\n\n\n20.4.5 Aplicar: select()\n\nUna máscara de datos suele ser un marco de datos, pero a veces es útil proporcionar una lista llena de contenidos más exóticos. Básicamente, así es como funciona el argumento select en base::subset(). Te permite referirte a las variables como si fueran números:\n\ndf &lt;- data.frame(a = 1, b = 2, c = 3, d = 4, e = 5)\nsubset(df, select = b:d)\n#&gt;   b c d\n#&gt; 1 2 3 4\n\nLa idea clave es crear una lista con nombre donde cada componente proporcione la posición de la variable correspondiente:\n\nvars &lt;- as.list(set_names(seq_along(df), names(df)))\nstr(vars)\n#&gt; List of 5\n#&gt;  $ a: int 1\n#&gt;  $ b: int 2\n#&gt;  $ c: int 3\n#&gt;  $ d: int 4\n#&gt;  $ e: int 5\n\nLuego, la implementación es nuevamente solo unas pocas líneas de código:\n\nselect2 &lt;- function(data, ...) {\n  dots &lt;- enquos(...)\n\n  vars &lt;- as.list(set_names(seq_along(data), names(data)))\n  cols &lt;- unlist(map(dots, eval_tidy, vars))\n\n  data[, cols, drop = FALSE]\n}\nselect2(df, b:d)\n#&gt;   b c d\n#&gt; 1 2 3 4\n\ndplyr::select() toma esta idea y la ejecuta, proporcionando una serie de ayudantes que le permiten seleccionar variables en función de sus nombres (por ejemplo, starts_with(\"x\") o ends_with(\"_a\")).\n\n\n20.4.6 Ejercicios\n\n¿Por qué usé un bucle for en transform2() en lugar de map()? Considere transform2(df, x = x * 2, x = x * 2).\nAquí hay una implementación alternativa de subset2():\n\nsubset3 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)\n}\n\ndf &lt;- data.frame(x = 1:3)\nsubset3(df, x == 1)\n\nCompara y contrasta subset3() con subset2(). ¿Cuáles son sus ventajas y desventajas?\nLa siguiente función implementa los conceptos básicos de dplyr::arrange(). Anote cada línea con un comentario que explique lo que hace. ¿Puede explicar por qué !!.na.last es estrictamente correcto, pero es poco probable que omitir !! cause problemas?\n\narrange2 &lt;- function(.df, ..., .na.last = TRUE) {\n  args &lt;- enquos(...)\n\n  order_call &lt;- expr(order(!!!args, na.last = !!.na.last))\n\n  ord &lt;- eval_tidy(order_call, .df)\n  stopifnot(length(ord) == nrow(.df))\n\n  .df[ord, , drop = FALSE]\n}",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Evaluation.html#sec-tidy-evaluation",
    "href": "Evaluation.html#sec-tidy-evaluation",
    "title": "20  Evaluación",
    "section": "20.5 Usando una evaluación ordenada",
    "text": "20.5 Usando una evaluación ordenada\nSi bien es importante comprender cómo funciona eval_tidy(), la mayoría de las veces no lo llamará directamente. En su lugar, normalmente lo usará indirectamente llamando a una función que usa eval_tidy(). Esta sección brindará algunos ejemplos prácticos de funciones de envoltura que utilizan una evaluación ordenada.\n\n20.5.1 Citar y remover cita\n \nImagina que hemos escrito una función que vuelve a muestrear un conjunto de datos:\n\nresample &lt;- function(df, n) {\n  idx &lt;- sample(nrow(df), n, replace = TRUE)\n  df[idx, , drop = FALSE]\n}\n\nQueremos crear una nueva función que nos permita volver a muestrear y crear subconjuntos en un solo paso. Nuestro enfoque ingenuo no funciona:\n\nsubsample &lt;- function(df, cond, n = nrow(df)) {\n  df &lt;- subset2(df, cond)\n  resample(df, n)\n}\n\ndf &lt;- data.frame(x = c(1, 1, 1, 2, 2), y = 1:5)\nsubsample(df, x == 1)\n#&gt; Error in eval(expr, envir, enclos): object 'x' not found\n\nsubsample() no cita ningún argumento, por lo que cond se evalúa normalmente (no en una máscara de datos), y obtenemos un error cuando intenta encontrar un enlace para x. Para solucionar este problema, necesitamos citar cond, y luego quitarlo cuando lo pasemos a subset2():\n\nsubsample &lt;- function(df, cond, n = nrow(df)) {\n  cond &lt;- enquo(cond)\n\n  df &lt;- subset2(df, !!cond)\n  resample(df, n)\n}\n\nsubsample(df, x == 1)\n#&gt;   x y\n#&gt; 3 1 3\n#&gt; 1 1 1\n#&gt; 2 1 2\n\nEste es un patrón muy común; cada vez que llame a una función de cotización con argumentos del usuario, debe citarlos y luego quitarlos.\n\n\n\n20.5.2 Manejo de la ambigüedad\n\nEn el caso anterior, necesitábamos pensar en una evaluación ordenada debido a la cuasicita. También debemos pensar en una evaluación ordenada, incluso cuando el contenedor no necesita citar ningún argumento. Tome este envoltorio alrededor de subset2():\n\nthreshold_x &lt;- function(df, val) {\n  subset2(df, x &gt;= val)\n}\n\nEsta función puede devolver silenciosamente un resultado incorrecto en dos situaciones:\n\nCuando x existe en el entorno de llamada, pero no en df:\n\nx &lt;- 10\nno_x &lt;- data.frame(y = 1:3)\nthreshold_x(no_x, 2)\n#&gt;   y\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3\n\nCuando val existe en df:\n\nhas_val &lt;- data.frame(x = 1:3, val = 9:11)\nthreshold_x(has_val, 2)\n#&gt; [1] x   val\n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\n\nEstos modos de falla surgen porque la evaluación ordenada es ambigua: cada variable se puede encontrar en ya sea la máscara de datos o el entorno. Para que esta función sea segura, necesitamos eliminar la ambigüedad usando los pronombres .data y .env:\n\nthreshold_x &lt;- function(df, val) {\n  subset2(df, .data$x &gt;= .env$val)\n}\n\nx &lt;- 10\nthreshold_x(no_x, 2)\n#&gt; Error in `.data$x`:\n#&gt; ! Column `x` not found in `.data`.\nthreshold_x(has_val, 2)\n#&gt;   x val\n#&gt; 2 2  10\n#&gt; 3 3  11\n\nGeneralmente, cada vez que usa el pronombre .env, puede usar la eliminación de comillas en su lugar:\n\nthreshold_x &lt;- function(df, val) {\n  subset2(df, .data$x &gt;= !!val)\n}\n\nHay diferencias sutiles en cuando se evalúa val. Si elimina las comillas, val será evaluado antes por enquo(); si usa un pronombre, val será evaluado perezosamente por eval_tidy(). Estas diferencias generalmente no son importantes, así que elija la forma que se vea más natural.\n\n\n20.5.3 Citas y ambigüedad\nPara finalizar nuestra discusión, consideremos el caso en el que tenemos tanto citas como ambigüedad potencial. Generalizaré threshold_x() ligeramente para que el usuario pueda elegir la variable utilizada para el umbral. Aquí usé .data[[var]] porque hace que el código sea un poco más simple; en los ejercicios tendrá la oportunidad de explorar cómo podría usar $ en su lugar.\n\nthreshold_var &lt;- function(df, var, val) {\n  var &lt;- as_string(ensym(var))\n  subset2(df, .data[[var]] &gt;= !!val)\n}\n\ndf &lt;- data.frame(x = 1:10)\nthreshold_var(df, x, 8)\n#&gt;     x\n#&gt; 8   8\n#&gt; 9   9\n#&gt; 10 10\n\nNo siempre es responsabilidad del autor de la función evitar la ambigüedad. Imagine que generalizamos aún más para permitir el umbral basado en cualquier expresión:\n\nthreshold_expr &lt;- function(df, expr, val) {\n  expr &lt;- enquo(expr)\n  subset2(df, !!expr &gt;= !!val)\n}\n\nNo es posible evaluar expr solo en la máscara de datos, porque la máscara de datos no incluye ninguna función como + o ==. Aquí, es responsabilidad del usuario evitar ambigüedades. Como regla general, como autor de una función, es su responsabilidad evitar la ambigüedad con cualquier expresión que cree; es responsabilidad del usuario evitar la ambigüedad en las expresiones que crea.\n\n\n20.5.4 Ejercicios\n\nHe incluido una implementación alternativa de threshold_var() a continuación. ¿Qué lo hace diferente al enfoque que usé anteriormente? ¿Qué lo hace más difícil?\n\nthreshold_var &lt;- function(df, var, val) {\n  var &lt;- ensym(var)\n  subset2(df, `$`(.data, !!var) &gt;= !!val)\n}",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Evaluation.html#sec-base-evaluation",
    "href": "Evaluation.html#sec-base-evaluation",
    "title": "20  Evaluación",
    "section": "20.6 Evaluación base",
    "text": "20.6 Evaluación base\n\nAhora que comprende la evaluación ordenada, es hora de volver a los enfoques alternativos tomados por la base R. Aquí exploraré los dos usos más comunes en la base R:\n\nsubstitute() y evaluación en el entorno de la persona que llama, tal como lo utiliza subset(). Usaré esta técnica para demostrar por qué esta técnica no es fácil de programar, como se advierte en la documentación subset().\nmatch.call(), manipulación de llamadas y evaluación en el entorno de la persona que llama, como lo usan write.csv() y lm(). Usaré esta técnica para demostrar cómo la cuasicita y la evaluación (regular) pueden ayudarlo a escribir envolturas alrededor de tales funciones.\n\nEstos dos enfoques son formas comunes de evaluación no estándar (NSE).\n\n20.6.1 substitute()\n\nLa forma más común de NSE en base R es substitute() + eval(). El siguiente código muestra cómo puedes escribir el núcleo de subset() en este estilo usando substitute() y eval() en lugar de enquo() y eval_tidy(). Repito el código introducido en la Sección 20.4.3 para que puedas comparar fácilmente. La principal diferencia es el entorno de evaluación: en subset_base(), el argumento se evalúa en el entorno de la persona que llama, mientras que en subset_tidy(), se evalúa en el entorno en el que se definió.\n\nsubset_base &lt;- function(data, rows) {\n  rows &lt;- substitute(rows)\n  rows_val &lt;- eval(rows, data, caller_env())\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\nsubset_tidy &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  rows_val &lt;- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\n\n20.6.1.1 Programación con subset()\n\nLa documentación de subset() incluye la siguiente advertencia:\n\nEsta es una función de conveniencia diseñada para uso interactivo. Para la programación, es mejor usar las funciones estándar de creación de subconjuntos como [ y, en particular, la evaluación no estándar del argumento subconjunto puede tener consecuencias imprevistas.\n\nHay tres problemas principales:\n\nbase::subset() siempre evalúa rows en el entorno de llamada, pero si se ha utilizado ..., es posible que la expresión deba evaluarse en otro lugar:\n\nf1 &lt;- function(df, ...) {\n  xval &lt;- 3\n  subset_base(df, ...)\n}\n\nmy_df &lt;- data.frame(x = 1:3, y = 3:1)\nxval &lt;- 1\nf1(my_df, x == xval)\n#&gt;   x y\n#&gt; 3 3 1\n\nEsto puede parecer una preocupación esotérica, pero significa que subset_base() no puede funcionar de manera confiable con funciones como map() o lapply():\n\nlocal({\n  zzz &lt;- 2\n  dfs &lt;- list(data.frame(x = 1:3), data.frame(x = 4:6))\n  lapply(dfs, subset_base, x == zzz)\n})\n#&gt; Error in eval(rows, data, caller_env()): object 'zzz' not found\n\nLlamar a subset() desde otra función requiere cierto cuidado: debe usar substitute() para capturar una llamada a la expresión completa de subset() y luego evaluar. Creo que este código es difícil de entender porque substitute() no usa un marcador sintáctico para quitar las comillas. Aquí imprimo la llamada generada para que sea un poco más fácil ver lo que está pasando.\n\nf2 &lt;- function(df1, expr) {\n  call &lt;- substitute(subset_base(df1, expr))\n  expr_print(call)\n  eval(call, caller_env())\n}\n\nmy_df &lt;- data.frame(x = 1:3, y = 3:1)\nf2(my_df, x == 1)\n#&gt; subset_base(my_df, x == 1)\n#&gt;   x y\n#&gt; 1 1 3\n\neval() no proporciona ningún pronombre, por lo que no hay forma de exigir que parte de la expresión provenga de los datos. Por lo que puedo decir, no hay forma de hacer que la siguiente función sea segura, excepto comprobando manualmente la presencia de la variable z en df.\n\nf3 &lt;- function(df) {\n  call &lt;- substitute(subset_base(df, z &gt; 0))\n  expr_print(call)\n  eval(call, caller_env())\n}\n\nmy_df &lt;- data.frame(x = 1:3, y = 3:1)\nz &lt;- -1\nf3(my_df)\n#&gt; subset_base(my_df, z &gt; 0)\n#&gt; [1] x y\n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\n\n\n\n20.6.1.2 ¿Qué pasa con [?\nDado que la evaluación ordenada es bastante compleja, ¿por qué no usar simplemente [ como recomienda ?subset? Principalmente, me parece poco atractivo tener funciones que solo se pueden usar de forma interactiva y nunca dentro de otra función.\nAdemás, incluso la función simple subset() proporciona dos características útiles en comparación con [:\n\nEstablece drop = FALSE de forma predeterminada, por lo que se garantiza que devolverá un marco de datos.\nElimina las filas donde la condición se evalúa como NA.\n\nEso significa que subset(df, x == y) no es equivalente a df[x == y,] como cabría esperar. En cambio, es equivalente a df[x == y & !is.na(x == y), , drop = FALSE]: ¡eso es mucho más tipeo! Las alternativas de la vida real a subset(), como dplyr::filter(), hacen aún más. Por ejemplo, dplyr::filter() puede traducir expresiones R a SQL para que puedan ejecutarse en una base de datos. Esto hace que programar con filter() sea relativamente más importante.\n\n\n\n20.6.2 match.call()\n\nOtra forma común de NSE es capturar la llamada completa con match.call(), modificarla y evaluar el resultado. match.call() es similar a substitute(), pero en lugar de capturar un solo argumento, captura la llamada completa. No tiene un equivalente en rlang.\n\ng &lt;- function(x, y, z) {\n  match.call()\n}\ng(1, 2, z = 3)\n#&gt; g(x = 1, y = 2, z = 3)\n\nUn usuario destacado de match.call() es write.csv(), que básicamente funciona transformando la llamada en una llamada a write.table() con los argumentos adecuados establecidos. El siguiente código muestra el corazón de write.csv():\n\nwrite.csv &lt;- function(...) {\n  call &lt;- match.call(write.table, expand.dots = TRUE)\n\n  call[[1]] &lt;- quote(write.table)\n  call$sep &lt;- \",\"\n  call$dec &lt;- \".\"\n\n  eval(call, parent.frame())\n}\n\nNo creo que esta técnica sea una buena idea porque puedes lograr el mismo resultado sin NSE:\n\nwrite.csv &lt;- function(...) {\n  write.table(..., sep = \",\", dec = \".\")\n}\n\nSin embargo, es importante comprender esta técnica porque se usa comúnmente en el modelado de funciones. Estas funciones también imprimen de forma destacada la llamada capturada, lo que plantea algunos desafíos especiales, como verá a continuación.\n\n20.6.2.1 Envolviendo funciones de modelado\n\nPara comenzar, considere el envoltorio más simple posible alrededor de lm():\n\nlm2 &lt;- function(formula, data) {\n  lm(formula, data)\n}\n\nEste contenedor funciona, pero no es óptimo porque lm() captura su llamada y la muestra al imprimir.\n\nlm2(mpg ~ disp, mtcars)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = formula, data = data)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp  \n#&gt;     29.5999      -0.0412\n\nArreglar esto es importante porque esta llamada es la forma principal en que ve la especificación del modelo al imprimir el modelo. Para superar este problema, necesitamos capturar los argumentos, crear la llamada a lm() sin comillas y luego evaluar esa llamada. Para que sea más fácil ver lo que está pasando, también imprimiré la expresión que generamos. Esto será más útil a medida que las llamadas se vuelvan más complicadas.\n\nlm3 &lt;- function(formula, data, env = caller_env()) {\n  formula &lt;- enexpr(formula)\n  data &lt;- enexpr(data)\n\n  lm_call &lt;- expr(lm(!!formula, data = !!data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\n\nlm3(mpg ~ disp, mtcars)\n#&gt; lm(mpg ~ disp, data = mtcars)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ disp, data = mtcars)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp  \n#&gt;     29.5999      -0.0412\n\nHay tres piezas que usará cada vez que envuelva una función NSE base de esta manera:\n\nCaptura los argumentos no evaluados usando enexpr(), y captura el entorno de la persona que llama usando caller_env().\nGeneras una nueva expresión usando expr() y quitando las comillas.\nEvalúa esa expresión en el entorno de la persona que llama. Debe aceptar que la función no funcionará correctamente si los argumentos no están definidos en el entorno de la persona que llama. Proporcionar el argumento env al menos proporciona un gancho que los expertos pueden usar si el entorno predeterminado no es correcto.\n\nEl uso de enexpr() tiene un buen efecto secundario: podemos usar la eliminación de comillas para generar fórmulas dinámicamente:\n\nresp &lt;- expr(mpg)\ndisp1 &lt;- expr(vs)\ndisp2 &lt;- expr(wt)\nlm3(!!resp ~ !!disp1 + !!disp2, mtcars)\n#&gt; lm(mpg ~ vs + wt, data = mtcars)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ vs + wt, data = mtcars)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)           vs           wt  \n#&gt;       33.00         3.15        -4.44\n\n\n\n20.6.2.2 Entorno de evaluación\n¿Qué sucede si desea mezclar objetos proporcionados por el usuario con objetos que crea en la función? Por ejemplo, imagina que quieres hacer una versión de remuestreo automático de lm(). Podrías escribirlo así:\n\nresample_lm0 &lt;- function(formula, data, env = caller_env()) {\n  formula &lt;- enexpr(formula)\n  resample_data &lt;- resample(data, n = nrow(data))\n\n  lm_call &lt;- expr(lm(!!formula, data = resample_data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\n\ndf &lt;- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))\nresample_lm0(y ~ x, data = df)\n#&gt; lm(y ~ x, data = resample_data)\n#&gt; Error in eval(mf, parent.frame()): object 'resample_data' not found\n\n¿Por qué no funciona este código? Estamos evaluando lm_call en el entorno de la persona que llama, pero resample_data existe en el entorno de ejecución. En cambio, podríamos evaluar en el entorno de ejecución de resample_lm0(), pero no hay garantía de que formula pueda evaluarse en ese entorno.\nHay dos formas básicas de superar este desafío:\n\nElimine las comillas del marco de datos en la llamada. Esto significa que no tiene que ocurrir ninguna búsqueda, pero tiene todos los problemas de las expresiones en línea (Sección 19.4.7). Para las funciones de modelado, esto significa que la llamada capturada no es óptima:\n\nresample_lm1 &lt;- function(formula, data, env = caller_env()) {\n  formula &lt;- enexpr(formula)\n  resample_data &lt;- resample(data, n = nrow(data))\n\n  lm_call &lt;- expr(lm(!!formula, data = !!resample_data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\nresample_lm1(y ~ x, data = df)$call\n#&gt; lm(y ~ x, data = &lt;data.frame&gt;)\n#&gt; lm(formula = y ~ x, data = list(x = c(3L, 7L, 4L, 4L, \n#&gt; 2L, 7L, 2L, 1L, 8L, 9L), y = c(13.21, 27.04, 18.63, \n#&gt; 18.63, 10.99, 27.04, 10.99, 7.83, 28.14, 32.72)))\n\nAlternativamente, puede crear un nuevo entorno que herede de la persona que llama y vincular las variables que ha creado dentro de la función a ese entorno.\n\nresample_lm2 &lt;- function(formula, data, env = caller_env()) {\n  formula &lt;- enexpr(formula)\n  resample_data &lt;- resample(data, n = nrow(data))\n\n  lm_env &lt;- env(env, resample_data = resample_data)\n  lm_call &lt;- expr(lm(!!formula, data = resample_data))\n  expr_print(lm_call)\n  eval(lm_call, lm_env)\n}\nresample_lm2(y ~ x, data = df)\n#&gt; lm(y ~ x, data = resample_data)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = y ~ x, data = resample_data)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)            x  \n#&gt;        4.42         3.11\n\nEsto es más trabajo, pero da la especificación más limpia.\n\n\n\n\n20.6.3 Ejercicios\n\n¿Por qué falla esta función?\n\nlm3a &lt;- function(formula, data) {\n  formula &lt;- enexpr(formula)\n\n  lm_call &lt;- expr(lm(!!formula, data = data))\n  eval(lm_call, caller_env())\n}\nlm3a(mpg ~ disp, mtcars)$call\n#&gt; Error en as.data.frame.default(data, optional = TRUE): \n#&gt; no puede obligar a la clase '\"function\"' a un data.frame\n\nCuando se crea un modelo, normalmente la respuesta y los datos son relativamente constantes mientras experimenta rápidamente con diferentes predictores. Escriba un pequeño contenedor que le permita reducir la duplicación en el código a continuación.\n\nlm(mpg ~ disp, data = mtcars)\nlm(mpg ~ I(1 / disp), data = mtcars)\nlm(mpg ~ disp * cyl, data = mtcars)\n\nOtra forma de escribir resample_lm() sería incluir la expresión de remuestreo (data[sample(nrow(data), replace = TRUE), , drop = FALSE]) en el argumento de datos. Implemente ese enfoque. ¿Cuáles son las ventajas? ¿Cuales son las desventajas?",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Evaluation.html#footnotes",
    "href": "Evaluation.html#footnotes",
    "title": "20  Evaluación",
    "section": "",
    "text": "Todos los demás objetos se rinden cuando se evalúan; es decir, eval(x) produce x, excepto cuando x es un símbolo o una expresión.↩︎\nTécnicamente, una fórmula combina una expresión y un entorno, pero las fórmulas están estrechamente vinculadas al modelado, por lo que una nueva estructura de datos tiene sentido.↩︎",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Evaluación</span>"
    ]
  },
  {
    "objectID": "Translation.html",
    "href": "Translation.html",
    "title": "21  Traducir código R",
    "section": "",
    "text": "21.1 Introducción\nLa combinación de entornos de primera clase, alcance léxico y metaprogramación nos brinda un poderoso conjunto de herramientas para traducir código R a otros lenguajes. Un ejemplo completo de esta idea es dbplyr, que impulsa los backends de la base de datos para dplyr, lo que le permite expresar la manipulación de datos en R y traducirlos automáticamente a SQL. Puedes ver la idea clave en translate_sql() que toma el código R y devuelve el SQL equivalente:\nlibrary(dbplyr)\n\ncon &lt;- simulate_dbi()\n\ntranslate_sql(x ^ 2, con = con)\n#&gt; &lt;SQL&gt; POWER(`x`, 2.0)\ntranslate_sql(x &lt; 5 & !is.na(x), con = con)\n#&gt; &lt;SQL&gt; `x` &lt; 5.0 AND NOT((`x` IS NULL))\ntranslate_sql(!first %in% c(\"John\", \"Roger\", \"Robert\"), con = con)\n#&gt; &lt;SQL&gt; NOT(`first` IN ('John', 'Roger', 'Robert'))\ntranslate_sql(select == 7, con = con)\n#&gt; &lt;SQL&gt; `select` = 7.0\nTraducir R a SQL es complejo debido a las muchas idiosincrasias de los dialectos de SQL, por lo que aquí desarrollaré dos lenguajes específicos de dominio (DSL) simples pero útiles: uno para generar HTML y el otro para generar ecuaciones matemáticas en LaTeX.\nSi está interesado en obtener más información sobre los idiomas específicos del dominio en general, le recomiendo Idiomas específicos del dominio (Fowler 2010). Analiza muchas opciones para crear un DSL y proporciona muchos ejemplos de diferentes idiomas.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Traducir código R</span>"
    ]
  },
  {
    "objectID": "Translation.html#introducción",
    "href": "Translation.html#introducción",
    "title": "21  Traducir código R",
    "section": "",
    "text": "Estructura\n\nLa Sección 21.2 crea un DSL para generar HTML, usando quasiquotation y purrr para generar una función para cada etiqueta HTML, luego ordena la evaluación para acceder fácilmente a ellos.\nLa Sección 21.3) transforma matemáticamente el código R en su equivalente LaTeX usando una combinación de evaluación ordenada y caminata de expresión.\n\n\n\nRequisitos previos\nEste capítulo reúne muchas técnicas discutidas en otras partes del libro. En particular, deberá comprender los entornos, las expresiones, la evaluación ordenada y un poco de programación funcional y S3. Usaremos rlang para herramientas de metaprogramación y purrr para programación funcional.\n\nlibrary(rlang)\nlibrary(purrr)",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Traducir código R</span>"
    ]
  },
  {
    "objectID": "Translation.html#sec-html",
    "href": "Translation.html#sec-html",
    "title": "21  Traducir código R",
    "section": "21.2 HTML",
    "text": "21.2 HTML\n\nHTML (lenguaje de marcado de hipertexto) subyace en la mayor parte de la web. Es un caso especial de SGML (Lenguaje de marcado generalizado estándar), y es similar pero no idéntico a XML (Lenguaje de marcado extensible). HTML se ve así:\n&lt;body&gt;\n  &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n  &lt;p&gt;Some text &amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n  &lt;img src='myimg.png' width='100' height='100' /&gt;\n&lt;/body&gt;\nIncluso si nunca antes ha mirado HTML, aún puede ver que el componente clave de su estructura de codificación son las etiquetas, que se ven como &lt;tag&gt;&lt;/tag&gt; o &lt;tag/&gt;. Las etiquetas se pueden anidar dentro de otras etiquetas y entremezclarse con el texto. Hay más de 100 etiquetas HTML, pero en este capítulo nos centraremos en unas pocas:\n\n&lt;body&gt; es la etiqueta de nivel superior que contiene todo el contenido.\n&lt;h1&gt; define un encabezado de nivel superior.\n&lt;p&gt; define un párrafo.\n&lt;b&gt; texto envalentonado.\n&lt;img&gt; incrusta una imagen.\n\nLas etiquetas pueden tener atributos con nombre que se parecen a &lt;tag nombre1='valor1' nombre2='valor2'&gt;&lt;/tag&gt;. Dos de los atributos más importantes son id y class, que se utilizan junto con CSS (hojas de estilo en cascada) para controlar la apariencia visual de la página.\nEtiquetas anuladas, como &lt;img&gt;, no tienen hijos y se escriben &lt;img /&gt;, no &lt;img&gt;&lt;/img&gt;. Dado que no tienen contenido, los atributos son más importantes, y img tiene tres que se usan con casi todas las imágenes: src (donde vive la imagen), width y height.\nDebido a que &lt; y &gt; tienen significados especiales en HTML, no puede escribirlos directamente. En su lugar, debe usar los escapes de HTML: &gt; y &lt;. Y dado que esos escapes usan &, si quieres un ampersand literal, tienes que escapar como &amp;.\n\n21.2.1 Objetivo\nNuestro objetivo es facilitar la generación de HTML desde R. Para dar un ejemplo concreto, queremos generar el siguiente HTML:\n&lt;body&gt;\n  &lt;h1 id='first'&gt;A heading&lt;/h1&gt;\n  &lt;p&gt;Some text &amp; &lt;b&gt;some bold text.&lt;/b&gt;&lt;/p&gt;\n  &lt;img src='myimg.png' width='100' height='100' /&gt;\n&lt;/body&gt;\nUsando el siguiente código que coincida lo más posible con la estructura del HTML:\n\nwith_html(\n  body(\n    h1(\"Un encabezado\", id = \"first\"),\n    p(\"Un poco de textp &\", b(\"un poco de texto en negrita.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n\nEste DSL tiene las siguientes tres propiedades:\n\nEl anidamiento de llamadas a funciones coincide con el anidamiento de etiquetas.\nLos argumentos sin nombre se convierten en el contenido de la etiqueta y los argumentos con nombre se convierten en sus atributos.\n& y otros caracteres especiales se escapan automáticamente.\n\n\n\n21.2.2 Escapar\n\nEscapar es tan fundamental para la traducción que será nuestro primer tema. Hay dos desafíos relacionados:\n\nEn la entrada del usuario, necesitamos escapar automáticamente &, &lt; y &gt;.\nAl mismo tiempo, debemos asegurarnos de que &, &lt; y &gt; que generamos no tengan doble escape (es decir, que no generemos accidentalmente &amp;amp;, &amp;lt ; y &amp;gt;).\n\nLa forma más sencilla de hacer esto es crear una clase S3 (Sección 13.3) que distinga entre texto normal (que necesita escape) y HTML (que no).\n\nhtml &lt;- function(x) structure(x, class = \"advr_html\")\n\nprint.advr_html &lt;- function(x, ...) {\n  out &lt;- paste0(\"&lt;HTML&gt; \", x)\n  cat(paste(strwrap(out), collapse = \"\\n\"), \"\\n\", sep = \"\")\n}\n\nLuego escribimos un escape genérico. Tiene dos métodos importantes:\n\nescape.character() toma un vector de caracteres regular y devuelve un vector HTML con caracteres especiales (&, &lt;, &gt;) escapados.\nescape.advr_html() deja solo el HTML escapado.\n\n\nescape &lt;- function(x) UseMethod(\"escape\")\n\nescape.character &lt;- function(x) {\n  x &lt;- gsub(\"&\", \"&amp;\", x)\n  x &lt;- gsub(\"&lt;\", \"&lt;\", x)\n  x &lt;- gsub(\"&gt;\", \"&gt;\", x)\n\n  html(x)\n}\n\nescape.advr_html &lt;- function(x) x\n\nAhora comprobamos que funciona\n\nescape(\"This is some text.\")\n#&gt; &lt;HTML&gt; This is some text.\nescape(\"x &gt; 1 & y &lt; 2\")\n#&gt; &lt;HTML&gt; x &gt; 1 &amp; y &lt; 2\n\n# Doble escape no es un problema\nescape(escape(\"This is some text. 1 &gt; 2\"))\n#&gt; &lt;HTML&gt; This is some text. 1 &gt; 2\n\n# Y el texto que sabemos que es HTML no se escapa.\nescape(html(\"&lt;hr /&gt;\"))\n#&gt; &lt;HTML&gt; &lt;hr /&gt;\n\nConvenientemente, esto también permite que un usuario opte por nuestro escape si sabe que el contenido ya está escapado.\n\n\n21.2.3 Funciones básicas de etiquetas\nA continuación, escribiremos una función de una etiqueta a mano, luego descubriremos cómo generalizarla para que podamos generar una función para cada etiqueta con código.\nComencemos con &lt;p&gt;. Las etiquetas HTML pueden tener tanto atributos (por ejemplo, id o clase) como elementos secundarios (como &lt;b&gt; o &lt;i&gt;). Necesitamos alguna forma de separarlos en la llamada a la función. Dado que los atributos tienen nombre y los hijos no, parece natural usar argumentos con nombre y sin nombre para ellos, respectivamente. Por ejemplo, una llamada a p() podría verse así:\n\np(\"Texo. \", b(i(\"some bold italic text\")), class = \"mypara\")\n\nPodríamos enumerar todos los atributos posibles de la etiqueta &lt;p&gt; en la definición de la función, pero eso es difícil porque hay muchos atributos y porque es posible usar [atributos personalizados] (http://html5doctor.com/html5- atributos-de-datos-personalizados/). En su lugar, usaremos ... y separaremos los componentes en función de si tienen nombre o no. Con esto en mente, creamos una función auxiliar que envuelve rlang::list2() (Sección 19.6) y devuelve los componentes con nombre y sin nombre por separado:\n\ndots_partition &lt;- function(...) {\n  dots &lt;- list2(...)\n  \n if (is.null(names(dots))) {\n  is_named &lt;- rep(FALSE, length(dots))\n} else {\n  is_named &lt;- names(dots) != \"\"\n}\n  \n  list(\n    named = dots[is_named],\n    unnamed = dots[!is_named]\n  )\n}\n\nstr(dots_partition(a = 1, 2, b = 3, 4))\n#&gt; List of 2\n#&gt;  $ named  :List of 2\n#&gt;   ..$ a: num 1\n#&gt;   ..$ b: num 3\n#&gt;  $ unnamed:List of 2\n#&gt;   ..$ : num 2\n#&gt;   ..$ : num 4\n\nAhora podemos crear nuestra función p(). Note que hay una nueva función aquí: html_attributes(). Toma una lista con nombre y devuelve la especificación del atributo HTML como una cadena. Es un poco complicado (en parte, porque trata con algunas idiosincrasias de HTML que no he mencionado aquí), pero no es tan importante y no introduce nuevas ideas de programación, así que no lo discutiré en detalle. Puede encontrar la fuente en línea si desea resolverlo usted mismo.\n\n\nsource(\"dsl-html-attributes.r\")\np &lt;- function(...) {\n  dots &lt;- dots_partition(...)\n  attribs &lt;- html_attributes(dots$named)\n  children &lt;- map_chr(dots$unnamed, escape)\n\n  html(paste0(\n    \"&lt;p\", attribs, \"&gt;\",\n    paste(children, collapse = \"\"),\n    \"&lt;/p&gt;\"\n  ))\n}\n\np(\"Some text\")\n#&gt; &lt;HTML&gt; &lt;p&gt;Some text&lt;/p&gt;\np(\"Some text\", id = \"myid\")\n#&gt; &lt;HTML&gt; &lt;p id='myid'&gt;Some text&lt;/p&gt;\np(\"Some text\", class = \"important\", `data-value` = 10)\n#&gt; &lt;HTML&gt; &lt;p class='important' data-value='10'&gt;Some text&lt;/p&gt;\n\n\n\n21.2.4 Funciones de etiquetas\nEs sencillo adaptar p() a otras etiquetas: solo necesitamos reemplazar \"p\" con el nombre de la etiqueta. Una forma elegante de hacerlo es crear una función con rlang::new_function() (Sección 19.7.4), utilizando la eliminación de comillas y paste0() para generar las etiquetas de inicio y finalización.\n\ntag &lt;- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots &lt;- dots_partition(...)\n      attribs &lt;- html_attributes(dots$named)\n      children &lt;- map_chr(dots$unnamed, escape)\n\n      html(paste0(\n        !!paste0(\"&lt;\", tag), attribs, \"&gt;\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"&lt;/\", tag, \"&gt;\")\n      ))\n    }),\n    caller_env()\n  )\n}\ntag(\"b\")\n#&gt; function (...) \n#&gt; {\n#&gt;     dots &lt;- dots_partition(...)\n#&gt;     attribs &lt;- html_attributes(dots$named)\n#&gt;     children &lt;- map_chr(dots$unnamed, escape)\n#&gt;     html(paste0(\"&lt;b\", attribs, \"&gt;\", paste(children, collapse = \"\"), \n#&gt;         \"&lt;/b&gt;\"))\n#&gt; }\n\nNecesitamos la extraña sintaxis exprs(... = ) para generar el argumento vacío ... en la función de etiqueta. Consulte la Sección 18.6.2 para obtener más detalles.\nAhora podemos ejecutar nuestro ejemplo anterior:\n\np &lt;- tag(\"p\")\nb &lt;- tag(\"b\")\ni &lt;- tag(\"i\")\np(\"Some text. \", b(i(\"some bold italic text\")), class = \"mypara\")\n#&gt; &lt;HTML&gt; &lt;p class='mypara'&gt;Some text. &lt;b&gt;&lt;i&gt;some bold italic\n#&gt; text&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;\n\nAntes de generar funciones para cada etiqueta HTML posible, necesitamos crear una variante que maneje etiquetas vacías. void_tag() es bastante similar a tag(), pero arroja un error si hay etiquetas secundarias, como lo capturan los puntos sin nombre. La etiqueta en sí también se ve un poco diferente.\n\nvoid_tag &lt;- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots &lt;- dots_partition(...)\n      if (length(dots$unnamed) &gt; 0) {\n        abort(!!paste0(\"&lt;\", tag, \"&gt; must not have unnamed arguments\"))\n      }\n      attribs &lt;- html_attributes(dots$named)\n\n      html(paste0(!!paste0(\"&lt;\", tag), attribs, \" /&gt;\"))\n    }),\n    caller_env()\n  )\n}\n\nimg &lt;- void_tag(\"img\")\nimg\n#&gt; function (...) \n#&gt; {\n#&gt;     dots &lt;- dots_partition(...)\n#&gt;     if (length(dots$unnamed) &gt; 0) {\n#&gt;         abort(\"&lt;img&gt; must not have unnamed arguments\")\n#&gt;     }\n#&gt;     attribs &lt;- html_attributes(dots$named)\n#&gt;     html(paste0(\"&lt;img\", attribs, \" /&gt;\"))\n#&gt; }\nimg(src = \"myimage.png\", width = 100, height = 100)\n#&gt; &lt;HTML&gt; &lt;img src='myimage.png' width='100' height='100' /&gt;\n\n\n\n21.2.5 Procesando todas las etiquetas\nA continuación, debemos generar estas funciones para cada etiqueta. Comenzaremos con una lista de todas las etiquetas HTML:\n\ntags &lt;- c(\"a\", \"abbr\", \"address\", \"article\", \"aside\", \"audio\",\n  \"b\",\"bdi\", \"bdo\", \"blockquote\", \"body\", \"button\", \"canvas\",\n  \"caption\",\"cite\", \"code\", \"colgroup\", \"data\", \"datalist\",\n  \"dd\", \"del\",\"details\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\",\n  \"eventsource\",\"fieldset\", \"figcaption\", \"figure\", \"footer\",\n  \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\",\n  \"hgroup\", \"html\", \"i\",\"iframe\", \"ins\", \"kbd\", \"label\",\n  \"legend\", \"li\", \"mark\", \"map\",\"menu\", \"meter\", \"nav\",\n  \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\",\n  \"p\", \"pre\", \"progress\", \"q\", \"ruby\", \"rp\",\"rt\", \"s\", \"samp\",\n  \"script\", \"section\", \"select\", \"small\", \"span\", \"strong\",\n  \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\",\n  \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\",\n  \"u\", \"ul\", \"var\", \"video\"\n)\n\nvoid_tags &lt;- c(\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\",\n  \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n  \"source\", \"track\", \"wbr\"\n)\n\nSi observa esta lista detenidamente, verá que hay bastantes etiquetas que tienen el mismo nombre que las funciones base de R (body, col, q, source, sub, summary, tabla). Esto significa que no queremos que todas las funciones estén disponibles de forma predeterminada, ya sea en el entorno global o en un paquete. En su lugar, los pondremos en una lista (como en la Sección 10.5) y luego proporcionaremos una ayuda para que sea más fácil usarlos cuando se desee. Primero, hacemos una lista con nombre que contiene todas las funciones de etiqueta:\n\nhtml_tags &lt;- c(\n  tags %&gt;% set_names() %&gt;% map(tag),\n  void_tags %&gt;% set_names() %&gt;% map(void_tag)\n)\n\nEsto nos da una forma explícita (pero detallada) de crear HTML:\n\nhtml_tags$p(\n  \"Some text. \",\n  html_tags$b(html_tags$i(\"some bold italic text\")),\n  class = \"mypara\"\n)\n#&gt; &lt;HTML&gt; &lt;p class='mypara'&gt;Some text. &lt;b&gt;&lt;i&gt;some bold italic\n#&gt; text&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;\n\nEntonces podemos terminar nuestro DSL HTML con una función que nos permita evaluar el código en el contexto de esa lista. Aquí abusamos ligeramente de la máscara de datos, pasándole una lista de funciones en lugar de un marco de datos. Este es un truco rápido para mezclar el entorno de ejecución del código con las funciones en html_tags.\n\n\nwith_html &lt;- function(code) {\n  code &lt;- enquo(code)\n  eval_tidy(code, html_tags)\n}\n\nEsto nos brinda una API sucinta que nos permite escribir HTML cuando lo necesitamos, pero no abarrota el espacio de nombres cuando no lo necesitamos.\n\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n#&gt; &lt;HTML&gt; &lt;body&gt;&lt;h1 id='first'&gt;A heading&lt;/h1&gt;&lt;p&gt;Some text &amp;&lt;b&gt;some\n#&gt; bold text.&lt;/b&gt;&lt;/p&gt;&lt;img src='myimg.png' width='100' height='100'\n#&gt; /&gt;&lt;/body&gt;\n\nSi desea acceder a la función R anulada por una etiqueta HTML con el mismo nombre dentro de with_html(), puede usar la especificación package::function completa.\n\n\n21.2.6 Ejercicios\n\nLas reglas de escape para las etiquetas &lt;script&gt; son diferentes porque contienen JavaScript, no HTML. En lugar de escapar los corchetes angulares o los símbolos de unión, debe escapar &lt;/script&gt; para que la etiqueta no se cierre demasiado pronto. Por ejemplo, script(\"'&lt;/script&gt;'\"), no debería generar esto:\n&lt;script&gt;'&lt;/script&gt;'&lt;/script&gt;\nBut\n&lt;script&gt;'&lt;\\/script&gt;'&lt;/script&gt;\nAdapte escape() para seguir estas reglas cuando un nuevo argumento script se establezca en TRUE.\nEl uso de ... para todas las funciones tiene algunas desventajas importantes. No hay validación de entrada y habrá poca información en la documentación o autocompletar sobre cómo se usan en la función. Cree una nueva función que, cuando se le proporcione una lista con nombre de etiquetas y sus nombres de atributos (como se muestra a continuación), cree funciones de etiqueta con argumentos con nombre.\n\nlist(\n  a = c(\"href\"),\n  img = c(\"src\", \"width\", \"height\")\n)\n\nTodas las etiquetas deben obtener los atributos class e id.\nRazona sobre el siguiente código que llama with_html() haciendo referencia a objetos del entorno. ¿Funcionará o fallará? ¿Por qué? Ejecute el código para verificar sus predicciones.\n\ngreeting &lt;- \"Hello!\"\nwith_html(p(greeting))\n\np &lt;- function() \"p\"\naddress &lt;- \"123 anywhere street\"\nwith_html(p(address))\n\nActualmente, el HTML no se ve muy bonito y es difícil ver la estructura. ¿Cómo podrías adaptar tag() para sangrar y formatear? (Es posible que deba investigar un poco sobre las etiquetas en bloque y en línea).",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Traducir código R</span>"
    ]
  },
  {
    "objectID": "Translation.html#sec-latex",
    "href": "Translation.html#sec-latex",
    "title": "21  Traducir código R",
    "section": "21.3 LaTeX",
    "text": "21.3 LaTeX\n\nEl próximo DSL convertirá las expresiones R en sus equivalentes matemáticos de LaTeX. (Esto es un poco como ?plotmath, pero para texto en lugar de gráficos.) LaTeX es la lingua franca de los matemáticos y estadísticos: es común usar la notación LaTeX cada vez que desea expresar una ecuación en texto, como en un correo electrónico. Dado que muchos informes se producen con R y LaTeX, podría ser útil poder convertir automáticamente expresiones matemáticas de un idioma a otro.\nDebido a que necesitamos convertir funciones y nombres, este DSL matemático será más complicado que el HTML DSL. También necesitaremos crear una conversión predeterminada, para que los símbolos que no conocemos obtengan una conversión estándar. Esto significa que ya no podemos usar solo la evaluación: también necesitamos recorrer el árbol de sintaxis abstracta (AST).\n\n21.3.1 LaTeX matemáticas\nAntes de comenzar, veamos rápidamente cómo se expresan las fórmulas en LaTeX. El estándar completo es muy complejo, pero afortunadamente está bien documentado, y los comandos más comunes tienen una estructura bastante simple:\n\nLa mayoría de las ecuaciones matemáticas simples se escriben de la misma manera que las escribirías en R: x * y, z ^ 5. Los subíndices se escriben usando _ (por ejemplo, x_1).\nLos caracteres especiales comienzan con \\: \\pi = \\(\\pi\\), \\pm = \\(\\pm\\), y así sucesivamente. Hay una gran cantidad de símbolos disponibles en LaTeX: la búsqueda en línea de “símbolos matemáticos de látex” arroja muchas listas. Incluso hay un servicio que buscará el símbolo que dibujes en el navegador.\nLas funciones más complicadas se ven como \\name{arg1}{arg2}. Por ejemplo, para escribir una fracción usarías \\frac{a}{b}. Para escribir una raíz cuadrada, usarías \\sqrt{a}.\nPara agrupar elementos, use {}: es decir, x ^ a + b versus x ^ {a + b}.\nEn una buena composición tipográfica matemática, se hace una distinción entre variables y funciones. Pero sin información adicional, LaTeX no sabe si f(a * b) representa llamar a la función f con la entrada a * b, o si es una abreviatura de f * (a * b). Si f es una función, puede decirle a LaTeX que la escriba usando una fuente vertical con \\textrm{f}(a * b). (El rm significa “romano”, lo contrario de la cursiva).\n\n\n\n21.3.2 Meta\nNuestro objetivo es usar estas reglas para convertir automáticamente una expresión R a su representación LaTeX adecuada. Abordaremos esto en cuatro etapas:\n\nConvertir símbolos conocidos: pi → \\pi\nDejar otros símbolos sin cambios: x → x, y → y\nConvertir funciones conocidas a sus formas especiales: sqrt(frac(a, b)) → \\sqrt{\\frac{a}{b}}\nEnvuelve funciones desconocidas con \\textrm: f(a) → \\textrm{f}(a)\n\nCodificaremos esta traducción en la dirección opuesta a lo que hicimos con HTML DSL. Comenzaremos con la infraestructura, porque eso hace que sea fácil experimentar con nuestro DSL, y luego trabajaremos de regreso para generar el resultado deseado.\n\n\n21.3.3 to_math()\nPara comenzar, necesitamos una función contenedora que convierta las expresiones R en expresiones matemáticas LaTeX. Esto funcionará como to_html() capturando la expresión no evaluada y evaluándola en un entorno especial. Hay dos diferencias principales:\n\nEl entorno de evaluación ya no es constante, ya que tiene que variar según la entrada. Esto es necesario para manejar símbolos y funciones desconocidos.\nNunca evaluamos en el entorno de argumentos porque estamos traduciendo cada función a una expresión LaTeX. El usuario necesitará usar explícitamente !! para evaluar normalmente.\n\nEsto nos da:\n\nto_math &lt;- function(x) {\n  expr &lt;- enexpr(x)\n  out &lt;- eval_bare(expr, latex_env(expr))\n\n  latex(out)\n}\n\nlatex &lt;- function(x) structure(x, class = \"advr_latex\")\nprint.advr_latex &lt;- function(x) {\n  cat(\"&lt;LATEX&gt; \", x, \"\\n\", sep = \"\")\n}\n\nA continuación, construiremos latex_env(), comenzando de manera simple y haciéndonos progresivamente más complejos.\n\n\n21.3.4 Símbolos conocidos\nNuestro primer paso es crear un entorno que convierta los símbolos especiales de LaTeX utilizados para los caracteres griegos, por ejemplo, pi a \\pi. Usaremos el truco de la Sección 20.4.3 para vincular el símbolo pi al valor \"\\pi\".\n\ngreek &lt;- c(\n  \"alpha\", \"theta\", \"tau\", \"beta\", \"vartheta\", \"pi\", \"upsilon\",\n  \"gamma\", \"varpi\", \"phi\", \"delta\", \"kappa\", \"rho\",\n  \"varphi\", \"epsilon\", \"lambda\", \"varrho\", \"chi\", \"varepsilon\",\n  \"mu\", \"sigma\", \"psi\", \"zeta\", \"nu\", \"varsigma\", \"omega\", \"eta\",\n  \"xi\", \"Gamma\", \"Lambda\", \"Sigma\", \"Psi\", \"Delta\", \"Xi\",\n  \"Upsilon\", \"Omega\", \"Theta\", \"Pi\", \"Phi\"\n)\ngreek_list &lt;- set_names(paste0(\"\\\\\", greek), greek)\ngreek_env &lt;- as_environment(greek_list)\n\nEntonces podemos comprobarlo:\n\nlatex_env &lt;- function(expr) {\n  greek_env\n}\n\nto_math(pi)\n#&gt; &lt;LATEX&gt; \\pi\nto_math(beta)\n#&gt; &lt;LATEX&gt; \\beta\n\n¡Se ve bien hasta ahora!\n\n\n21.3.5 Símbolos desconocidos\nSi un símbolo no es griego, queremos dejarlo como está. Esto es complicado porque no sabemos de antemano qué símbolos se utilizarán y no podemos generarlos todos. En su lugar, usaremos el enfoque descrito en la Sección 18.5: recorrer el AST para encontrar todos los símbolos. Esto nos da all_names_rec() y el asistente all_names():\n\n\nall_names_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = character(),\n    symbol =   as.character(x),\n    call =     flat_map_chr(as.list(x[-1]), all_names)\n  )\n}\n\nall_names &lt;- function(x) {\n  unique(all_names_rec(x))\n}\n\nall_names(expr(x + y + f(a, b, c, 10)))\n#&gt; [1] \"x\" \"y\" \"a\" \"b\" \"c\"\n\nAhora queremos tomar esa lista de símbolos y convertirla en un entorno para que cada símbolo se asigne a su representación de cadena correspondiente (por ejemplo, eval(quote(x), env) produce \"x\"). Nuevamente usamos el patrón de convertir un vector de caracteres con nombre en una lista y luego convertir la lista en un entorno.\n\nlatex_env &lt;- function(expr) {\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(names))\n\n  symbol_env\n}\n\nto_math(x)\n#&gt; &lt;LATEX&gt; x\nto_math(longvariablename)\n#&gt; &lt;LATEX&gt; longvariablename\nto_math(pi)\n#&gt; &lt;LATEX&gt; pi\n\nEsto funciona, pero necesitamos combinarlo con el entorno de símbolos griegos. Dado que queremos dar preferencia al griego sobre los valores predeterminados (por ejemplo, to_math(pi) debe dar \"\\\\pi\", no \"pi\"), symbol_env debe ser el padre de greek_env. Para hacer eso, necesitamos hacer una copia de greek_env con un nuevo padre. Esto nos da una función que puede convertir símbolos conocidos (griegos) y desconocidos.\n\nlatex_env &lt;- function(expr) {\n  # Símbolos desconocidos\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(names))\n\n  # Símbolos conocidos\n  env_clone(greek_env, parent = symbol_env)\n}\n\nto_math(x)\n#&gt; &lt;LATEX&gt; x\nto_math(longvariablename)\n#&gt; &lt;LATEX&gt; longvariablename\nto_math(pi)\n#&gt; &lt;LATEX&gt; \\pi\n\n\n\n21.3.6 Funciones conocidas\nA continuación agregaremos funciones a nuestro DSL. Comenzaremos con un par de ayudantes que facilitan la adición de nuevos operadores binarios y unarios. Estas funciones son muy simples: solo ensamblan cadenas.\n\nunary_op &lt;- function(left, right) {\n  new_function(\n    exprs(e1 = ),\n    expr(\n      paste0(!!left, e1, !!right)\n    ),\n    caller_env()\n  )\n}\n\nbinary_op &lt;- function(sep) {\n  new_function(\n    exprs(e1 = , e2 = ),\n    expr(\n      paste0(e1, !!sep, e2)\n    ),\n    caller_env()\n  )\n}\n\nunary_op(\"\\\\sqrt{\", \"}\")\n#&gt; function (e1) \n#&gt; paste0(\"\\\\sqrt{\", e1, \"}\")\nbinary_op(\"+\")\n#&gt; function (e1, e2) \n#&gt; paste0(e1, \"+\", e2)\n\nUsando estos ayudantes, podemos mapear algunos ejemplos ilustrativos de conversión de R a LaTeX. Tenga en cuenta que con las reglas de alcance léxico de R ayudándonos, podemos proporcionar fácilmente nuevos significados para funciones estándar como +, - y *, e incluso ( y {.\n\n# Operadores binarios\nf_env &lt;- child_env(\n  .parent = empty_env(),\n  `+` = binary_op(\" + \"),\n  `-` = binary_op(\" - \"),\n  `*` = binary_op(\" * \"),\n  `/` = binary_op(\" / \"),\n  `^` = binary_op(\"^\"),\n  `[` = binary_op(\"_\"),\n\n  # Agrupamiento\n  `{` = unary_op(\"\\\\left{ \", \" \\\\right}\"),\n  `(` = unary_op(\"\\\\left( \", \" \\\\right)\"),\n  paste = paste,\n\n  # Otras funciones matemáticas\n  sqrt = unary_op(\"\\\\sqrt{\", \"}\"),\n  sin =  unary_op(\"\\\\sin(\", \")\"),\n  log =  unary_op(\"\\\\log(\", \")\"),\n  abs =  unary_op(\"\\\\left| \", \"\\\\right| \"),\n  frac = function(a, b) {\n    paste0(\"\\\\frac{\", a, \"}{\", b, \"}\")\n  },\n\n  # Etiquetado\n  hat =   unary_op(\"\\\\hat{\", \"}\"),\n  tilde = unary_op(\"\\\\tilde{\", \"}\")\n)\n\nNuevamente modificamos latex_env() para incluir este entorno. Debería ser el último entorno en el que R busca nombres para que expresiones como sin(sin) funcionen.\n\nlatex_env &lt;- function(expr) {\n  # Funciones conocidas\n  f_env\n\n  # Símbolos predeterminados\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(names), parent = f_env)\n\n  # Símbolos conocidos\n  greek_env &lt;- env_clone(greek_env, parent = symbol_env)\n\n  greek_env\n}\n\nto_math(sin(x + pi))\n#&gt; &lt;LATEX&gt; \\sin(x + \\pi)\nto_math(log(x[i]^2))\n#&gt; &lt;LATEX&gt; \\log(x_i^2)\nto_math(sin(sin))\n#&gt; &lt;LATEX&gt; \\sin(sin)\n\n\n\n21.3.7 Funciones desconocidas\nFinalmente, agregaremos un valor predeterminado para las funciones que aún no conocemos. No podemos saber de antemano cuáles serán las funciones desconocidas, por lo que nuevamente recorremos el AST para encontrarlas:\n\nall_calls_rec &lt;- function(x) {\n  switch_expr(x,\n    constant = ,\n    symbol =   character(),\n    call = {\n      fname &lt;- as.character(x[[1]])\n      children &lt;- flat_map_chr(as.list(x[-1]), all_calls)\n      c(fname, children)\n    }\n  )\n}\nall_calls &lt;- function(x) {\n  unique(all_calls_rec(x))\n}\n\nall_calls(expr(f(g + b, c, d(a))))\n#&gt; [1] \"f\" \"+\" \"d\"\n\nNecesitamos un cierre que genere las funciones para cada llamada desconocida:\n\nunknown_op &lt;- function(op) {\n  new_function(\n    exprs(... = ),\n    expr({\n      contents &lt;- paste(..., collapse = \", \")\n      paste0(!!paste0(\"\\\\mathrm{\", op, \"}(\"), contents, \")\")\n    })\n  )\n}\nunknown_op(\"foo\")\n#&gt; function (...) \n#&gt; {\n#&gt;     contents &lt;- paste(..., collapse = \", \")\n#&gt;     paste0(\"\\\\mathrm{foo}(\", contents, \")\")\n#&gt; }\n#&gt; &lt;environment: 0x55ad40d59db8&gt;\n\nY de nuevo la actualizamos latex_env():\n\nlatex_env &lt;- function(expr) {\n  calls &lt;- all_calls(expr)\n  call_list &lt;- map(set_names(calls), unknown_op)\n  call_env &lt;- as_environment(call_list)\n\n  # Funciones conocidas\n  f_env &lt;- env_clone(f_env, call_env)\n\n  # Símbolos predeterminados\n  names &lt;- all_names(expr)\n  symbol_env &lt;- as_environment(set_names(names), parent = f_env)\n\n  # Símbolos conocidos\n  greek_env &lt;- env_clone(greek_env, parent = symbol_env)\n  greek_env\n}\n\nEsto completa nuestros requisitos originales:\n\nto_math(sin(pi) + f(a))\n#&gt; &lt;LATEX&gt; \\sin(\\pi) + \\mathrm{f}(a)\n\nSin duda, podría llevar esta idea más allá y traducir tipos de expresiones matemáticas, pero no debería necesitar ninguna herramienta de metaprogramación adicional.\n\n\n21.3.8 Ejercicios\n\nAñadir escape. Los símbolos especiales que deben escaparse agregando una barra invertida delante de ellos son \\, $ y %. Al igual que con HTML, deberá asegurarse de no terminar con doble escape. Por lo tanto, deberá crear una clase S3 pequeña y luego usarla en los operadores de funciones. Eso también le permitirá incrustar LaTeX arbitrario si es necesario.\nComplete el DSL para admitir todas las funciones que admite plotmath.\n\n\n\n\n\nFowler, Martin. 2010. Domain-specific Languages. Pearson Education. http://amzn.com/0321712943.",
    "crumbs": [
      "Metaprogramación",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Traducir código R</span>"
    ]
  },
  {
    "objectID": "Techniques.html",
    "href": "Techniques.html",
    "title": "Introducción",
    "section": "",
    "text": "Los últimos cuatro capítulos cubren dos técnicas generales de programación: encontrar y corregir errores, y encontrar y corregir problemas de rendimiento. Las herramientas para medir y mejorar el rendimiento son particularmente importantes porque R no es un lenguaje rápido. Esto no es un accidente: R fue diseñado a propósito para hacer que el análisis de datos interactivo sea más fácil para los humanos, no para hacer que las computadoras sean lo más rápidas posible. Si bien R es lento en comparación con otros lenguajes de programación, para la mayoría de los propósitos, es lo suficientemente rápido. Estos capítulos lo ayudan a manejar los casos en los que R ya no es lo suficientemente rápido, ya sea mejorando el rendimiento de su código R o cambiando a un lenguaje, C++, que está diseñado para el rendimiento.\n\n22  Depuración habla de depuración, porque encontrar la causa raíz del error puede ser extremadamente frustrante. Afortunadamente, R tiene algunas herramientas excelentes para la depuración y, cuando se combinan con una estrategia sólida, debería poder encontrar la causa raíz de la mayoría de los problemas de forma rápida y relativamente sencilla.\n23  Medición de desempeño se enfoca en medir el desempeño.\n24  Mejorando el desempeño luego muestra cómo mejorar el rendimiento.",
    "crumbs": [
      "Tecnicas",
      "Introducción"
    ]
  },
  {
    "objectID": "Debugging.html",
    "href": "Debugging.html",
    "title": "22  Depuración",
    "section": "",
    "text": "22.1 Introducción\n¿Qué haces cuando el código R arroja un error inesperado? ¿Qué herramientas tienes para encontrar y solucionar el problema? Este capítulo le enseñará el arte y la ciencia de la depuración, comenzando con una estrategia general y luego siguiendo con herramientas específicas.\nMostraré las herramientas proporcionadas por R y el IDE de RStudio. Recomiendo usar las herramientas de RStudio si es posible, pero también te mostraré los equivalentes que funcionan en todas partes. También puede consultar la documentación oficial de depuración de RStudio que siempre refleja la última versión de RStudio.\nNB: No debería necesitar usar estas herramientas al escribir funciones nuevas. Si se encuentra usándolos con frecuencia con código nuevo, reconsidere su enfoque. En lugar de tratar de escribir una gran función de una sola vez, trabaje de forma interactiva en piezas pequeñas. Si comienza poco a poco, puede identificar rápidamente por qué algo no funciona y no necesita herramientas de depuración sofisticadas.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Depuración</span>"
    ]
  },
  {
    "objectID": "Debugging.html#introducción",
    "href": "Debugging.html#introducción",
    "title": "22  Depuración",
    "section": "",
    "text": "Estructura\n\nLa Sección 22.2 describe una estrategia general para encontrar y corregir errores.\nLa Sección 22.3 le presenta la función traceback() que le ayuda a localizar exactamente dónde ocurrió un error.\nLa Sección 22.4 le muestra cómo pausar la ejecución de una función e iniciar un entorno donde puede explorar de forma interactiva lo que está sucediendo.\nLa Sección 22.5 analiza el desafiante problema de la depuración cuando ejecuta código de forma no interactiva.\nLa Sección 22.6 analiza un puñado de problemas que no son errores y que ocasionalmente también necesitan depuración.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Depuración</span>"
    ]
  },
  {
    "objectID": "Debugging.html#sec-debugging-strategy",
    "href": "Debugging.html#sec-debugging-strategy",
    "title": "22  Depuración",
    "section": "22.2 Enfoque global",
    "text": "22.2 Enfoque global\n\nEncontrar su error es un proceso de confirmación de las muchas cosas que cree que son ciertas, hasta que encuentre una que no lo sea.\n—Norm Matloff\n\nEncontrar la causa raíz de un problema siempre es un desafío. La mayoría de los errores son sutiles y difíciles de encontrar porque si fueran obvios, los habrías evitado en primer lugar. Una buena estrategia ayuda. A continuación, describo un proceso de cuatro pasos que he encontrado útil:\n\nGoogle!\nCada vez que vea un mensaje de error, comience a buscarlo en Google. Si tiene suerte, descubrirá que es un error común con una solución conocida. Cuando busque en Google, mejore sus posibilidades de una buena coincidencia eliminando cualquier nombre o valor de variable que sea específico para su problema.\nPuede automatizar este proceso con los paquetes errorist (Balamuta 2018a) y searcher (Balamuta 2018b). Consulte sus sitios web para obtener más detalles.\nHazlo repetible\nPara encontrar la causa raíz de un error, necesitará ejecutar el código muchas veces mientras considera y rechaza las hipótesis. Para que la iteración sea lo más rápida posible, vale la pena hacer una inversión inicial para que el problema sea fácil y rápido de reproducir.\nComience creando un ejemplo reproducible (Sección 1.7). A continuación, haga que el ejemplo sea mínimo eliminando el código y simplificando los datos. Al hacer esto, es posible que descubra entradas que no desencadenan el error. Tome nota de ellos: serán útiles al diagnosticar la causa raíz.\nSi está utilizando pruebas automatizadas, este también es un buen momento para crear un caso de prueba automatizado. Si su cobertura de prueba existente es baja, aproveche la oportunidad para agregar algunas pruebas cercanas para garantizar que se conserve el buen comportamiento existente. Esto reduce las posibilidades de crear un nuevo error.\nAverigua dónde está\nSi tiene suerte, una de las herramientas de la siguiente sección lo ayudará a identificar rápidamente la línea de código que está causando el error. Por lo general, sin embargo, tendrás que pensar un poco más sobre el problema. Es una gran idea adoptar el método científico. Genere hipótesis, diseñe experimentos para probarlas y registre sus resultados. Esto puede parecer mucho trabajo, pero un enfoque sistemático terminará ahorrándole tiempo. A menudo pierdo mucho tiempo confiando en mi intuición para resolver un error (“oh, debe ser un error de uno, así que restaré 1 aquí”), cuando hubiera sido mejor tomar un Acercamiento sistematico.\nSi esto falla, es posible que deba pedir ayuda a otra persona. Si ha seguido el paso anterior, tendrá un pequeño ejemplo que es fácil de compartir con otros. Eso hace que sea mucho más fácil para otras personas ver el problema y es más probable que lo ayuden a encontrar una solución.\nArreglarlo y probarlo\nUna vez que haya encontrado el error, debe descubrir cómo solucionarlo y verificar que la solución realmente funcionó. Una vez más, es muy útil contar con pruebas automatizadas. Esto no solo ayuda a garantizar que realmente haya solucionado el error, sino que también ayuda a garantizar que no haya introducido ningún error nuevo en el proceso. En ausencia de pruebas automatizadas, asegúrese de registrar cuidadosamente la salida correcta y compárela con las entradas que fallaron anteriormente.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Depuración</span>"
    ]
  },
  {
    "objectID": "Debugging.html#sec-traceback",
    "href": "Debugging.html#sec-traceback",
    "title": "22  Depuración",
    "section": "22.3 Localización de errores",
    "text": "22.3 Localización de errores\n \nUna vez que haya hecho que el error sea repetible, el siguiente paso es averiguar de dónde viene. La herramienta más importante para esta parte del proceso es traceback(), que le muestra la secuencia de llamadas (también conocida como pila de llamadas, Sección 7.5) que conducen al error.\nHe aquí un ejemplo sencillo: puedes ver que f() llama a g() llama a h() llama a i(), que comprueba si su argumento es numérico:\n\nf &lt;- function(a) g(a)\ng &lt;- function(b) h(b)\nh &lt;- function(c) i(c)\ni &lt;- function(d) {\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\n\nCuando ejecutamos el código f(\"a\") en RStudio vemos:\n\n\n\n\n\n\n\n\n\nAparecen dos opciones a la derecha del mensaje de error: “Mostrar seguimiento” y “Volver a ejecutar con depuración”. Si hace clic en “Mostrar seguimiento”, verá:\n\n\n\n\n\n\n\n\n\nSi no está usando RStudio, puede usar traceback() para obtener la misma información (sin un formato bonito):\n\ntraceback()\n#&gt; 5: stop(\"`d` must be numeric\", call. = FALSE) at debugging.R#6\n#&gt; 4: i(c) at debugging.R#3\n#&gt; 3: h(b) at debugging.R#2\n#&gt; 2: g(a) at debugging.R#1\n#&gt; 1: f(\"a\")\n\nNB: Usted lee la salida traceback() de abajo hacia arriba: la llamada inicial es f(), que llama g(), luego h(), luego i(), que activa el error. Si está llamando al código que ’fuente () ’d en R, el rastreo también mostrará la ubicación de la función, en la forma nombredearchivo.r# númerodelínea. Estos se pueden hacer clic en RStudio y lo llevarán a la línea de código correspondiente en el editor.\n\n22.3.1 Evaluación perezosa\n\nUn inconveniente de traceback() es que siempre linealiza el árbol de llamadas, lo que puede ser confuso si hay mucha evaluación perezosa involucrada (Sección 7.5.2). Por ejemplo, tome el siguiente ejemplo donde ocurre el error al evaluar el primer argumento de f():\n\nj &lt;- function() k()\nk &lt;- function() stop(\"Oops!\", call. = FALSE)\nf(j())\n#&gt; Error: Oops!\n\n\ntraceback()\n#&gt; 7: stop(\"Oops!\") at #1\n#&gt; 6: k() at #1\n#&gt; 5: j() at debugging.R#1\n#&gt; 4: i(c) at debugging.R#3\n#&gt; 3: h(b) at debugging.R#2\n#&gt; 2: g(a) at debugging.R#1\n#&gt; 1: f(j())\n\nPuede usar rlang::with_abort() y rlang::last_trace() para ver el árbol de llamadas. Aquí, creo que hace que sea mucho más fácil ver el origen del problema. Mire la última rama del árbol de llamadas para ver que el error proviene de j() llamando a k().\n\nrlang::with_abort(f(j()))\n#&gt; Error: 'with_abort' is not an exported object from 'namespace:rlang'\nrlang::last_trace()\n#&gt; Error: Can't show last error because no error was recorded yet\n\nNB: rlang::last_trace() se ordena de forma opuesta a traceback(). Volveremos a ese tema en la Sección 22.4.2.4.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Depuración</span>"
    ]
  },
  {
    "objectID": "Debugging.html#sec-browser",
    "href": "Debugging.html#sec-browser",
    "title": "22  Depuración",
    "section": "22.4 Depurador interactivo",
    "text": "22.4 Depurador interactivo\n \nA veces, la ubicación precisa del error es suficiente para permitirle localizarlo y solucionarlo. Sin embargo, con frecuencia necesita más información, y la forma más fácil de obtenerla es con el depurador interactivo que le permite pausar la ejecución de una función y explorar su estado de forma interactiva.\nSi está utilizando RStudio, la forma más fácil de ingresar al depurador interactivo es a través de la herramienta “Reejecutar con depuración” de RStudio. Esto vuelve a ejecutar el comando que creó el error, deteniendo la ejecución donde ocurrió el error. De lo contrario, puede insertar una llamada a browser() donde desea hacer una pausa y volver a ejecutar la función. Por ejemplo, podríamos insertar una llamada browser() en g():\n\ng &lt;- function(b) {\n  browser()\n  h(b)\n}\nf(10)\n\nbrowser() es solo una llamada de función regular, lo que significa que puede ejecutarla condicionalmente envolviéndola en una declaración if:\n\ng &lt;- function(b) {\n  if (b &lt; 0) {\n    browser()\n  }\n  h(b)\n}\n\nEn cualquier caso, terminará en un entorno interactivo dentro de la función donde puede ejecutar código R arbitrario para explorar el estado actual. Sabrá cuándo está en el depurador interactivo porque recibe un aviso especial:\nBrowse[1]&gt; \nEn RStudio, verá el código correspondiente en el editor (con la instrucción que se ejecutará a continuación resaltada), los objetos en el entorno actual en el panel Entorno y la pila de llamadas en el panel Rastreo.\n\n22.4.1 Comandos browser()\nAdemás de permitirle ejecutar código R regular, browser() proporciona algunos comandos especiales. Puede usarlos escribiendo comandos de texto cortos o haciendo clic en un botón en la barra de herramientas de RStudio, Figura 22.1:\n\n\n\n\n\n\n\n\nFigura 22.1: RStudio debugging toolbar\n\n\n\n\n\n\nSiguiente, n: ejecuta el siguiente paso en la función. Si tiene una variable llamada n, necesitará print(n) para mostrar su valor.\nEntrar en,  o s: funciona como el siguiente, pero si el siguiente paso es una función, entrará en esa función para que pueda explorarla de forma interactiva.\nFinalizar,  o f: finaliza la ejecución del ciclo o función actual.\nContinuar, c: sale de la depuración interactiva y continúa con la ejecución normal de la función. Esto es útil si ha solucionado el mal estado y desea comprobar que la función se desarrolla correctamente.\nDetener, Q: detiene la depuración, finaliza la función y regresa al espacio de trabajo global. Úselo una vez que haya descubierto dónde está el problema y esté listo para solucionarlo y volver a cargar el código.\n\nHay otros dos comandos un poco menos útiles que no están disponibles en la barra de herramientas:\n\nEnter: repite el comando anterior. Encuentro esto demasiado fácil de activar accidentalmente, así que lo apago usando options(browserNLdisabled = TRUE). \nwhere: imprime el seguimiento de la pila de llamadas activas (el equivalente interactivo de traceback).\n\n\n\n22.4.2 Alternativas\nHay tres alternativas al uso de browser(): establecer puntos de interrupción en RStudio, options(error = recovery) y debug() y otras funciones relacionadas.\n\n22.4.2.1 Puntos de ruptura\n\nEn RStudio, puede establecer un punto de interrupción haciendo clic a la izquierda del número de línea o presionando Shift + F9. Los puntos de interrupción se comportan de manera similar a browser() pero son más fáciles de configurar (un clic en lugar de nueve pulsaciones de teclas), y no corre el riesgo de incluir accidentalmente una declaración browser() en su código fuente. Hay dos pequeñas desventajas de los puntos de interrupción:\n\nTaquí hay algunas situaciones inusuales en las que los puntos de interrupción no funcionarán. Para más detalles lea solución de problemas de puntos de interrupción.\nRStudio actualmente no admite puntos de interrupción condicionales.\n\n\n\n22.4.2.2 recover()\n \nOtra forma de activar browser() es usar options(error = recover). Ahora, cuando reciba un error, obtendrá un mensaje interactivo que muestra el rastreo y le brinda la capacidad de depurar de forma interactiva dentro de cualquiera de los marcos:\n\noptions(error = recover)\nf(\"x\")\n#&gt; Error: `d` must be numeric\n#&gt; \n#&gt; Enter a frame number, or 0 to exit   \n#&gt; \n#&gt; 1: f(\"x\")\n#&gt; 2: debugging.R#1: g(a)\n#&gt; 3: debugging.R#2: h(b)\n#&gt; 4: debugging.R#3: i(c)\n#&gt; \n#&gt; Selection:\n\nPuede volver al manejo de errores predeterminado con options(error = NULL).\n\n\n22.4.2.3 debug()\nOtro enfoque es llamar a una función que inserta la llamada browser() por ti:\n\ndebug() inserta una declaración del navegador en la primera línea de la función especificada. undebug() lo elimina. Alternativamente, puede usar debugonce() para navegar solo en la próxima ejecución.\nutils::setBreakpoint() funciona de manera similar, pero en lugar de tomar un nombre de función, toma un nombre de archivo y un número de línea y encuentra la función adecuada para usted.\n\nEstas dos funciones son casos especiales de trace(), que inserta código arbitrario en cualquier posición de una función existente. trace() es ocasionalmente útil cuando estás depurando código para el cual no tienes la fuente. Para eliminar el rastreo de una función, use untrace(). Solo puede realizar un seguimiento por función, pero ese seguimiento puede llamar a varias funciones.\n\n\n22.4.2.4 Pila de llamadas\n\nDesafortunadamente, las pilas de llamadas impresas por traceback(), browser() & where, y recover() no son consistentes. La siguiente tabla muestra cómo las tres herramientas muestran las pilas de llamadas de un conjunto anidado simple de llamadas. La numeración es diferente entre traceback() y where, y recover() muestra las llamadas en el orden opuesto.\n\n\n\n\n\n\n\n\n\ntraceback()\nwhere\nrecover()\nfunciones rlang\n\n\n\n\n5: stop(\"...\")\n\n\n\n\n\n4: i(c)\nwhere 1: i(c)\n1: f()\n1. └─global::f(10)\n\n\n3: h(b)\nwhere 2: h(b)\n2: g(a)\n2.   └─global::g(a)\n\n\n2: g(a)\nwhere 3: g(a)\n3: h(b)\n3.     └─global::h(b)\n\n\n1: f(\"a\")\nwhere 4: f(\"a\")\n4: i(\"a\")\n4.       └─global::i(\"a\")\n\n\n\nRStudio muestra las llamadas en el mismo orden que traceback(). Las funciones rlang usan el mismo orden y numeración que recover(), pero también usan sangría para reforzar la jerarquía de las llamadas.\n\n\n\n22.4.3 Código compilado\n\nTambién es posible usar un depurador interactivo (gdb o lldb) para código compilado (como C o C++). Desafortunadamente, eso está más allá del alcance de este libro, pero hay algunos recursos que pueden resultarle útiles:\n\nhttp://r-pkgs.had.co.nz/src.html#src-debugging\nhttps://github.com/wch/r-debug/blob/master/debugging-r.md\nhttp://kevinushey.github.io/blog/2015/04/05/debugging-with-valgrind/\nhttps://www.jimhester.com/2018/08/22/debugging-rstudio/",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Depuración</span>"
    ]
  },
  {
    "objectID": "Debugging.html#sec-non-interactive-debugging",
    "href": "Debugging.html#sec-non-interactive-debugging",
    "title": "22  Depuración",
    "section": "22.5 Depuración no interactiva",
    "text": "22.5 Depuración no interactiva\n\nLa depuración es más desafiante cuando no puede ejecutar el código de forma interactiva, generalmente porque es parte de una canalización que se ejecuta automáticamente (posiblemente en otra computadora), o porque el error no ocurre cuando ejecuta el mismo código de forma interactiva. ¡Esto puede ser extremadamente frustrante!\nEsta sección le brindará algunas herramientas útiles, pero no olvide la estrategia general en la Sección 22.2. Cuando no puede explorar de forma interactiva, es particularmente importante dedicar algún tiempo a hacer que el problema sea lo más pequeño posible para que pueda iterar rápidamente. A veces callr::r(f, list(1, 2)) puede ser útil; esto llama a f(1, 2) en una nueva sesión y puede ayudar a reproducir el problema.\nTambién es posible que desee verificar dos veces estos problemas comunes:\n\n¿Es diferente el entorno global? ¿Has cargado diferentes paquetes? ¿Los objetos que quedaron de sesiones anteriores causan diferencias?\n¿El directorio de trabajo es diferente?\n¿Es diferente la variable de entorno PATH, que determina dónde se encuentran los comandos externos (como git)?\n¿Es diferente la variable de entorno R_LIBS, que determina dónde library() busca paquetes?\n\n\n22.5.1 dump.frames()\ndump.frames() es el equivalente a recover() para código no interactivo; guarda un archivo last.dump.rda en el directorio de trabajo. Más tarde, en una sesión interactiva, puede load(\"last.dump.rda\"); debugger() para ingresar a un depurador interactivo con la misma interfaz que recover(). Esto le permite “engañar”, depurando de forma interactiva el código que se ejecutó de forma no interactiva.\n\n# En proceso por lotes R ----\ndump_and_quit &lt;- function() {\n  # Guardar información de depuración en un archivo last.dump.rda\n  dump.frames(to.file = TRUE)\n  # Salir de R con estado de error\n  q(status = 1)\n}\noptions(error = dump_and_quit)\n\n# En una sesión interactiva posterior ----\nload(\"last.dump.rda\")\ndebugger()\n\n\n\n22.5.2 Imprimir depuración\n\nSi dump.frames() no ayuda, una buena alternativa es imprimir la depuración, donde inserta numerosas instrucciones de impresión para ubicar con precisión el problema y ver los valores de las variables importantes. La depuración de impresión es lenta y primitiva, pero siempre funciona, por lo que es particularmente útil si no puede obtener un buen seguimiento. Comience insertando marcadores de grano grueso y luego hágalos progresivamente más finos a medida que determina exactamente dónde está el problema.\n\nf &lt;- function(a) {\n  cat(\"f()\\n\")\n  g(a)\n}\ng &lt;- function(b) {\n  cat(\"g()\\n\")\n  cat(\"b =\", b, \"\\n\")\n  h(b)\n}\nh &lt;- function(c) {\n  cat(\"i()\\n\")\n  i(c)\n}\n\nf(10)\n#&gt; f()\n#&gt; g()\n#&gt; b = 10 \n#&gt; i()\n#&gt; [1] 20\n\nImprimir la depuración es particularmente útil para el código compilado porque no es raro que el compilador modifique su código hasta el punto de que no pueda descubrir la raíz del problema, incluso cuando se encuentra dentro de un depurador interactivo.\n\n\n22.5.3 RMarkdown\n\n\nLa depuración del código dentro de los archivos RMarkdown requiere algunas herramientas especiales. Primero, si está tejiendo el archivo usando RStudio, cambie a llamar rmarkdown::render(\"path/to/file.Rmd\") en su lugar. Esto ejecuta el código en la sesión actual, lo que facilita la depuración. Si hacer esto hace que el problema desaparezca, deberá descubrir qué hace que los entornos sean diferentes.\nSi el problema persiste, deberá usar sus habilidades de depuración interactiva. Independientemente del método que utilice, necesitará un paso adicional: en el controlador de errores, deberá llamar a sink(). Esto elimina el sumidero predeterminado que usa knitr para capturar todos los resultados y garantiza que pueda ver los resultados en la consola. Por ejemplo, para usar recover() con RMarkdown, colocaría el siguiente código en su bloque de configuración:\n\noptions(error = function() {\n  sink()\n  recover()\n})\n\nEsto generará una advertencia de “no hay disipador para eliminar” cuando se complete knitr; puede ignorar esta advertencia con seguridad.\nSi simplemente quiere un rastreo, la opción más fácil es usar rlang::trace_back(), aprovechando la opción rlang_trace_top_env. Esto garantiza que solo vea el rastreo de su código, en lugar de todas las funciones llamadas por RMarkdown y knitr.\n\noptions(rlang_trace_top_env = rlang::current_env())\noptions(error = function() {\n  sink()\n  print(rlang::trace_back(bottom = sys.frame(-1)), simplify = \"none\")\n})",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Depuración</span>"
    ]
  },
  {
    "objectID": "Debugging.html#sec-non-error-failures",
    "href": "Debugging.html#sec-non-error-failures",
    "title": "22  Depuración",
    "section": "22.6 Fallos sin error",
    "text": "22.6 Fallos sin error\n \nHay otras formas de que una función falle además de arrojar un error:\n\nUna función puede generar una advertencia inesperada. La forma más fácil de rastrear las advertencias es convertirlas en errores con options(warn = 2) y usar la pila de llamadas, como doWithOneRestart(), withOneRestart(), herramientas de depuración regulares. Cuando haga esto, verá algunas llamadas adicionales withRestarts() y .signalSimpleWarning(). Ignórelos: son funciones internas que se utilizan para convertir las advertencias en errores.\nUna función puede generar un mensaje inesperado. Puedes usar rlang::with_abort() para convertir estos mensajes en errores:\n\nf &lt;- function() g()\ng &lt;- function() message(\"Hi!\")\nf()\n#&gt; Hi!\n\nrlang::with_abort(f(), \"message\")\n#&gt; Error: 'with_abort' is not an exported object from 'namespace:rlang'\nrlang::last_trace()\n#&gt; Error: Can't show last error because no error was recorded yet\n\nEs posible que una función nunca regrese. Esto es particularmente difícil de depurar automáticamente, pero a veces terminar la función y mirar el traceback() es informativo. De lo contrario, utilice la depuración de impresión, como en la Sección 22.5.2.\nEl peor de los escenarios es que su código podría fallar por completo en R, dejándolo sin forma de depurar su código de manera interactiva. Esto indica un error en el código compilado (C o C++).\nSi el error está en su código compilado, deberá seguir los enlaces en la Sección 22.4.3 y aprender a usar un depurador de C interactivo (o insertar muchas instrucciones de impresión).\nSi el error está en un paquete o base R, deberá ponerse en contacto con el mantenedor del paquete. En cualquier caso, trabaje para hacer el ejemplo reproducible más pequeño posible (Sección 1.7) para ayudar al desarrollador a ayudarlo.\n\n\n\n\n\nBalamuta, James. 2018a. errorist: Automatically Search Errors or Warnings. https://github.com/coatless/errorist.\n\n\n———. 2018b. searcher: Query Search Interfaces. https://github.com/coatless/searcher.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Depuración</span>"
    ]
  },
  {
    "objectID": "Perf-measure.html",
    "href": "Perf-measure.html",
    "title": "23  Medición de desempeño",
    "section": "",
    "text": "23.1 Introducción\nAntes de que pueda hacer que su código sea más rápido, primero debe averiguar qué lo hace lento. Esto suena fácil, pero no lo es. Incluso los programadores experimentados tienen dificultades para identificar cuellos de botella en su código. Entonces, en lugar de confiar en su intuición, debe perfilar su código: mida el tiempo de ejecución de cada línea de código usando entradas realistas.\nUna vez que haya identificado los cuellos de botella, deberá experimentar cuidadosamente con alternativas para encontrar un código más rápido que aún sea equivalente. En el Capítulo 24 aprenderá un montón de formas de acelerar el código, pero primero necesita aprender cómo microbenchmark para que pueda medir con precisión la diferencia en el rendimiento.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Medición de desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-measure.html#introducción",
    "href": "Perf-measure.html#introducción",
    "title": "23  Medición de desempeño",
    "section": "",
    "text": "Los programadores pierden enormes cantidades de tiempo pensando o preocupándose por la velocidad de las partes no críticas de sus programas, y estos intentos de eficiencia en realidad tienen un fuerte impacto negativo cuando se consideran la depuración y el mantenimiento.\n— Donald Knuth\n\n\n\n\nEstructura\n\nLa Sección 23.2 le muestra cómo usar las herramientas de creación de perfiles para profundizar exactamente en lo que hace que el código sea lento.\nLa Sección 23.3 muestra cómo usar microbenchmarking para explorar implementaciones alternativas y descubrir exactamente cuál es la más rápida.\n\n\n\nRequisitos\nUsaremos profvis para creación de perfiles y bench para microbenchmarking.\n\nlibrary(profvis)\nlibrary(bench)",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Medición de desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-measure.html#sec-profiling",
    "href": "Perf-measure.html#sec-profiling",
    "title": "23  Medición de desempeño",
    "section": "23.2 Perfiles",
    "text": "23.2 Perfiles\n \nEn todos los lenguajes de programación, la herramienta principal utilizada para comprender el rendimiento del código es el generador de perfiles. Hay varios tipos diferentes de perfiladores, pero R usa un tipo bastante simple llamado perfilador estadístico o de muestreo. Un generador de perfiles de muestreo detiene la ejecución del código cada pocos milisegundos y registra la pila de llamadas (es decir, qué función se está ejecutando actualmente y la función que llamó a la función, etc.). Por ejemplo, considere f(), a continuación:\n\nf &lt;- function() {\n  pause(0.1)\n  g()\n  h()\n}\ng &lt;- function() {\n  pause(0.1)\n  h()\n}\nh &lt;- function() {\n  pause(0.1)\n}\n\n(Utilizo profvis::pause() en lugar de Sys.sleep() porque Sys.sleep() no aparece en las salidas de creación de perfiles porque, por lo que R puede decir, no consume tiempo de cálculo .) \nSi perfiláramos la ejecución de f(), deteniendo la ejecución del código cada 0.1 s, veríamos un perfil como este:\n\n\"pause\" \"f\" \n\"pause\" \"g\" \"f\"\n\"pause\" \"h\" \"g\" \"f\"\n\"pause\" \"h\" \"f\"\n\nCada línea representa un “tick” del generador de perfiles (0,1 s en este caso), y las llamadas a funciones se registran de derecha a izquierda: la primera línea muestra f() llamando a pause(). Muestra que el código gasta 0.1 s ejecutando f(), luego 0.2 s ejecutando g(), luego 0.1 s ejecutando h().\nSi realmente perfilamos f(), usando utils::Rprof() como en el código de abajo, es poco probable que obtengamos un resultado tan claro.\n\ntmp &lt;- tempfile()\nRprof(tmp, interval = 0.1)\nf()\nRprof(NULL)\nwriteLines(readLines(tmp))\n#&gt; sample.interval=100000\n#&gt; \"pause\" \"g\" \"f\" \n#&gt; \"pause\" \"h\" \"g\" \"f\" \n#&gt; \"pause\" \"h\" \"f\" \n\nEsto se debe a que todos los perfiladores deben hacer un equilibrio fundamental entre precisión y rendimiento. El compromiso que se obtiene al usar un generador de perfiles de muestreo solo tiene un impacto mínimo en el rendimiento, pero es fundamentalmente estocástico porque existe cierta variabilidad tanto en la precisión del temporizador como en el tiempo que toma cada operación. Eso significa que cada vez que hagas un perfil obtendrás una respuesta ligeramente diferente. Afortunadamente, la variabilidad afecta más a las funciones que tardan muy poco en ejecutarse, que también son las funciones de menor interés.\n\n23.2.1 Visualización de perfiles\n\nLa resolución de creación de perfiles predeterminada es bastante pequeña, por lo que si su función tarda incluso unos segundos, generará cientos de muestras. Eso crece rápidamente más allá de nuestra capacidad de mirar directamente, así que en lugar de usar utils::Rprof() usaremos el paquete profvis para visualizar agregados. profvis también conecta los datos de creación de perfiles con el código fuente subyacente, lo que facilita la creación de un modelo mental de lo que necesita cambiar. Si encuentra que profvis no ayuda con su código, puede probar una de las otras opciones como utils::summaryRprof() o el paquete proftools (Tierney y Jarjour 2016).\nHay dos formas de usar profvis:\n\nDesde el menú Profile en RStudio.\nCon profvis::profvis(). Recomiendo almacenar su código en un archivo separado y source(); esto garantizará que obtenga la mejor conexión entre los datos de creación de perfiles y el código fuente.\n\nsource(\"profiling-example.R\")\nprofvis(f())\n\n\nUna vez completada la creación de perfiles, profvis abrirá un documento HTML interactivo que le permitirá explorar los resultados. Hay dos paneles, como se muestra en la Figura 23.1.\n\n\n\n\n\n\n\n\nFigura 23.1: Salida profvis que muestra la fuente en la parte superior y el gráfico de llamas a continuación.\n\n\n\n\n\nEl panel superior muestra el código fuente, superpuesto con gráficos de barras para memoria y tiempo de ejecución para cada línea de código. Aquí me centraré en el tiempo y volveremos a la memoria en breve. Esta pantalla le brinda una buena idea general de los cuellos de botella, pero no siempre lo ayuda a identificar con precisión la causa. Aquí, por ejemplo, puedes ver que h() tarda 150 ms, el doble que g(); eso no se debe a que la función sea más lenta, sino a que se llama con el doble de frecuencia.\nEl panel inferior muestra un gráfico de llamas que muestra la pila de llamadas completa. Esto le permite ver la secuencia completa de llamadas que conducen a cada función, lo que le permite ver que h() se llama desde dos lugares diferentes. En esta pantalla, puede pasar el mouse sobre las llamadas individuales para obtener más información y ver la línea correspondiente del código fuente, como en la Figura 23.2.\n\n\n\n\n\n\n\n\nFigura 23.2: Al pasar el cursor sobre una llamada en el gráfico de llamas, se resalta la línea de código correspondiente y se muestra información adicional sobre el rendimiento.\n\n\n\n\n\nAlternativamente, puede usar la pestaña de datos, Figura 23.3 le permite sumergirse de forma interactiva en el árbol de datos de rendimiento. Esta es básicamente la misma pantalla que el gráfico de llama (girado 90 grados), pero es más útil cuando tiene pilas de llamadas muy grandes o muy anidadas porque puede optar por hacer zoom de forma interactiva solo en los componentes seleccionados.\n\n\n\n\n\n\n\n\nFigura 23.3: The data gives an interactive tree that allows you to selectively zoom into key components\n\n\n\n\n\n\n\n23.2.2 Perfilado de memoria\n \nHay una entrada especial en el gráfico de llamas que no corresponde a su código: &lt;GC&gt;, que indica que el recolector de basura se está ejecutando. Si &lt;GC&gt; toma mucho tiempo, generalmente es una indicación de que está creando muchos objetos de corta duración. Por ejemplo, tome este pequeño fragmento de código:\n\nx &lt;- integer()\nfor (i in 1:1e4) {\n  x &lt;- c(x, i)\n}\n\nSi lo perfilas, verás que la mayor parte del tiempo lo pasa en el recolector de basura, Figura 23.4.\n\n\n\n\n\n\n\n\nFigura 23.4: Perfilar un bucle que modifica una variable existente revela que la mayor parte del tiempo se pasa en el recolector de basura().\n\n\n\n\n\nCuando vea que el recolector de elementos no utilizados ocupa mucho tiempo en su propio código, a menudo puede descubrir el origen del problema observando la columna de memoria: verá una línea donde se asignan grandes cantidades de memoria (el barra de la derecha) y liberada (la barra de la izquierda). Aquí surge el problema debido a la copia al modificar (Sección 2.3): cada iteración del bucle crea otra copia de x. Aprenderá estrategias para resolver este tipo de problema en la Sección 24.6.\n\n\n23.2.3 Limitaciones\n\nHay algunas otras limitaciones para la creación de perfiles:\n\nLa generación de perfiles no se extiende al código C. Puede ver si su código R llama al código C/C++ pero no qué funciones se llaman dentro de su código C/C++. Desafortunadamente, las herramientas para generar perfiles de código compilado están más allá del alcance de este libro; Comience mirando https://github.com/r-prof/jointprof.\nSi está haciendo mucha programación funcional con funciones anónimas, puede ser difícil averiguar exactamente qué función se está llamando. La forma más fácil de evitar esto es nombrar sus funciones.\nLa evaluación perezosa significa que los argumentos a menudo se evalúan dentro de otra función, y esto complica la pila de llamadas (Sección 7.5.2). Desafortunadamente, el generador de perfiles de R no almacena suficiente información para desenredar la evaluación perezosa, por lo que en el siguiente código, la generación de perfiles haría que pareciera que i() fue llamado por j() porque el argumento no se evalúa hasta que lo necesita j().\n\ni &lt;- function() {\n  pause(0.1)\n  10\n}\nj &lt;- function(x) {\n  x + 10\n}\nj(i())\n\nSi esto es confuso, use force() (Sección 10.2.3) para forzar que el cálculo ocurra antes.\n\n\n\n23.2.4 Ejercicios\n\n\nPerfila la siguiente función con torture = 10. ¿Qué es sorprendente? Lea el código fuente de rm() para averiguar qué está pasando.\n\nf &lt;- function(n = 1e5) {\n  x &lt;- rep(1, n)\n  rm(x)\n}",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Medición de desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-measure.html#sec-microbenchmarking",
    "href": "Perf-measure.html#sec-microbenchmarking",
    "title": "23  Medición de desempeño",
    "section": "23.3 Microbenchmark",
    "text": "23.3 Microbenchmark\n \nUn microbenchmark es una medida del rendimiento de un fragmento de código muy pequeño, algo que puede tardar milisegundos (ms), microsegundos (µs) o nanosegundos (ns) en ejecutarse. Los microbenchmarks son útiles para comparar pequeños fragmentos de código para tareas específicas. Tenga mucho cuidado al generalizar los resultados de los micropuntos de referencia al código real: las diferencias observadas en los micropuntos de referencia normalmente estarán dominadas por efectos de orden superior en el código real; una comprensión profunda de la física subatómica no es muy útil al hornear.\nUna gran herramienta para microbenchmarking en R es el paquete de banco (Hester 2018). El paquete de banco utiliza un temporizador de alta precisión, lo que permite comparar operaciones que solo toman una pequeña cantidad de tiempo. Por ejemplo, el siguiente código compara la velocidad de dos enfoques para calcular una raíz cuadrada.\n\nx &lt;- runif(100)\n(lb &lt;- bench::mark(\n  sqrt(x),\n  x ^ 0.5\n))\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 sqrt(x)    379.98ns 410.01ns  2292903.      848B     229.\n#&gt; 2 x^0.5        1.98µs   2.02µs   487035.      848B       0\n\nDe forma predeterminada, bench::mark() ejecuta cada expresión al menos una vez (min_iterations = 1) y, como máximo, las veces necesarias para tardar 0,5 s (min_time = 0,5). Comprueba que cada ejecución devuelve el mismo valor, que suele ser lo que desea microbenchmarking; si desea comparar la velocidad de las expresiones que devuelven valores diferentes, configure check = FALSE.\n\n23.3.1 Resultados de bench::mark()\n\nbench::mark() devuelve los resultados como un tibble, con una fila para cada expresión de entrada y las siguientes columnas:\n\nmin, mean, median, max, y itr/sec resume el tiempo que tarda la expresión. Concéntrese en el mínimo (el mejor tiempo de ejecución posible) y la mediana (el tiempo típico). En este ejemplo, puede ver que usar la función sqrt() de propósito especial es más rápido que el operador de exponenciación general.\nPuedes visualizar la distribución de los tiempos individuales con plot():\n\nplot(lb)\n#&gt; Loading required namespace: tidyr\n\n\n\n\n\n\n\n\nLa distribución tiende a ser muy sesgada hacia la derecha (¡tenga en cuenta que el eje x ya está en una escala logarítmica!), razón por la cual debe evitar comparar medias. También verá a menudo multimodalidad porque su computadora está ejecutando algo más en segundo plano.\nmem_alloc te dice la cantidad de memoria asignada por la primera ejecución, y n_gc() te dice el número total de recolecciones de basura en todas las ejecuciones. Estos son útiles para evaluar el uso de memoria de la expresión.\nn_itr y total_time le dice cuántas veces se evaluó la expresión y cuánto tiempo tomó en total. n_itr siempre será mayor que el parámetro min_iteration, y total_time siempre será mayor que el parámetro min_time.\nresult, memory, time, y gc son columnas de lista que almacenan los datos subyacentes sin procesar.\n\nDebido a que el resultado es un tipo especial de tibble, puede usar [ para seleccionar solo las columnas más importantes. Lo haré con frecuencia en el próximo capítulo.\n\nlb[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 2 × 4\n#&gt;   expression      min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 sqrt(x)    379.98ns 410.01ns  2292903.\n#&gt; 2 x^0.5        1.98µs   2.02µs   487035.\n\n\n\n23.3.2 Interpretación de resultados\nAl igual que con todos los micropuntos de referencia, preste mucha atención a las unidades: aquí, cada cálculo toma alrededor de 380 ns, 380 mil millonésimas de segundo. Para ayudar a calibrar el impacto de un micropunto de referencia en el tiempo de ejecución, es útil pensar cuántas veces debe ejecutarse una función antes de que tarde un segundo. Si un microbenchmark toma:\n\n1 ms, entonces mil llamadas toman un segundo.\n1 µs, luego un millón de llamadas toman un segundo.\n1 ns, luego mil millones de llamadas toman un segundo.\n\nLa función sqrt() toma aproximadamente 380 ns, o 0.38 µs, para calcular las raíces cuadradas de 100 números. Eso significa que si repitió la operación un millón de veces, tomaría 0.38 s y, por lo tanto, es poco probable que cambiar la forma en que calcula la raíz cuadrada afecte significativamente el código real. Esta es la razón por la que debe tener cuidado al generalizar los resultados de microbenchmarking.\n\n\n23.3.3 Ejercicios\n\nEn lugar de usar bench::mark(), podrías usar la función integrada system.time(). Pero system.time() es mucho menos preciso, por lo que deberá repetir cada operación muchas veces con un ciclo y luego dividir para encontrar el tiempo promedio de cada operación, como en el código a continuación.\n\nn &lt;- 1e6\nsystem.time(for (i in 1:n) sqrt(x)) / n\nsystem.time(for (i in 1:n) x ^ 0.5) / n\n\n¿Cómo se comparan las estimaciones de system.time() con las de bench::mark()? ¿Por qué son diferentes?\nAquí hay otras dos formas de calcular la raíz cuadrada de un vector. ¿Cuál crees que será más rápido? ¿Cuál será más lento? Utilice microbenchmarking para probar sus respuestas.\n\nx ^ (1 / 2)\nexp(log(x) / 2)\n\n\n\n\n\n\nHester, Jim. 2018. bench: high precision timing of R expressions. http://bench.r-lib.org/.\n\n\nTierney, Luke, y Riad Jarjour. 2016. proftools: Profile Output Processing Tools for R. https://CRAN.R-project.org/package=proftools.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Medición de desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html",
    "href": "Perf-improve.html",
    "title": "24  Mejorando el desempeño",
    "section": "",
    "text": "24.1 Introducción\nUna vez que haya utilizado la creación de perfiles para identificar un cuello de botella, debe hacerlo más rápido. Es difícil dar consejos generales sobre cómo mejorar el rendimiento, pero hago lo mejor que puedo con cuatro técnicas que se pueden aplicar en muchas situaciones. También sugeriré una estrategia general para la optimización del rendimiento que ayude a garantizar que su código más rápido siga siendo correcto.\nEs fácil quedar atrapado tratando de eliminar todos los cuellos de botella. ¡No! Su tiempo es valioso y es mejor gastarlo analizando sus datos, no eliminando posibles ineficiencias en su código. Sea pragmático: no gaste horas de su tiempo para ahorrar segundos de tiempo de computadora. Para hacer cumplir este consejo, debe establecer un objetivo de tiempo para su código y optimizar solo hasta ese objetivo. Esto significa que no eliminará todos los cuellos de botella. Algunas no las alcanzarás porque has cumplido tu objetivo. Es posible que deba pasar por alto otros y aceptarlos porque no hay una solución rápida y fácil o porque el código ya está bien optimizado y no es posible una mejora significativa. Acepte estas posibilidades y pase al siguiente candidato.\nSi desea obtener más información sobre las características de rendimiento del lenguaje R, le recomiendo Evaluar el diseño del lenguaje R (Morandat et al. 2012). Saca conclusiones al combinar un intérprete R modificado con un amplio conjunto de código que se encuentra en la naturaleza.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#introducción",
    "href": "Perf-improve.html#introducción",
    "title": "24  Mejorando el desempeño",
    "section": "",
    "text": "Deberíamos olvidarnos de las pequeñas eficiencias, digamos alrededor del 97% del tiempo: la optimización prematura es la raíz de todos los males. Sin embargo, no debemos dejar pasar nuestras oportunidades en ese crítico 3%. Un buen programador no se dejará llevar por la complacencia de tal razonamiento, será prudente al mirar cuidadosamente el código crítico; pero solo después de que ese código haya sido identificado.\n— Donald Knuth\n\n\n\n\n\nEstructura\n\nLa Sección 24.2 le enseña cómo organizar su código para que la optimización sea lo más fácil y libre de errores posible.\nLa Sección 24.3 le recuerda que busque las soluciones existentes.\nLa Sección 24.4 enfatiza la importancia de ser perezoso: a menudo, la forma más fácil de hacer una función más rápida es dejar que haga menos trabajo.\nLa Sección 24.5 define de forma concisa la vectorización y le muestra cómo aprovechar al máximo las funciones integradas.\nLa Sección 24.6 analiza los peligros de rendimiento de la copia de datos.\nLa Sección 24.7 reúne todas las piezas en un estudio de caso que muestra cómo acelerar las pruebas t repetidas unas mil veces.\nLa Sección 24.8 termina el capítulo con indicaciones a más recursos que lo ayudarán a escribir código rápido.\n\n\n\nRequisitos previos\nUsaremos bench para comparar con precisión el rendimiento de pequeños fragmentos de código independientes.\n\nlibrary(bench)",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#sec-code-organisation",
    "href": "Perf-improve.html#sec-code-organisation",
    "title": "24  Mejorando el desempeño",
    "section": "24.2 Organización del código",
    "text": "24.2 Organización del código\n\nHay dos trampas en las que es fácil caer cuando intentas hacer tu código más rápido:\n\nEscribir código más rápido pero incorrecto.\nEscribir código que crees que es más rápido, pero que en realidad no es mejor.\n\nLa estrategia descrita a continuación le ayudará a evitar estas trampas.\nAl abordar un cuello de botella, es probable que encuentre múltiples enfoques. Escriba una función para cada enfoque, encapsulando todo el comportamiento relevante. Esto hace que sea más fácil verificar que cada enfoque devuelva el resultado correcto y cronometrar cuánto tiempo lleva ejecutarse. Para demostrar la estrategia, compararé dos enfoques para calcular la media:\n\nmean1 &lt;- function(x) mean(x)\nmean2 &lt;- function(x) sum(x) / length(x)\n\nTe recomiendo que lleves un registro de todo lo que intentes, incluso de los fracasos. Si ocurre un problema similar en el futuro, será útil ver todo lo que ha intentado. Para hacer esto, recomiendo RMarkdown, que facilita la combinación de código con comentarios y notas detallados.\nA continuación, genere un caso de prueba representativo. El caso debe ser lo suficientemente grande para capturar la esencia de su problema, pero lo suficientemente pequeño como para que solo tome unos segundos como máximo. No desea que tarde demasiado porque necesitará ejecutar el caso de prueba muchas veces para comparar enfoques. Por otro lado, no desea que el caso sea demasiado pequeño porque es posible que los resultados no alcancen el problema real. Aquí voy a usar 100,000 números:\n\nx &lt;- runif(1e5)\n\nAhora usa bench::mark() para comparar con precisión las variaciones. bench::mark() verifica automáticamente que todas las llamadas devuelvan los mismos valores. Esto no garantiza que la función se comporte de la misma manera para todas las entradas, por lo que en un mundo ideal también tendrá pruebas unitarias para asegurarse de no cambiar accidentalmente el comportamiento de la función.\n\nbench::mark(\n  mean1(x),\n  mean2(x)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 2 × 4\n#&gt;   expression      min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean1(x)      417µs    437µs     2277.\n#&gt; 2 mean2(x)      186µs    187µs     5319.\n\n(Puede que te sorprendan los resultados: mean(x) es considerablemente más lento que sum(x) / length(x). Esto se debe a que, entre otras razones, mean(x) hace dos pasadas sobre el vector para que sea numéricamente más preciso.)\nSi desea ver esta estrategia en acción, la he usado varias veces en stackoverflow:\n\nhttp://stackoverflow.com/questions/22515525#22518603\nhttp://stackoverflow.com/questions/22515175#22515856\nhttp://stackoverflow.com/questions/3476015#22511936",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#sec-already-solved",
    "href": "Perf-improve.html#sec-already-solved",
    "title": "24  Mejorando el desempeño",
    "section": "24.3 Comprobación de soluciones existentes",
    "text": "24.3 Comprobación de soluciones existentes\nUna vez que haya organizado su código y capturado todas las variaciones que se le ocurran, es natural ver lo que otros han hecho. Eres parte de una gran comunidad y es muy posible que alguien ya haya abordado el mismo problema. Dos buenos lugares para comenzar son:\n\nCRAN task views. Si hay una vista de tareas CRAN relacionada con el dominio de su problema, vale la pena mirar los paquetes enumerados allí.\nDependencias inversas de Rcpp, como se indica en su página de CRAN. Dado que estos paquetes usan C++, es probable que sean rápidos.\n\nDe lo contrario, el desafío es describir su cuello de botella de una manera que lo ayude a encontrar problemas y soluciones relacionados. Saber el nombre del problema o sus sinónimos hará que esta búsqueda sea mucho más fácil. Pero como no sabes cómo se llama, ¡es difícil buscarlo! La mejor manera de resolver este problema es leer mucho para que puedas construir tu propio vocabulario con el tiempo. Alternativamente, pregunte a otros. Hable con sus colegas y haga una lluvia de ideas sobre algunos nombres posibles, luego busque en Google y StackOverflow. Suele ser útil restringir la búsqueda a páginas relacionadas con R. Para Google, pruebe rseek. Para stackoverflow, restrinja su búsqueda incluyendo la etiqueta R, [R], en su búsqueda.\nRegistre todas las soluciones que encuentre, no solo aquellas que parezcan ser más rápidas inmediatamente. Algunas soluciones pueden ser más lentas inicialmente, pero terminan siendo más rápidas porque son más fáciles de optimizar. También puede combinar las partes más rápidas desde diferentes enfoques. Si ha encontrado una solución lo suficientemente rápida, ¡felicidades! De lo contrario, sigue leyendo.\n\n24.3.1 Ejercicios\n\n¿Cuáles son las alternativas más rápidas a lm()? ¿Cuáles están diseñados específicamente para trabajar con conjuntos de datos más grandes?\n¿Qué paquete implementa una versión de match() que es más rápida para búsquedas repetidas? ¿Cuánto más rápido es?\nEnumere cuatro funciones (no solo las de base R) que convierten una cadena en un objeto de fecha y hora. Cuales son sus fortalezas y debilidades?\n¿Qué paquetes brindan la capacidad de calcular una media móvil?\n¿Cuáles son las alternativas a optim()?",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#sec-be-lazy",
    "href": "Perf-improve.html#sec-be-lazy",
    "title": "24  Mejorando el desempeño",
    "section": "24.4 Haciendo lo menos posible",
    "text": "24.4 Haciendo lo menos posible\nLa forma más fácil de hacer que una función sea más rápida es dejar que haga menos trabajo. Una forma de hacerlo es usar una función adaptada a un tipo de entrada o salida más específico, o a un problema más específico. Por ejemplo:\n\nrowSums(), colSums(), rowMeans(), y colMeans() son más rápidas que las invocaciones equivalentes que usan apply() porque están vectorizadas (Sección 24.5).\nvapply() es más rápido que sapply() porque especifica previamente el tipo de salida.\nSi quiere ver si un vector contiene un solo valor, any(x == 10) es mucho más rápido que 10 %in% x porque probar la igualdad es más simple que probar la inclusión de conjuntos.\n\nTener este conocimiento al alcance de la mano requiere saber que existen funciones alternativas: es necesario tener un buen vocabulario. Amplíe su vocabulario leyendo regularmente el código R. Buenos lugares para leer código son la lista de correo de R-help y StackOverflow.\nAlgunas funciones obligan a sus entradas a un tipo específico. Si su entrada no es del tipo correcto, la función tiene que hacer un trabajo extra. En su lugar, busque una función que funcione con sus datos tal como están, o considere cambiar la forma en que almacena sus datos. El ejemplo más común de este problema es usar apply() en un marco de datos. apply() siempre convierte su entrada en una matriz. No solo es propenso a errores (porque un marco de datos es más general que una matriz), sino que también es más lento.\nOtras funciones harán menos trabajo si les proporciona más información sobre el problema. Siempre vale la pena leer detenidamente la documentación y experimentar con diferentes argumentos. Algunos ejemplos que he descubierto en el pasado incluyen:\n\nread.csv(): especificar tipos de columnas conocidas con colClasses. (También considere cambiar a readr::read_csv() o data.table::fread() que son considerablemente más rápidos que read.csv().)\nfactor(): especificar niveles conocidos con levels.\ncut(): no genere etiquetas con labels = FALSE si no las necesita o, mejor aún, use findInterval() como se menciona en la sección “ver también” de la documentación.\nunlist(x, use.names = FALSE) es mucho más rápido que unlist(x).\ninteraction(): si solo necesita combinaciones que existen en los datos, use drop = TRUE.\n\nA continuación, exploro cómo podría mejorar la aplicación de esta estrategia para mejorar el rendimiento de mean() y as.data.frame().\n\n24.4.1 mean()\n\n\nA veces, puede hacer que una función sea más rápida evitando el envío de métodos. Si está llamando a un método en un ciclo cerrado, puede evitar algunos de los costos haciendo la búsqueda del método solo una vez:\n\nPara S3, puede hacer esto llamando a generic.class() en lugar de generic().\nPara S4, puede hacer esto usando selectMethod() para encontrar el método, guardándolo en una variable y luego llamando a esa función.\n\nPor ejemplo, llamar a mean.default() es un poco más rápido que llamar a mean() para vectores pequeños:\n\nx &lt;- runif(1e2)\n\nbench::mark(\n  mean(x),\n  mean.default(x)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 2 × 4\n#&gt;   expression           min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean(x)           2.88µs   3.15µs   288781.\n#&gt; 2 mean.default(x)   1.86µs   1.99µs   478356.\n\nEsta optimización es un poco arriesgada. Si bien mean.default() es casi el doble de rápido para 100 valores, fallará de manera sorprendente si x no es un vector numérico.\nUna optimización aún más arriesgada es llamar directamente a la función .Internal subyacente. Esto es más rápido porque no realiza ninguna verificación de entrada ni maneja NA, por lo que está comprando velocidad a costa de la seguridad.\n\nx &lt;- runif(1e2)\nbench::mark(\n  mean(x),\n  mean.default(x),\n  .Internal(mean(x))\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 3 × 4\n#&gt;   expression              min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean(x)              2.92µs   3.19µs   306080.\n#&gt; 2 mean.default(x)      1.87µs   1.98µs   485384.\n#&gt; 3 .Internal(mean(x))  480.1ns 501.05ns  1981460.\n\nNB: La mayoría de estas diferencias surgen porque x es pequeño. Si aumenta el tamaño, las diferencias básicamente desaparecen, porque la mayor parte del tiempo ahora se dedica a calcular la media, sin encontrar la implementación subyacente. Este es un buen recordatorio de que el tamaño de la entrada es importante y debe motivar sus optimizaciones en función de datos realistas.\n\nx &lt;- runif(1e4)\nbench::mark(\n  mean(x),\n  mean.default(x),\n  .Internal(mean(x))\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 3 × 4\n#&gt;   expression              min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 mean(x)              41.7µs   46.1µs    21606.\n#&gt; 2 mean.default(x)        41µs   44.8µs    22202.\n#&gt; 3 .Internal(mean(x))   37.7µs   43.3µs    23053.\n\n\n\n24.4.2 as.data.frame()\n\nSaber que está tratando con un tipo específico de entrada puede ser otra forma de escribir código más rápido. Por ejemplo, as.data.frame() es bastante lento porque convierte cada elemento en un marco de datos y luego rbind() los une. Si tiene una lista con nombre con vectores de igual longitud, puede transformarla directamente en un marco de datos. En este caso, si puede hacer suposiciones sólidas sobre su entrada, puede escribir un método que sea considerablemente más rápido que el predeterminado.\n\nquickdf &lt;- function(l) {\n  class(l) &lt;- \"data.frame\"\n  attr(l, \"row.names\") &lt;- .set_row_names(length(l[[1]]))\n  l\n}\n\nl &lt;- lapply(1:26, function(i) runif(1e3))\nnames(l) &lt;- letters\n\nbench::mark(\n  as.data.frame = as.data.frame(l),\n  quick_df      = quickdf(l)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 2 × 4\n#&gt;   expression         min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;    &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 as.data.frame 956.43µs   1.01ms      970.\n#&gt; 2 quick_df        6.42µs   7.31µs   129784.\n\nUna vez más, tenga en cuenta la compensación. Este método es rápido porque es peligroso. Si le da entradas incorrectas, obtendrá un marco de datos corrupto:\n\nquickdf(list(x = 1, y = 1:2))\n#&gt; Warning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\n#&gt; corrupt data frame: columns will be truncated or padded with NAs\n#&gt;   x y\n#&gt; 1 1 1\n\nPara llegar a este método mínimo, leí cuidadosamente y luego reescribí el código fuente para as.data.frame.list() y data.frame(). Hice muchos pequeños cambios, comprobando cada vez que no había roto el comportamiento existente. Después de varias horas de trabajo, pude aislar el código mínimo que se muestra arriba. Esta es una técnica muy útil. La mayoría de las funciones básicas de R están escritas para la flexibilidad y la funcionalidad, no para el rendimiento. Por lo tanto, reescribir para su necesidad específica a menudo puede generar mejoras sustanciales. Para hacer esto, deberá leer el código fuente. Puede ser complejo y confuso, ¡pero no te rindas!\n\n\n24.4.3 Ejercicios\n\n¿Cuál es la diferencia entre rowSums() y .rowSums()?\nCree una versión más rápida de chisq.test() que solo calcula la estadística de prueba de chi-cuadrado cuando la entrada son dos vectores numéricos sin valores faltantes. Puede intentar simplificar chisq.test() o codificar desde la definición matemática.\n¿Puedes hacer una versión más rápida de table() para el caso de una entrada de dos vectores enteros sin valores perdidos? ¿Puedes usarlo para acelerar tu prueba de chi-cuadrado?",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#sec-vectorise",
    "href": "Perf-improve.html#sec-vectorise",
    "title": "24  Mejorando el desempeño",
    "section": "24.5 Vectorizar",
    "text": "24.5 Vectorizar\n\nSi ha usado R durante algún tiempo, probablemente haya escuchado la advertencia de “vectorizar su código”. Pero, ¿qué significa eso realmente? Vectorizar su código no se trata solo de evitar bucles for, aunque eso suele ser un paso. Vectorizar se trata de adoptar un enfoque de objeto completo para un problema, pensando en vectores, no en escalares. Hay dos atributos clave de una función vectorizada:\n\nSimplifica muchos problemas. En lugar de tener que pensar en los componentes de un vector, solo piensa en vectores completos.\nLos bucles en una función vectorizada están escritos en C en lugar de R. Los bucles en C son mucho más rápidos porque tienen mucha menos sobrecarga.\n\nEl Capítulo 9 hizo hincapié en la importancia del código vectorizado como una abstracción de mayor nivel. La vectorización también es importante para escribir código R rápido. Esto no significa simplemente usar map() o lapply(). En cambio, la vectorización significa encontrar la función R existente que se implementa en C y se aplica más a su problema.\nLas funciones vectorizadas que se aplican a muchos cuellos de botella de rendimiento comunes incluyen:\n\nrowSums(), colSums(), rowMeans(), y colMeans(). Estas funciones matriciales vectorizadas siempre serán más rápidas que usar apply(). A veces puede usar estas funciones para construir otras funciones vectorizadas.\n\nrowAny &lt;- function(x) rowSums(x) &gt; 0\nrowAll &lt;- function(x) rowSums(x) == ncol(x)\n\nLa creación de subconjuntos vectorizados puede conducir a grandes mejoras en la velocidad. Recuerde las técnicas detrás de las tablas de búsqueda (Sección 4.5.1) y la combinación y combinación manual (Sección 4.5.2). Recuerde también que puede usar la asignación de subconjuntos para reemplazar varios valores en un solo paso. Si x es un vector, una matriz o un marco de datos, entonces x[is.na(x)] &lt;- 0 reemplazará todos los valores faltantes con 0.\nSi está extrayendo o reemplazando valores en ubicaciones dispersas en una matriz o marco de datos, subconjunto con una matriz de enteros. Consulte Sección 4.2.3 para obtener más detalles.\nSi está convirtiendo valores continuos a categóricos, asegúrese de saber cómo usar cut() y findInterval().\nTenga en cuenta las funciones vectorizadas como cumsum() y diff().\n\nEl álgebra matricial es un ejemplo general de vectorización. Estos bucles son ejecutados por bibliotecas externas altamente optimizadas como BLAS. Si puede encontrar una manera de usar el álgebra matricial para resolver su problema, a menudo obtendrá una solución muy rápida. La habilidad para resolver problemas con álgebra matricial es producto de la experiencia. Un buen lugar para comenzar es preguntar a personas con experiencia en su dominio.\nLa vectorización tiene un inconveniente: es más difícil predecir cómo escalarán las operaciones. El siguiente ejemplo mide cuánto tiempo lleva usar subconjuntos de caracteres para buscar 1, 10 y 100 elementos de una lista. Podría esperar que buscar 10 elementos tomara 10 veces más que buscar 1, y que buscar 100 elementos tomaría 10 veces más de nuevo. De hecho, el siguiente ejemplo muestra que solo se tarda aproximadamente ~10 veces más en buscar 100 elementos que en buscar 1. Eso sucede porque una vez que llega a un cierto tamaño, la implementación interna cambia a una estrategia que tiene un mayor costo de instalación, pero escala mejor.\n\nlookup &lt;- setNames(as.list(sample(100, 26)), letters)\n\nx1 &lt;- \"j\"\nx10 &lt;- sample(letters, 10)\nx100 &lt;- sample(letters, 100, replace = TRUE)\n\nbench::mark(\n  lookup[x1],\n  lookup[x10],\n  lookup[x100],\n  check = FALSE\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 3 × 4\n#&gt;   expression        min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt;   &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 lookup[x1]   420.03ns  461.1ns  1983301.\n#&gt; 2 lookup[x10]    1.24µs    1.3µs   716742.\n#&gt; 3 lookup[x100]   2.88µs    4.6µs   226070.\n\nLa vectorización no resolverá todos los problemas y, en lugar de convertir un algoritmo existente en uno que utilice un enfoque vectorizado, a menudo es mejor escribir su propia función vectorizada en C++. Aprenderá cómo hacerlo en el Capítulo 25.\n\n24.5.1 Ejercicios\n\nLas funciones de densidad, por ejemplo, dnorm(), tienen una interfaz común. ¿Qué argumentos se vectorizan? ¿Qué hace rnorm(10, mean = 10:1)?\nCompara la velocidad de apply(x, 1, sum) con rowSums(x) para diferentes tamaños de x.\n¿Cómo puedes usar crossprod() para calcular una suma ponderada? ¿Cuánto más rápido es que el ingenuo sum(x * w)?",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#sec-avoid-copies",
    "href": "Perf-improve.html#sec-avoid-copies",
    "title": "24  Mejorando el desempeño",
    "section": "24.6 Evitar copias",
    "text": "24.6 Evitar copias\n \nUna fuente perniciosa de código R lento es hacer crecer un objeto con un bucle. Siempre que use c(), append(), cbind(), rbind() o paste() para crear un objeto más grande, R primero debe asignar espacio para el nuevo objeto y luego copiar el objeto antiguo a su nuevo hogar. Si repite esto muchas veces, como en un ciclo for, esto puede ser bastante costoso. Has entrado en el Círculo 2 del R inferno.\nViste un ejemplo de este tipo de problema en la Sección 23.2.2, así que aquí mostraré un ejemplo un poco más complejo del mismo problema básico. Primero generamos algunas cadenas aleatorias y luego las combinamos iterativamente con un ciclo usando collapse(), o en un solo paso usando paste(). Tenga en cuenta que el rendimiento de collapse() empeora relativamente a medida que aumenta el número de cadenas: combinar 100 cadenas lleva casi 30 veces más que combinar 10 cadenas.\n\nrandom_string &lt;- function() {\n  paste(sample(letters, 50, replace = TRUE), collapse = \"\")\n}\nstrings10 &lt;- replicate(10, random_string())\nstrings100 &lt;- replicate(100, random_string())\n\ncollapse &lt;- function(xs) {\n  out &lt;- \"\"\n  for (x in xs) {\n    out &lt;- paste0(out, x)\n  }\n  out\n}\n\nbench::mark(\n  loop10  = collapse(strings10),\n  loop100 = collapse(strings100),\n  vec10   = paste(strings10, collapse = \"\"),\n  vec100  = paste(strings100, collapse = \"\"),\n  check = FALSE\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#&gt; # A tibble: 4 × 4\n#&gt;   expression      min   median `itr/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;\n#&gt; 1 loop10      19.64µs  21.08µs    46392.\n#&gt; 2 loop100    521.65µs 555.82µs     1799.\n#&gt; 3 vec10        3.56µs   3.88µs   253849.\n#&gt; 4 vec100      22.41µs  23.05µs    42740.\n\nModificar un objeto en un bucle, por ejemplo, x[i] &lt;- y, también puede crear una copia, dependiendo de la clase de x. La Sección 2.5.1 analiza este problema con mayor profundidad y le brinda algunas herramientas para determinar cuándo está haciendo copias.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#sec-t-test",
    "href": "Perf-improve.html#sec-t-test",
    "title": "24  Mejorando el desempeño",
    "section": "24.7 Caso de estudio: t-test",
    "text": "24.7 Caso de estudio: t-test\nEl siguiente estudio de caso muestra cómo hacer que las pruebas t sean más rápidas utilizando algunas de las técnicas descritas anteriormente. Se basa en un ejemplo de Cálculo de miles de estadísticas de prueba simultáneamente en R de Holger Schwender y Tina Müller. Recomiendo encarecidamente leer el documento completo para ver la misma idea aplicada a otras pruebas.\nImagine que hemos realizado 1000 experimentos (filas), cada uno de los cuales recopila datos de 50 individuos (columnas). Los primeros 25 individuos de cada experimento se asignan al grupo 1 y el resto al grupo 2. Primero generaremos algunos datos aleatorios para representar este problema:\n\nm &lt;- 1000\nn &lt;- 50\nX &lt;- matrix(rnorm(m * n, mean = 10, sd = 3), nrow = m)\ngrp &lt;- rep(1:2, each = n / 2)\n\nPara los datos en este formulario, hay dos formas de usar t.test(). Podemos usar la interfaz de fórmula o proporcionar dos vectores, uno para cada grupo. El tiempo revela que la interfaz de la fórmula es considerablemente más lenta.\n\nsystem.time(\n  for (i in 1:m) {\n    t.test(X[i, ] ~ grp)$statistic\n  }\n)\n#&gt;    user  system elapsed \n#&gt;   0.388   0.004   0.392\nsystem.time(\n  for (i in 1:m) {\n    t.test(X[i, grp == 1], X[i, grp == 2])$statistic\n  }\n)\n#&gt;    user  system elapsed \n#&gt;   0.113   0.000   0.113\n\nPor supuesto, un bucle for calcula, pero no guarda los valores. Podemos map_dbl() (Sección 9.2.1) para hacer eso. Esto agrega un poco de sobrecarga:\n\ncompT &lt;- function(i){\n  t.test(X[i, grp == 1], X[i, grp == 2])$statistic\n}\nsystem.time(t1 &lt;- purrr::map_dbl(1:m, compT))\n#&gt;    user  system elapsed \n#&gt;   0.124   0.000   0.124\n\n¿Cómo podemos hacer esto más rápido? Primero, podríamos intentar hacer menos trabajo. Si observa el código fuente de stats:::t.test.default(), verá que hace mucho más que calcular la estadística t. También calcula el valor p y formatea la salida para su impresión. Podemos intentar que nuestro código sea más rápido eliminando esas piezas.\n\nmy_t &lt;- function(x, grp) {\n  t_stat &lt;- function(x) {\n    m &lt;- mean(x)\n    n &lt;- length(x)\n    var &lt;- sum((x - m) ^ 2) / (n - 1)\n\n    list(m = m, n = n, var = var)\n  }\n\n  g1 &lt;- t_stat(x[grp == 1])\n  g2 &lt;- t_stat(x[grp == 2])\n\n  se_total &lt;- sqrt(g1$var / g1$n + g2$var / g2$n)\n  (g1$m - g2$m) / se_total\n}\n\nsystem.time(t2 &lt;- purrr::map_dbl(1:m, ~ my_t(X[.,], grp)))\n#&gt;    user  system elapsed \n#&gt;   0.024   0.000   0.024\nstopifnot(all.equal(t1, t2))\n\nEsto nos da una mejora de velocidad de seis veces.\nAhora que tenemos una función bastante simple, podemos hacerla aún más rápida al vectorizarla. En lugar de recorrer la matriz fuera de la función, modificaremos t_stat() para que funcione con una matriz de valores. Por lo tanto, mean() se convierte en rowMeans(), length() se convierte en ncol() y sum() se convierte en rowSums(). El resto del código permanece igual.\n\nrowtstat &lt;- function(X, grp){\n  t_stat &lt;- function(X) {\n    m &lt;- rowMeans(X)\n    n &lt;- ncol(X)\n    var &lt;- rowSums((X - m) ^ 2) / (n - 1)\n\n    list(m = m, n = n, var = var)\n  }\n\n  g1 &lt;- t_stat(X[, grp == 1])\n  g2 &lt;- t_stat(X[, grp == 2])\n\n  se_total &lt;- sqrt(g1$var / g1$n + g2$var / g2$n)\n  (g1$m - g2$m) / se_total\n}\nsystem.time(t3 &lt;- rowtstat(X, grp))\n#&gt;    user  system elapsed \n#&gt;   0.010   0.000   0.009\nstopifnot(all.equal(t1, t3))\n\n¡Eso es mucho más rápido! Es al menos 40 veces más rápido que nuestro esfuerzo anterior y alrededor de 1000 veces más rápido que donde comenzamos.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Perf-improve.html#sec-more-techniques",
    "href": "Perf-improve.html#sec-more-techniques",
    "title": "24  Mejorando el desempeño",
    "section": "24.8 Otras tecnicas",
    "text": "24.8 Otras tecnicas\nSer capaz de escribir código R rápido es parte de ser un buen programador R. Más allá de las sugerencias específicas de este capítulo, si desea escribir código R rápido, deberá mejorar sus habilidades generales de programación. Algunas formas de hacer esto son:\n\nRead R blogs para ver con qué problemas de rendimiento han luchado otras personas y cómo han hecho que su código sea más rápido.\nLea otros libros de programación R, como El arte de la programación R (Matloff 2011) o [R Inferno] de Patrick Burns (http://www.burns-stat.com/documents/books/the -r-inferno/) para conocer las trampas comunes.\nTome un curso de algoritmos y estructura de datos para aprender algunas formas bien conocidas de abordar ciertas clases de problemas. Escuché cosas buenas sobre el curso de algoritmos de Princeton que se ofrece en Coursera.\nAprende a paralelizar tu código. Dos lugares para comenzar son Parallel R (McCallum y Weston 2011) y Parallel Computing for Data Science (Matloff 2015).\nLea libros generales sobre optimización como Optimización madura (Bueno 2013) o el Programador pragmático (Hunt y Thomas 1990).\n\nTambién puede comunicarse con la comunidad para obtener ayuda. StackOverflow puede ser un recurso útil. Deberá esforzarse un poco para crear un ejemplo fácilmente digerible que también capture las características más destacadas de su problema. Si su ejemplo es demasiado complejo, pocas personas tendrán el tiempo y la motivación para intentar una solución. Si es demasiado simple, obtendrá respuestas que resuelven el problema del juguete pero no el problema real. Si también intenta responder preguntas en StackOverflow, rápidamente tendrá una idea de lo que constituye una buena pregunta.\n\n\n\n\nBueno, Carlos. 2013. Mature Optimization Handbook. http://carlos.bueno.org/optimization/.\n\n\nHunt, Andrew, y David Thomas. 1990. The Pragmatic Programmer. Addison Wesley.\n\n\nMatloff, Norman. 2011. The Art of R Programming. No Starch Press.\n\n\n———. 2015. Parallel Computing for Data Science. Chapman & Hall/CRC. http://amzn.com/1466587016.\n\n\nMcCallum, Q. Ethan, y Steve Weston. 2011. Parallel R. O’Reilly. http://amzn.com/B005Z29QT4.\n\n\nMorandat, Floréal, Brandon Hill, Leo Osvald, y Jan Vitek. 2012. «Evaluating the design of the R language». En European Conference on Object-Oriented Programming, 104-31. Springer. http://r.cs.purdue.edu/pub/ecoop12.pdf.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mejorando el desempeño</span>"
    ]
  },
  {
    "objectID": "Rcpp.html",
    "href": "Rcpp.html",
    "title": "25  Reescribiendo código de R en C++",
    "section": "",
    "text": "25.1 Introducción\nA veces, el código R simplemente no es lo suficientemente rápido. Ha utilizado la creación de perfiles para descubrir dónde están los cuellos de botella y ha hecho todo lo posible en R, pero su código aún no es lo suficientemente rápido. En este capítulo, aprenderá a mejorar el rendimiento reescribiendo funciones clave en C++. Esta magia viene a través del paquete Rcpp (Eddelbuettel y François 2011) (con contribuciones clave de Doug Bates, John Chambers y JJ Allaire).\nRcpp hace que sea muy simple conectar C++ a R. Si bien es posible escribir código C o Fortran para usar en R, será doloroso en comparación. Rcpp proporciona una API limpia y accesible que le permite escribir código de alto rendimiento, aislado de la compleja API C de R.\nLos cuellos de botella típicos que C++ puede abordar incluyen:\nEl objetivo de este capítulo es discutir solo aquellos aspectos de C++ y Rcpp que son absolutamente necesarios para ayudarlo a eliminar los cuellos de botella en su código. No dedicaremos mucho tiempo a funciones avanzadas como la programación orientada a objetos o las plantillas porque el enfoque está en escribir funciones pequeñas e independientes, no grandes programas. Un conocimiento práctico de C++ es útil, pero no esencial. Muchos buenos tutoriales y referencias están disponibles gratuitamente, incluidos http://www.learncpp.com/ y https://en.cppreference.com/w/cpp. Para temas más avanzados, la serie Effective C++ de Scott Meyers es una opción popular.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#introducción",
    "href": "Rcpp.html#introducción",
    "title": "25  Reescribiendo código de R en C++",
    "section": "",
    "text": "Bucles que no se pueden vectorizar fácilmente porque las iteraciones posteriores dependen de las anteriores.\nFunciones recursivas, o problemas que implican llamar funciones millones de veces. La sobrecarga de llamar a una función en C++ es mucho menor que en R.\nProblemas que requieren estructuras de datos y algoritmos avanzados que R no proporciona. A través de la biblioteca de plantillas estándar (STL), C++ tiene implementaciones eficientes de muchas estructuras de datos importantes, desde mapas ordenados hasta colas de dos extremos.\n\n\n\nEstructura\n\nLa Sección 25.2 teaches you how to write C++ by converting simple R functions to their C++ equivalents. You’ll learn how C++ differs from R, and what the key scalar, vector, and matrix classes are called.\nLa Sección 25.2.5 le muestra cómo usar sourceCpp() para cargar un archivo C++ desde el disco de la misma manera que usa source() para cargar un archivo de código R.\nLa Sección 25.3 analiza cómo modificar los atributos de Rcpp y menciona algunas de las otras clases importantes.\nLa Sección 25.4 le enseña cómo trabajar con los valores faltantes de R en C++.\nLa Sección 25.5 le muestra cómo usar algunas de las estructuras de datos y algoritmos más importantes de la biblioteca de plantillas estándar, o STL, integrada en C++.\nLa Sección 25.6 muestra dos estudios de casos reales en los que se utilizó Rcpp para obtener mejoras de rendimiento considerables.\nLa Sección 25.7 le enseña cómo agregar código C++ a un paquete.\nLa Sección 25.8 concluye el capítulo con una lista de más recursos para ayudarlo a aprender Rcpp y C++.\n\n\n\nRequisitos previos\nUsaremos Rcpp para llamar a C++ desde R:\n\nlibrary(Rcpp)\n\nTambién necesitará un compilador de C++ que funcione. Para conseguirlo:\n\nEn Windows, instale Rtools.\nEn Mac, instala Xcode desde la tienda de aplicaciones.\nEn Linux, sudo apt-get install r-base-dev o similar.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#sec-rcpp-intro",
    "href": "Rcpp.html#sec-rcpp-intro",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.2 Empezar con C++",
    "text": "25.2 Empezar con C++\ncppFunction() le permite escribir funciones de C++ en R: \n\ncppFunction('int add(int x, int y, int z) {\n  int sum = x + y + z;\n  return sum;\n}')\n# add funciona como una función R normal\nadd\n#&gt; function (x, y, z) \n#&gt; .Call(&lt;pointer: 0x7f477a8f84d0&gt;, x, y, z)\nadd(1, 2, 3)\n#&gt; [1] 6\n\nCuando ejecute este código, Rcpp compilará el código C++ y construirá una función R que se conecta a la función C++ compilada. Suceden muchas cosas debajo del capó, pero Rcpp se encarga de todos los detalles para que no tengas que preocuparte por ellos.\nLas siguientes secciones le enseñarán los conceptos básicos mediante la traducción de funciones simples de R a sus equivalentes de C++. Comenzaremos de manera simple con una función que no tiene entradas y una salida escalar, y luego la complicaremos progresivamente:\n\nEntrada escalar y salida escalar\nEntrada vectorial y salida escalar\nEntrada vectorial y salida vectorial\nEntrada matricial y salida vectorial\n\n\n25.2.1 Sin entradas, salida escalar\nComencemos con una función muy simple. No tiene argumentos y siempre devuelve el entero 1:\n\none &lt;- function() 1L\n\nThe equivalent C++ function is:\nint one() {\n  return 1;\n}\nLa podemos compilar y usar desde R con cppFunction()\n\ncppFunction('int one() {\n  return 1;\n}')\n\nEsta pequeña función ilustra una serie de diferencias importantes entre R y C++:\n\nLa sintaxis para crear una función se parece a la sintaxis para llamar a una función; no usa la asignación para crear funciones como lo hace en R.\nDebe declarar el tipo de salida que devuelve la función. Esta función devuelve un int (un entero escalar). Las clases para los tipos más comunes de vectores R son: NumericVector, IntegerVector, CharacterVector y LogicalVector.\nLos escalares y los vectores son diferentes. Los equivalentes escalares de vectores numéricos, enteros, de caracteres y lógicos son: doble, int, String y bool.\nDebe usar una declaración return explícita para devolver un valor de una función.\nCada instrucción termina con un ;.\n\n\n\n25.2.2 Entrada escalar, salida escalar\nLa siguiente función de ejemplo implementa una versión escalar de la función sign() que devuelve 1 si la entrada es positiva y -1 si es negativa:\n\nsignR &lt;- function(x) {\n  if (x &gt; 0) {\n    1\n  } else if (x == 0) {\n    0\n  } else {\n    -1\n  }\n}\n\ncppFunction('int signC(int x) {\n  if (x &gt; 0) {\n    return 1;\n  } else if (x == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}')\n\nEn la versión C++:\n\nDeclaramos el tipo de cada entrada de la misma forma que declaramos el tipo de la salida. Si bien esto hace que el código sea un poco más detallado, también aclara el tipo de entrada que necesita la función.\nLa sintaxis if es idéntica — si bien existen grandes diferencias entre R y C++, ¡también hay muchas similitudes! C++ también tiene una instrucción while que funciona de la misma manera que la de R. Como en R, puede usar break para salir del ciclo, pero para omitir una iteración necesita usar continue en lugar de next.\n\n\n\n25.2.3 Entrada vectorial, salida escalar\nUna gran diferencia entre R y C++ es que el costo de los bucles es mucho menor en C++. Por ejemplo, podríamos implementar la función sum en R usando un bucle. Si ha estado programando en R por un tiempo, ¡probablemente tendrá una reacción visceral a esta función!\n\nsumR &lt;- function(x) {\n  total &lt;- 0\n  for (i in seq_along(x)) {\n    total &lt;- total + x[i]\n  }\n  total\n}\n\nEn C++, los bucles tienen muy poca sobrecarga, por lo que está bien usarlos. En la Sección 25.5, verá alternativas a los bucles for que expresan más claramente su intención; no son más rápidos, pero pueden hacer que su código sea más fácil de entender.\n\ncppFunction('double sumC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n  for(int i = 0; i &lt; n; ++i) {\n    total += x[i];\n  }\n  return total;\n}')\n\nLa versión C++ es similar, pero:\n\nPara encontrar la longitud del vector, usamos el método .size(), que devuelve un número entero. Los métodos de C++ se llaman con . (es decir, un punto).\nLa sentencia for tiene una sintaxis diferente: for(init; check; increment). Este bucle se inicializa creando una nueva variable llamada i con valor 0. Antes de cada iteración comprobamos que i &lt; n, y terminamos el bucle si no es así. Después de cada iteración, incrementamos el valor de i en uno, utilizando el operador de prefijo especial ++ que aumenta el valor de i en 1.\nEn C++, los índices vectoriales comienzan en 0, lo que significa que el último elemento está en la posición n - 1. Repetiré esto porque es muy importante: ¡EN C++, LOS ÍNDICES VECTORIALES EMPIEZAN EN 0! Esta es una fuente muy común de errores al convertir funciones de R a C++.\nUtilice = para la asignación, no &lt;-.\nC++ proporciona operadores que modifican en el lugar: total += x[i] es equivalente a total = total + x[i]. Operadores in situ similares son -=, *= y /=.\n\nEste es un buen ejemplo de dónde C++ es mucho más eficiente que R. Como se muestra en el siguiente micropunto de referencia, sumC() es competitivo con el integrado (y altamente optimizado) sum(), mientras que sumR() es varios órdenes de magnitud más lento.\n\nx &lt;- runif(1e3)\nbench::mark(\n  sum(x),\n  sumC(x),\n  sumR(x)\n)[1:6]\n#&gt; # A tibble: 3 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 sum(x)       2.05µs   2.08µs   471466.        0B     0   \n#&gt; 2 sumC(x)      1.68µs   1.76µs   537120.        0B     0   \n#&gt; 3 sumR(x)     20.06µs  20.54µs    48222.      22KB     4.82\n\n\n\n25.2.4 Entrada vectorial, salida vectorial\n\nA continuación, crearemos una función que calcule la distancia euclidiana entre un valor y un vector de valores:\n\npdistR &lt;- function(x, ys) {\n  sqrt((x - ys) ^ 2)\n}\n\nEn R, no es obvio que queremos que x sea un escalar de la definición de la función, y debemos dejarlo claro en la documentación. Eso no es un problema en la versión de C++ porque tenemos que ser explícitos con los tipos:\n\ncppFunction('NumericVector pdistC(double x, NumericVector ys) {\n  int n = ys.size();\n  NumericVector out(n);\n\n  for(int i = 0; i &lt; n; ++i) {\n    out[i] = sqrt(pow(ys[i] - x, 2.0));\n  }\n  return out;\n}')\n\nEsta función introduce solo algunos conceptos nuevos:\n\nCreamos un nuevo vector numérico de longitud n con un constructor: NumericVector out(n). Otra forma útil de hacer un vector es copiar uno existente: NumericVector zs = clone(ys).\nC++ usa pow(), no ^, para la exponenciación.\n\nTenga en cuenta que debido a que la versión R está completamente vectorizada, ya será rápida.\n\ny &lt;- runif(1e6)\nbench::mark(\n  pdistR(0.5, y),\n  pdistC(0.5, y)\n)[1:6]\n#&gt; # A tibble: 2 × 6\n#&gt;   expression          min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 pdistR(0.5, y)   4.78ms   5.01ms      199.    7.63MB     103.\n#&gt; 2 pdistC(0.5, y)   3.98ms   4.04ms      247.    7.63MB     123.\n\nEn mi computadora, toma alrededor de 5 ms con un vector y de 1 millón de elementos. La función de C++ es unas 2,5 veces más rápida, ~2 ms, pero suponiendo que le haya llevado 10 minutos escribir la función de C++, necesitará ejecutarla ~200.000 veces para que valga la pena reescribirla. La razón por la que la función de C++ es más rápida es sutil y se relaciona con la administración de la memoria. La versión R necesita crear un vector intermedio de la misma longitud que y (x - ys), y asignar memoria es una operación costosa. La función de C++ evita esta sobrecarga porque usa un escalar intermedio.\n\n\n25.2.5 Usar sourceCpp\nHasta ahora, hemos usado C++ en línea con cppFunction(). Esto hace que la presentación sea más simple, pero para problemas reales, generalmente es más fácil usar archivos independientes de C++ y luego enviarlos a R usando sourceCpp(). Esto le permite aprovechar la compatibilidad con el editor de texto para archivos C++ (p. ej., resaltado de sintaxis), además de facilitar la identificación de los números de línea en los errores de compilación. \nSu archivo independiente de C++ debe tener la extensión .cpp y debe comenzar con:\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\nY para cada función que desee que esté disponible dentro de R, debe prefijarla con:\n// [[Rcpp::export]]\n\nSi está familiarizado con roxygen2, puede preguntarse cómo se relaciona esto con @export. Rcpp::export controla si una función se exporta de C++ a R; @export controla si una función se exporta desde un paquete y se pone a disposición del usuario.\n\nPuede incrustar código R en bloques de comentarios especiales de C++. Esto es realmente conveniente si desea ejecutar algún código de prueba:\n/*** R\n# This is R code\n*/\nEl código R se ejecuta con source(echo = TRUE), por lo que no es necesario que imprima la salida explícitamente.\nPara compilar el código C++, usa sourceCpp(\"ruta/al/archivo.cpp\"). Esto creará las funciones R coincidentes y las agregará a su sesión actual. Tenga en cuenta que estas funciones no se pueden guardar en un archivo .Rdata y volver a cargar en una sesión posterior; deben volver a crearse cada vez que reinicie R.\nPor ejemplo, ejecutar sourceCpp() en el siguiente archivo implementa mean en C++ y luego lo compara con mean() integrado:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble meanC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n\n  for(int i = 0; i &lt; n; ++i) {\n    total += x[i];\n  }\n  return total / n;\n}\n\n/*** R\nx &lt;- runif(1e5)\nbench::mark(\n  mean(x),\n  meanC(x)\n)\n*/\n\nNB: Si ejecuta este código, notará que meanC() es mucho más rápido que el mean() integrado. Esto se debe a que cambia la precisión numérica por la velocidad.\nEn el resto de este capítulo, el código C++ se presentará de forma independiente en lugar de envuelto en una llamada a cppFunction. Si desea intentar compilar y/o modificar los ejemplos, debe pegarlos en un archivo fuente de C++ que incluya los elementos descritos anteriormente. Esto es fácil de hacer en RMarkdown: todo lo que necesita hacer es especificar engine = \"Rcpp\".\n\n\n25.2.6 Ejercicios\n\nCon los conceptos básicos de C++ en la mano, ahora es un buen momento para practicar leyendo y escribiendo algunas funciones simples de C++. Para cada una de las siguientes funciones, lea el código y averigüe cuál es la función base R correspondiente. Es posible que aún no comprenda cada parte del código, pero debería poder descubrir los conceptos básicos de lo que hace la función.\ndouble f1(NumericVector x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i &lt; n; ++i) {\n    y += x[i] / n;\n  }\n  return y;\n}\n\nNumericVector f2(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  out[0] = x[0];\n  for(int i = 1; i &lt; n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\n\nbool f3(LogicalVector x) {\n  int n = x.size();\n\n  for(int i = 0; i &lt; n; ++i) {\n    if (x[i]) return true;\n  }\n  return false;\n}\n\nint f4(Function pred, List x) {\n  int n = x.size();\n\n  for(int i = 0; i &lt; n; ++i) {\n    LogicalVector res = pred(x[i]);\n    if (res[0]) return i + 1;\n  }\n  return 0;\n}\n\nNumericVector f5(NumericVector x, NumericVector y) {\n  int n = std::max(x.size(), y.size());\n  NumericVector x1 = rep_len(x, n);\n  NumericVector y1 = rep_len(y, n);\n\n  NumericVector out(n);\n\n  for (int i = 0; i &lt; n; ++i) {\n    out[i] = std::min(x1[i], y1[i]);\n  }\n\n  return out;\n}\nPara practicar sus habilidades de escritura de funciones, convierta las siguientes funciones a C++. Por ahora, suponga que las entradas no tienen valores faltantes.\n\nall().\ncumprod(), cummin(), cummax().\ndiff(). Start by assuming lag 1, and then generalise for lag n.\nrange().\nvar(). Lea acerca de los enfoques que puede adoptar en Wikipedia. Siempre que se implemente un algoritmo numérico, siempre es bueno verificar lo que ya se sabe sobre el problema.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#sec-rcpp-classes",
    "href": "Rcpp.html#sec-rcpp-classes",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.3 Otras clases",
    "text": "25.3 Otras clases\nYa has visto las clases vectoriales básicas (IntegerVector, NumericVector, LogicalVector, CharacterVector) y sus equivalentes escalares (int, double, bool, String). Rcpp también proporciona contenedores para todos los demás tipos de datos básicos. Los más importantes son para listas y marcos de datos, funciones y atributos, como se describe a continuación. Rcpp también proporciona clases para más tipos como Environment, DottedPair, Language, Symbol, etc., pero estos están más allá del alcance de este capítulo.\n\n25.3.1 Listas y data frames\nRcpp también proporciona las clases List y DataFrame, pero son más útiles para la salida que para la entrada. Esto se debe a que las listas y los marcos de datos pueden contener clases arbitrarias, pero C++ necesita conocer sus clases de antemano. Si la lista tiene una estructura conocida (p. ej., es un objeto de S3), puede extraer los componentes y convertirlos manualmente a sus equivalentes de C++ con as(). Por ejemplo, el objeto creado por lm(), la función que ajusta un modelo lineal, es una lista cuyos componentes son siempre del mismo tipo. El siguiente código ilustra cómo puede extraer el error porcentual medio (mpe()) de un modelo lineal. Este no es un buen ejemplo de cuándo usar C++, porque se implementa muy fácilmente en R, pero muestra cómo trabajar con una clase S3 importante. Tenga en cuenta el uso de .inherits() y stop() para verificar que el objeto realmente es un modelo lineal. \n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble mpe(List mod) {\n  if (!mod.inherits(\"lm\")) stop(\"Input must be a linear model\");\n\n  NumericVector resid = as&lt;NumericVector&gt;(mod[\"residuals\"]);\n  NumericVector fitted = as&lt;NumericVector&gt;(mod[\"fitted.values\"]);\n\n  int n = resid.size();\n  double err = 0;\n  for(int i = 0; i &lt; n; ++i) {\n    err += resid[i] / (fitted[i] + resid[i]);\n  }\n  return err / n;\n}\n\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nmpe(mod)\n#&gt; [1] -0.0154\n\n\n\n25.3.2 Funciones\n\nPuede poner funciones R en un objeto de tipo Function. Esto hace que llamar a una función R desde C++ sea sencillo. El único desafío es que no sabemos qué tipo de salida devolverá la función, por lo que usamos el tipo general RObject.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nRObject callWithOne(Function f) {\n  return f(1);\n}\n\n\ncallWithOne(function(x) x + 1)\n#&gt; [1] 2\ncallWithOne(paste)\n#&gt; [1] \"1\"\n\nLlamar funciones R con argumentos posicionales es obvio:\nf(\"y\", 1);\nPero necesita una sintaxis especial para argumentos con nombre:\nf(_[\"x\"] = \"y\", _[\"value\"] = 1);\n\n\n25.3.3 Atributos\n\nTodos los objetos R tienen atributos, que se pueden consultar y modificar con .attr(). Rcpp también proporciona .names() como un alias para el atributo de nombre. El siguiente fragmento de código ilustra estos métodos. Tenga en cuenta el uso de ::create(), un método de clase. Esto le permite crear un vector R a partir de valores escalares de C++:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector attribs() {\n  NumericVector out = NumericVector::create(1, 2, 3);\n\n  out.names() = CharacterVector::create(\"a\", \"b\", \"c\");\n  out.attr(\"my-attr\") = \"my-value\";\n  out.attr(\"class\") = \"my-class\";\n\n  return out;\n}\n\nPara los objetos S4, .slot() juega un papel similar a .attr().",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#sec-rcpp-na",
    "href": "Rcpp.html#sec-rcpp-na",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.4 Valores faltantes",
    "text": "25.4 Valores faltantes\n\nSi está trabajando con valores perdidos, necesita saber dos cosas:\n\nCómo se comportan los valores faltantes de R en los escalares de C++ (por ejemplo, doble).\nCómo obtener y establecer valores faltantes en vectores (por ejemplo, NumericVector).\n\n\n25.4.1 Escalares\nEl siguiente código explora lo que sucede cuando tomas uno de los valores faltantes de R, lo conviertes en un escalar y luego vuelves a convertirlo en un vector R. Tenga en cuenta que este tipo de experimentación es una forma útil de descubrir qué hace cualquier operación.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList scalar_missings() {\n  int int_s = NA_INTEGER;\n  String chr_s = NA_STRING;\n  bool lgl_s = NA_LOGICAL;\n  double num_s = NA_REAL;\n\n  return List::create(int_s, chr_s, lgl_s, num_s);\n}\n\n\nstr(scalar_missings())\n#&gt; List of 4\n#&gt;  $ : int NA\n#&gt;  $ : chr NA\n#&gt;  $ : logi TRUE\n#&gt;  $ : num NA\n\nCon la excepción de bool, las cosas se ven bastante bien aquí: todos los valores que faltan se han conservado. Sin embargo, como veremos en las siguientes secciones, las cosas no son tan sencillas como parecen.\n\n25.4.1.1 Enteros\nCon números enteros, los valores faltantes se almacenan como el número entero más pequeño. Si no les haces nada, se conservarán. Pero, dado que C++ no sabe que el entero más pequeño tiene este comportamiento especial, si hace algo al respecto, es probable que obtenga un valor incorrecto: por ejemplo, evalCpp('NA_INTEGER + 1') da -2147483647.\nEntonces, si desea trabajar con valores faltantes en números enteros, use un IntegerVector de longitud 1 o tenga mucho cuidado con su código.\n\n\n25.4.1.2 Dobles\nCon los dobles, es posible que pueda ignorar los valores faltantes y trabajar con NaN (no un número). Esto se debe a que el NA de R es un tipo especial de número NaN de punto flotante IEEE 754. Entonces, cualquier expresión lógica que involucre un NaN (o en C++, NAN) siempre se evalúa como FALSE:\n\nevalCpp(\"NAN == 1\")\n#&gt; [1] FALSE\nevalCpp(\"NAN &lt; 1\")\n#&gt; [1] FALSE\nevalCpp(\"NAN &gt; 1\")\n#&gt; [1] FALSE\nevalCpp(\"NAN == NAN\")\n#&gt; [1] FALSE\n\n(Aquí estoy usando evalCpp() que le permite ver el resultado de ejecutar una sola expresión de C++, lo que la hace excelente para este tipo de experimentación interactiva.)\nPero tenga cuidado al combinarlos con valores booleanos:\n\nevalCpp(\"NAN && TRUE\")\n#&gt; [1] TRUE\nevalCpp(\"NAN || FALSE\")\n#&gt; [1] TRUE\n\nSin embargo, en contextos numéricos, los NaN propagarán los NA:\n\nevalCpp(\"NAN + 1\")\n#&gt; [1] NaN\nevalCpp(\"NAN - 1\")\n#&gt; [1] NaN\nevalCpp(\"NAN / 1\")\n#&gt; [1] NaN\nevalCpp(\"NAN * 1\")\n#&gt; [1] NaN\n\n\n\n\n25.4.2 Caracteres\nString es una clase de cadena de caracteres escalar introducida por Rcpp, por lo que sabe cómo lidiar con los valores faltantes.\n\n\n25.4.3 Booleano\nMientras que bool de C++ tiene dos valores posibles (true o false), un vector lógico en R tiene tres (TRUE, FALSE y NA). Si fuerza un vector lógico de longitud 1, asegúrese de que no contenga ningún valor faltante; de lo contrario, se convertirán en VERDADERO. Una solución fácil es usar int en su lugar, ya que esto puede representar TRUE, FALSE y NA.\n\n\n25.4.4 Vectores\nCon los vectores, debe usar un valor perdido específico para el tipo de vector, NA_REAL, NA_INTEGER, NA_LOGICAL, NA_STRING:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList missing_sampler() {\n  return List::create(\n    NumericVector::create(NA_REAL),\n    IntegerVector::create(NA_INTEGER),\n    LogicalVector::create(NA_LOGICAL),\n    CharacterVector::create(NA_STRING)\n  );\n}\n\n\nstr(missing_sampler())\n#&gt; List of 4\n#&gt;  $ : num NA\n#&gt;  $ : int NA\n#&gt;  $ : logi NA\n#&gt;  $ : chr NA\n\n\n\n25.4.5 Ejercicios\n\nVuelva a escribir cualquiera de las funciones del primer ejercicio de la Sección 25.2.6 para tratar con los valores faltantes. Si na.rm es verdadero, ignore los valores faltantes. Si na.rm es falso, devuelve un valor faltante si la entrada contiene valores faltantes. Algunas buenas funciones para practicar son min(), max(), range(), mean() y var().\nVuelva a escribir cumsum() y diff() para que puedan manejar los valores faltantes. Tenga en cuenta que estas funciones tienen un comportamiento un poco más complicado.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#sec-stl",
    "href": "Rcpp.html#sec-stl",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.5 Biblioteca de plantillas estándar",
    "text": "25.5 Biblioteca de plantillas estándar\nLa verdadera fortaleza de C++ se revela cuando necesita implementar algoritmos más complejos. La biblioteca de plantillas estándar (STL) proporciona un conjunto de estructuras de datos y algoritmos extremadamente útiles. Esta sección explicará algunos de los algoritmos y estructuras de datos más importantes y le indicará la dirección correcta para obtener más información. No puedo enseñarte todo lo que necesitas saber sobre STL, pero espero que los ejemplos te muestren el poder de STL y te convenzan de que es útil aprender más. \nSi necesita un algoritmo o una estructura de datos que no esté implementado en STL, un buen lugar para buscar es boost. La instalación de boost en su computadora está más allá del alcance de este capítulo, pero una vez que lo haya instalado, puede usar las estructuras de datos y los algoritmos de boost al incluir el archivo de encabezado apropiado con (p. ej.) #include &lt;boost/array.hpp&gt;.\n\n25.5.1 Usar iteradores\nLos iteradores se utilizan mucho en STL: muchas funciones aceptan o devuelven iteradores. Son el siguiente paso de los bucles básicos, abstrayendo los detalles de la estructura de datos subyacente. Los iteradores tienen tres operadores principales: \n\nAvanza con ++.\nObtener el valor al que se refieren, o desreferenciar, con *.\nComparar con ==.\n\nPor ejemplo, podríamos reescribir nuestra función de suma usando iteradores:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum3(NumericVector x) {\n  double total = 0;\n  \n  NumericVector::iterator it;\n  for(it = x.begin(); it != x.end(); ++it) {\n    total += *it;\n  }\n  return total;\n}\n\nLos principales cambios están en el bucle for:\n\nComenzamos en x.begin() y repetimos hasta llegar a x.end(). Una pequeña optimización es almacenar el valor del iterador final para que no tengamos que buscarlo cada vez. Esto solo ahorra alrededor de 2 ns por iteración, por lo que solo es importante cuando los cálculos en el ciclo son muy simples.\nEn lugar de indexar en x, usamos el operador de desreferencia para obtener su valor actual: *it.\nObserve el tipo de iterador: NumericVector::iterator. Cada tipo de vector tiene su propio tipo de iterador: LogicalVector::iterator, CharacterVector::iterator, etc.\n\nEste código se puede simplificar aún más mediante el uso de una característica de C++11: bucles for basados en rangos. C ++ 11 está ampliamente disponible y se puede activar fácilmente para usar con Rcpp agregando [[Rcpp::plugins(cpp11)]].\n\n// [[Rcpp::plugins(cpp11)]]\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum4(NumericVector xs) {\n  double total = 0;\n  \n  for(const auto &x : xs) {\n    total += x;\n  }\n  return total;\n}\n\nLos iteradores también nos permiten usar los equivalentes de C++ de la familia de funciones apply. Por ejemplo, podríamos volver a escribir sum() para usar la función accumulate(), que toma un iterador inicial y final, y suma todos los valores en el vector. El tercer argumento para acumular da el valor inicial: es particularmente importante porque esto también determina el tipo de datos que usa acumular (así que usamos 0.0 y no 0 para que acumule use un doble, no un int.). Para usar accumulate() necesitamos incluir el encabezado &lt;numeric&gt;.\n\n#include &lt;numeric&gt;\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum5(NumericVector x) {\n  return std::accumulate(x.begin(), x.end(), 0.0);\n}\n\n\n\n25.5.2 Algoritmos\nEl encabezado &lt;algorithm&gt; proporciona una gran cantidad de algoritmos que funcionan con iteradores. Una buena referencia está disponible en https://en.cppreference.com/w/cpp/algorithm. Por ejemplo, podríamos escribir una versión básica de Rcpp de findInterval() que toma dos argumentos, un vector de valores y un vector de rupturas, y ubica el contenedor en el que cae cada x. Esto muestra algunas características más avanzadas del iterador. Lea el código a continuación y vea si puede descubrir cómo funciona. \n\n#include &lt;algorithm&gt;\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector findInterval2(NumericVector x, NumericVector breaks) {\n  IntegerVector out(x.size());\n\n  NumericVector::iterator it, pos;\n  IntegerVector::iterator out_it;\n\n  for(it = x.begin(), out_it = out.begin(); it != x.end(); \n      ++it, ++out_it) {\n    pos = std::upper_bound(breaks.begin(), breaks.end(), *it);\n    *out_it = std::distance(breaks.begin(), pos);\n  }\n\n  return out;\n}\n\nLos puntos clave son:\n\nPasamos por dos iteradores (entrada y salida) simultáneamente.\nPodemos asignar a un iterador desreferenciado (out_it) para cambiar los valores en out.\nupper_bound() devuelve un iterador. Si quisiéramos el valor de upper_bound(), podríamos quitarle la referencia; para averiguar su ubicación, usamos la función distance().\nPequeña nota: si queremos que esta función sea tan rápida como findInterval() en R (que usa código C escrito a mano), necesitamos calcular las llamadas a .begin() y .end() una vez y guardar los resultados. Esto es fácil, pero distrae la atención de este ejemplo, por lo que se ha omitido. Hacer este cambio produce una función que es un poco más rápida que la función findInterval() de R, pero es aproximadamente 1/10 del código.\n\nEn general, es mejor usar algoritmos de STL que bucles enrollados a mano. En Effective STL, Scott Meyers da tres razones: eficiencia, corrección y mantenibilidad. Los algoritmos de STL están escritos por expertos en C++ para que sean extremadamente eficientes y han existido durante mucho tiempo, por lo que están bien probados. El uso de algoritmos estándar también hace que la intención de su código sea más clara, lo que ayuda a que sea más legible y fácil de mantener.\n\n\n25.5.3 Estructuras de datos\nEl STL proporciona un gran conjunto de estructuras de datos: array, bitset, list, forward_list, map, multimap, multiset, priority_queue, queue, deque, set, stack, unordered_map, unordered_set, unordered_multimap, unordered_multiset, y vector. Las más importantes de estas estructuras de datos son el vector, el unordered_set y el unordered_map. Nos centraremos en estos tres en esta sección, pero el uso de los otros es similar: solo tienen diferentes compensaciones de rendimiento. Por ejemplo, deque (pronunciado “deck”) tiene una interfaz muy similar a los vectores pero una implementación subyacente diferente que tiene diferentes compensaciones de rendimiento. Es posible que desee probarlo para su problema. Una buena referencia para las estructuras de datos STL es https://en.cppreference.com/w/cpp/container — Le recomiendo que lo mantenga abierto mientras trabaja con STL.\nRcpp sabe cómo convertir muchas estructuras de datos STL a sus equivalentes R, por lo que puede devolverlas desde sus funciones sin convertirlas explícitamente en estructuras de datos R.\n\n\n25.5.4 Vectores\nUn vector STL es muy similar a un vector R, excepto que crece de manera eficiente. Esto hace que los vectores sean apropiados para usar cuando no se sabe de antemano qué tan grande será la salida. Los vectores tienen una plantilla, lo que significa que debe especificar el tipo de objeto que contendrá el vector cuando lo cree: vector&lt;int&gt;, vector&lt;bool&gt;, vector&lt;double&gt;, vector&lt;String&gt;. Puede acceder a elementos individuales de un vector usando la notación estándar [], y puede agregar un nuevo elemento al final del vector usando .push_back(). Si tiene una idea de antemano de qué tan grande será el vector, puede usar .reserve() para asignar suficiente almacenamiento. \nEl siguiente código implementa la codificación de longitud de ejecución (rle()). Produce dos vectores de salida: un vector de valores y un vector de “longitudes” que indica cuántas veces se repite cada elemento. Funciona recorriendo el vector de entrada x comparando cada valor con el anterior: si es el mismo, incrementa el último valor en lengths; si es diferente, agrega el valor al final de values y establece la longitud correspondiente en 1.\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList rleC(NumericVector x) {\n  std::vector&lt;int&gt; lengths;\n  std::vector&lt;double&gt; values;\n\n  // Initialise first value\n  int i = 0;\n  double prev = x[0];\n  values.push_back(prev);\n  lengths.push_back(1);\n\n  NumericVector::iterator it;\n  for(it = x.begin() + 1; it != x.end(); ++it) {\n    if (prev == *it) {\n      lengths[i]++;\n    } else {\n      values.push_back(*it);\n      lengths.push_back(1);\n\n      i++;\n      prev = *it;\n    }\n  }\n\n  return List::create(\n    _[\"lengths\"] = lengths, \n    _[\"values\"] = values\n  );\n}\n\n(Una implementación alternativa sería reemplazar i con el iterador lengths.rbegin() que siempre apunta al último elemento del vector. Es posible que desee intentar implementar eso.)\nOtros métodos de un vector se describen en https://en.cppreference.com/w/cpp/container/vector.\n\n\n25.5.5 Conjuntos\nLos conjuntos mantienen un conjunto único de valores y pueden indicar de manera eficiente si ha visto un valor antes. Son útiles para problemas que involucran duplicados o valores únicos (como unique, duplicated o in). C++ proporciona tanto conjuntos ordenados (std::set) como desordenados (std::unordered_set), dependiendo de si el orden es importante para usted o no. Los conjuntos desordenados tienden a ser mucho más rápidos (porque usan una tabla hash internamente en lugar de un árbol), por lo que incluso si necesita un conjunto ordenado, debe considerar usar un conjunto desordenado y luego ordenar la salida. Al igual que los vectores, los conjuntos tienen plantillas, por lo que debe solicitar el tipo de conjunto adecuado para su propósito: unordered_set&lt;int&gt;, unordered_set&lt;bool&gt;, etc. Hay más detalles disponibles en https://en.cppreference.com/w/cpp/container/set y https://en.cppreference.com/w/cpp/container/unordered_set. \nLa siguiente función usa un conjunto desordenado para implementar un equivalente a duplicated() para vectores enteros. Tenga en cuenta el uso de seen.insert(x[i]).second. insert() devuelve un par, el valor .first es un iterador que apunta al elemento y el valor .second es un valor booleano que es verdadero si el valor fue una nueva adición al conjunto.\n\n// [[Rcpp::plugins(cpp11)]]\n#include &lt;Rcpp.h&gt;\n#include &lt;unordered_set&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nLogicalVector duplicatedC(IntegerVector x) {\n  std::unordered_set&lt;int&gt; seen;\n  int n = x.size();\n  LogicalVector out(n);\n\n  for (int i = 0; i &lt; n; ++i) {\n    out[i] = !seen.insert(x[i]).second;\n  }\n\n  return out;\n}\n\n\n\n25.5.6 Map\n\nUn mapa es similar a un conjunto, pero en lugar de almacenar presencia o ausencia, puede almacenar datos adicionales. Es útil para funciones como table() o match() que necesitan buscar un valor. Al igual que con los conjuntos, existen versiones ordenadas (std::map) y desordenadas (std::unordered_map). Dado que los mapas tienen un valor y una clave, debe especificar ambos tipos al inicializar un mapa: mapa&lt;doble, int&gt;, mapa_desordenado&lt;int, doble&gt;, etc. El siguiente ejemplo muestra cómo podrías usar un map para implementar table() para vectores numéricos:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nstd::map&lt;double, int&gt; tableC(NumericVector x) {\n  std::map&lt;double, int&gt; counts;\n\n  int n = x.size();\n  for (int i = 0; i &lt; n; i++) {\n    counts[x[i]]++;\n  }\n\n  return counts;\n}\n\n\n\n25.5.7 Ejercicios\nPara practicar el uso de estructuras de datos y algoritmos STL, implemente lo siguiente mediante funciones R en C++, utilizando las sugerencias proporcionadas:\n\nmedian.default() usando partial_sort.\n%in% usando unordered_set y los find() o count() métodos.\nunique() usando un unordered_set (desafío: ¡hazlo en una línea!).\nmin() usando std::min(), o max() usando std::max().\nwhich.min() usando min_element, o which.max() usando max_element.\nsetdiff(), union(), y intersect() para números enteros usando rangos ordenados y set_union, set_intersection y set_difference.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#sec-rcpp-case-studies",
    "href": "Rcpp.html#sec-rcpp-case-studies",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.6 Caso de estudio",
    "text": "25.6 Caso de estudio\nLos siguientes estudios de casos ilustran algunos usos reales de C++ para reemplazar el código R lento.\n\n25.6.1 Muestreador de Gibbs\n\nEl siguiente estudio de caso actualiza un ejemplo sobre el que se escribió en un blog de Dirk Eddelbuettel, que ilustra la conversión de una muestra de Gibbs en R a C++. El código R y C++ que se muestra a continuación es muy similar (solo tomó unos minutos convertir la versión R a la versión C++), pero se ejecuta unas 20 veces más rápido en mi computadora. La publicación del blog de Dirk también muestra otra forma de hacerlo aún más rápido: usar las funciones de generador de números aleatorios más rápidas en GSL (fácilmente accesible desde R a través del paquete RcppGSL) puede hacerlo otras dos o tres veces más rápido. \nEl código R es el siguiente:\n\ngibbs_r &lt;- function(N, thin) {\n  mat &lt;- matrix(nrow = N, ncol = 2)\n  x &lt;- y &lt;- 0\n\n  for (i in 1:N) {\n    for (j in 1:thin) {\n      x &lt;- rgamma(1, 3, y * y + 4)\n      y &lt;- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))\n    }\n    mat[i, ] &lt;- c(x, y)\n  }\n  mat\n}\n\nEsto es fácil de convertir a C++. Nosotros:\n\nAgregar declaraciones de tipo a todas las variables.\nUtilice ( en lugar de [ para indexar en la matriz.\nSubíndice los resultados de rgamma y rnorm para convertir de un vector a un escalar.\n\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericMatrix gibbs_cpp(int N, int thin) {\n  NumericMatrix mat(N, 2);\n  double x = 0, y = 0;\n\n  for(int i = 0; i &lt; N; i++) {\n    for(int j = 0; j &lt; thin; j++) {\n      x = rgamma(1, 3, 1 / (y * y + 4))[0];\n      y = rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))[0];\n    }\n    mat(i, 0) = x;\n    mat(i, 1) = y;\n  }\n\n  return(mat);\n}\n\nLa evaluación comparativa de los dos rendimientos de implementación:\n\nbench::mark(\n  gibbs_r(100, 10),\n  gibbs_cpp(100, 10),\n  check = FALSE\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression              min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 gibbs_r(100, 10)     2.36ms   2.41ms      411.   107.5KB     15.1\n#&gt; 2 gibbs_cpp(100, 10) 238.09µs 254.29µs     3883.    1.61KB     14.5\n\n\n\n25.6.2 R vectorización frente a vectorización C++\n\nEste ejemplo está adaptado de “Rcpp fuma rápido para modelos basados en agentes en marcos de datos”. El desafío es predecir la respuesta de un modelo a partir de tres entradas. La versión básica de R del predictor se ve así:\n\nvacc1a &lt;- function(age, female, ily) {\n  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily\n  p &lt;- p * if (female) 1.25 else 0.75\n  p &lt;- max(0, p)\n  p &lt;- min(1, p)\n  p\n}\n\nQueremos poder aplicar esta función a muchas entradas, por lo que podríamos escribir una versión de entrada vectorial usando un bucle for.\n\nvacc1 &lt;- function(age, female, ily) {\n  n &lt;- length(age)\n  out &lt;- numeric(n)\n  for (i in seq_len(n)) {\n    out[i] &lt;- vacc1a(age[i], female[i], ily[i])\n  }\n  out\n}\n\nSi está familiarizado con R, tendrá el presentimiento de que esto será lento, y de hecho lo es. Hay dos formas en las que podemos atacar este problema. Si tiene un buen vocabulario de R, puede ver inmediatamente cómo vectorizar la función (usando ifelse(), pmin() y pmax()). Alternativamente, podríamos reescribir vacc1a() y vacc1() en C++, utilizando nuestro conocimiento de que los bucles y las llamadas a funciones tienen una sobrecarga mucho menor en C++.\nCualquiera de los dos enfoques es bastante sencillo. En R:\n\nvacc2 &lt;- function(age, female, ily) {\n  p &lt;- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily\n  p &lt;- p * ifelse(female, 1.25, 0.75)\n  p &lt;- pmax(0, p)\n  p &lt;- pmin(1, p)\n  p\n}\n\n(Si ha trabajado mucho con R, es posible que reconozca algunos cuellos de botella potenciales en este código: se sabe que ifelse, pmin y pmax son lentos y podrían reemplazarse con p * 0.75 + p * 0.5 * mujer, p[p &lt; 0] &lt;- 0, p[p &gt; 1] &lt;- 1. Es posible que desee intentar cronometrar esas variaciones.)\nO en C++:\n\n#include &lt;Rcpp.h&gt;\nusing namespace Rcpp;\n\ndouble vacc3a(double age, bool female, bool ily){\n  double p = 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily;\n  p = p * (female ? 1.25 : 0.75);\n  p = std::max(p, 0.0);\n  p = std::min(p, 1.0);\n  return p;\n}\n\n// [[Rcpp::export]]\nNumericVector vacc3(NumericVector age, LogicalVector female, \n                    LogicalVector ily) {\n  int n = age.size();\n  NumericVector out(n);\n\n  for(int i = 0; i &lt; n; ++i) {\n    out[i] = vacc3a(age[i], female[i], ily[i]);\n  }\n\n  return out;\n}\n\nA continuación, generamos algunos datos de muestra y verificamos que las tres versiones devuelvan los mismos valores:\n\nn &lt;- 1000\nage &lt;- rnorm(n, mean = 50, sd = 10)\nfemale &lt;- sample(c(T, F), n, rep = TRUE)\nily &lt;- sample(c(T, F), n, prob = c(0.8, 0.2), rep = TRUE)\n\nstopifnot(\n  all.equal(vacc1(age, female, ily), vacc2(age, female, ily)),\n  all.equal(vacc1(age, female, ily), vacc3(age, female, ily))\n)\n\nLa publicación del blog original olvidó hacer esto e introdujo un error en la versión C++: usaba 0.004 en lugar de 0.04. Finalmente, podemos comparar nuestros tres enfoques:\n\nbench::mark(\n  vacc1 = vacc1(age, female, ily),\n  vacc2 = vacc2(age, female, ily),\n  vacc3 = vacc3(age, female, ily)\n)\n#&gt; # A tibble: 3 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 vacc1        1.49ms   1.54ms      600.    7.86KB     19.5\n#&gt; 2 vacc2       41.81µs   43.5µs    21846.  148.56KB     45.0\n#&gt; 3 vacc3       11.35µs  11.62µs    85187.   14.48KB     17.0\n\nNo es sorprendente que nuestro enfoque original con bucles sea muy lento. La vectorización en R proporciona una gran aceleración, y podemos obtener aún más rendimiento (unas diez veces) con el ciclo de C++. Me sorprendió un poco que C++ fuera mucho más rápido, pero se debe a que la versión R tiene que crear 11 vectores para almacenar resultados intermedios, mientras que el código C++ solo necesita crear 1.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#sec-rcpp-package",
    "href": "Rcpp.html#sec-rcpp-package",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.7 Using Rcpp in a package",
    "text": "25.7 Using Rcpp in a package\nEl mismo código C++ que se usa con sourceCpp() también se puede agrupar en un paquete. Hay varios beneficios de mover el código de un archivo fuente de C++ independiente a un paquete: \n\nSu código puede estar disponible para los usuarios sin las herramientas de desarrollo de C++.\nEl sistema de compilación de paquetes R gestiona automáticamente varios archivos de origen y sus dependencias.\nLos paquetes brindan infraestructura adicional para pruebas, documentación y consistencia.\n\nPara agregar Rcpp a un paquete existente, coloque sus archivos C++ en el directorio src/ y cree o modifique los siguientes archivos de configuración:\n\nEn DESCRIPTION añade\nLinkingTo: Rcpp\nImports: Rcpp\nAsegúrese de que su NAMESPACE incluye:\nuseDynLib(mypackage)\nimportFrom(Rcpp, sourceCpp)\nNecesitamos importar algo (cualquier cosa) de Rcpp para que el código interno de Rcpp se cargue correctamente. Este es un error en R y, con suerte, se solucionará en el futuro.\n\nLa forma más fácil de configurar esto automáticamente es llamar a usethis::use_rcpp().\nAntes de compilar el paquete, deberá ejecutar Rcpp::compileAttributes(). Esta función escanea los archivos C++ en busca de atributos Rcpp::export y genera el código necesario para que las funciones estén disponibles en R. Vuelva a ejecutar compileAttributes() cada vez que se agreguen, eliminen o cambien sus firmas. Esto lo hace automáticamente el paquete devtools y Rstudio.\nPara obtener más detalles, consulte la viñeta del paquete Rcpp, vignette(\"Rcpp-package\").",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#sec-rcpp-more",
    "href": "Rcpp.html#sec-rcpp-more",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.8 Aprendiendo más",
    "text": "25.8 Aprendiendo más\nEste capítulo solo ha tocado una pequeña parte de Rcpp, brindándole las herramientas básicas para reescribir código R de bajo rendimiento en C++. Como se señaló, Rcpp tiene muchas otras capacidades que facilitan la interfaz de R con el código C++ existente, que incluyen:\n\nCaracterísticas adicionales de los atributos, incluida la especificación de argumentos predeterminados, la vinculación en dependencias externas de C++ y la exportación de interfaces de C++ desde paquetes. Estas características y más están cubiertas en la viñeta de atributos de Rcpp, vignette(\"Rcpp-attributes\").\nCreación automática de contenedores entre estructuras de datos de C++ y estructuras de datos de R, incluida la asignación de clases de C++ a clases de referencia. Una buena introducción a este tema es la viñeta de módulos Rcpp, vignette(\"Rcpp-modules\").\nLa guía de referencia rápida de Rcpp, vignette(\"Rcpp-quickref\"), contiene un resumen útil de las clases de Rcpp y lenguajes de programación comunes.\n\nRecomiendo encarecidamente estar atento a la página de inicio de Rcpp y registrarse en la lista de correo de Rcpp.\nOtros recursos que he encontrado útiles para aprender C++ son:\n\nEffective C++ (Meyers 2005) y Effective STL (Meyers 2001).\nC++ Annotations, dirigido a usuarios expertos en C (o cualquier otro lenguaje que use una gramática similar a C, como Perl o Java) que deseen saber más sobre C++ o hacer la transición a C++.\nAlgorithm Libraries, que proporciona una descripción más técnica, pero aún concisa, de conceptos importantes de STL. (Siga los enlaces debajo de las notas).\n\nEscribir código de rendimiento también puede requerir que reconsidere su enfoque básico: una sólida comprensión de las estructuras de datos y los algoritmos básicos es muy útil aquí. Eso está más allá del alcance de este libro, pero sugeriría el Manual de diseño de algoritmos (Skiena 1998), Introducción a los algoritmos del MIT, Algorithms de Robert Sedgewick y Kevin Wayne, que tiene un libro de texto en línea gratuito y un [curso de Coursera] correspondiente (https://www.coursera.org/learn/algorithms-part1).",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "Rcpp.html#reconocimientos",
    "href": "Rcpp.html#reconocimientos",
    "title": "25  Reescribiendo código de R en C++",
    "section": "25.9 Reconocimientos",
    "text": "25.9 Reconocimientos\nMe gustaría agradecer a la lista de correo de Rcpp por muchas conversaciones útiles, en particular a Romain Francois y Dirk Eddelbuettel, quienes no solo han brindado respuestas detalladas a muchas de mis preguntas, sino que también han sido increíblemente receptivos para mejorar Rcpp. Este capítulo no hubiera sido posible sin JJ Allaire; me animó a aprender C++ y luego respondió muchas de mis preguntas tontas en el camino.\n\n\n\n\nEddelbuettel, Dirk, y Romain François. 2011. «Rcpp: Seamless R and C++ Integration». Journal of Statistical Software 40 (8): 1-18. https://doi.org/10.18637/jss.v040.i08.\n\n\nMeyers, Scott. 2001. Effective STL: 50 specific ways to improve your use of the standard template library. Pearson Education. http://amzn.com/0201749629.\n\n\n———. 2005. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education. http://amzn.com/0321334876.\n\n\nSkiena, Steven S. 1998. The Algorithm Design Manual. Springer. http://amzn.com/0387948600.",
    "crumbs": [
      "Tecnicas",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Reescribiendo código de R en C++</span>"
    ]
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "Referencias",
    "section": "",
    "text": "Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996.\nStructure and Interpretation of Computer Programs. MIT Press.\n\n\nBache, Stefan Milton, and Hadley Wickham. 2014. Magrittr: A\nForward-Pipe Operator for R. http://magrittr.tidyverse.org/.\n\n\nBalamuta, James. 2018a. Errorist: Automatically Search Errors or\nWarnings. https://github.com/coatless/errorist.\n\n\n———. 2018b. Searcher: Query Search Interfaces. https://github.com/coatless/searcher.\n\n\nBates, Douglas, and Martin Maechler. 2018. “Matrix: Sparse and\nDense Matrix Classes and Methods.” https://CRAN.R-project.org/package=Matrix.\n\n\nBawden, Alan. 1999. “Quasiquotation in Lisp.”\nIn PEPM ’99, 4–12. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.309.227.\n\n\nBengtsson, Henrik. 2003. “The R.oo\nPackage - Object-Oriented Programming with References Using Standard\nR Code.” In Proceedings of the 3rd International\nWorkshop on Distributed Statistical Computing (DSC 2003), edited by\nKurt Hornik, Friedrich Leisch, and Achim Zeileis. Vienna, Austria:\nhttps://www.r-project.org/conferences/DSC-2003/Proceedings/. https://www.r-project.org/conferences/DSC-2003/Proceedings/Bengtsson.pdf.\n\n\nBrown, Christopher. 2013. Hash: Full Feature Implementation of\nHash/Associated Arrays/Dictionaries. https://CRAN.R-project.org/package=hash.\n\n\nBueno, Carlos. 2013. Mature Optimization Handbook. http://carlos.bueno.org/optimization/.\n\n\nChambers, John M. 1998. Programming with Data: A Guide to the s\nLanguage. Springer.\n\n\n———. 2008. Software for Data Analysis: Programming with\nR. Springer.\n\n\n———. 2014. “Object-Oriented Programming, Functional Programming\nand R.” Statistical Science 29 (2): 167–80.\nhttps://projecteuclid.org/download/pdfview_1/euclid.ss/1408368569.\n\n\n———. 2016. Extending R. CRC Press.\n\n\nChambers, John M, and Trevor J Hastie. 1992. Statistical Models in\nS. Wadsworth & Brooks/Cole Advanced Books &\nSoftware.\n\n\nChang, Winston. 2017. R6: Classes with Reference Semantics. https://r6.r-lib.org.\n\n\nEddelbuettel, Dirk, and Romain François. 2011. “Rcpp:\nSeamless R and C++ Integration.”\nJournal of Statistical Software 40 (8): 1–18. https://doi.org/10.18637/jss.v040.i08.\n\n\nFowler, Martin. 2010. Domain-Specific Languages. Pearson\nEducation. http://amzn.com/0321712943.\n\n\nGrolemund, Garrett, and Hadley Wickham. 2011. “Dates and Times\nMade Easy with lubridate.”\nJournal of Statistical Software 40 (3): 1–25. http://www.jstatsoft.org/v40/i03/.\n\n\nGrothendieck, Gabor, Louis Kates, and Thomas Petzoldt. 2016. Proto:\nPrototype Object-Based Programming. https://CRAN.R-project.org/package=proto.\n\n\nHenry, Lionel, and Hadley Wickham. 2018a. Purrr: Functional\nProgramming Tools. https://purrr.tidyverse.org.\n\n\n———. 2018b. Rlang: Tools for Low-Level R\nProgramming. https://rlang.r-lib.org.\n\n\nHester, Jim. 2018. Bench: High Precision Timing of R\nExpressions. http://bench.r-lib.org/.\n\n\nHester, Jim, Kirill Müller, Kevin Ushey, Hadley Wickham, and Winston\nChang. 2018. Withr: Run Code with Temporarily Modified Global\nState. http://withr.r-lib.org.\n\n\nHunt, Andrew, and David Thomas. 1990. The Pragmatic Programmer.\nAddison Wesley.\n\n\nLumley, Thomas. 2001. “Programmer’s Niche: Macros in\nR.” R News 1 (3): 11–13. https://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf.\n\n\nMatloff, Norman. 2011. The Art of R Programming.\nNo Starch Press.\n\n\n———. 2015. Parallel Computing for Data Science. Chapman &\nHall/CRC. http://amzn.com/1466587016.\n\n\nMcCallum, Q. Ethan, and Steve Weston. 2011. Parallel\nR. O’Reilly. http://amzn.com/B005Z29QT4.\n\n\nMeyers, Scott. 2001. Effective STL: 50 Specific Ways to\nImprove Your Use of the Standard Template Library. Pearson\nEducation. http://amzn.com/0201749629.\n\n\n———. 2005. Effective C++: 55 Specific Ways to Improve\nYour Programs and Designs. Pearson Education. http://amzn.com/0321334876.\n\n\nMorandat, Floréal, Brandon Hill, Leo Osvald, and Jan Vitek. 2012.\n“Evaluating the Design of the R Language.” In\nEuropean Conference on Object-Oriented Programming, 104–31.\nSpringer. http://r.cs.purdue.edu/pub/ecoop12.pdf.\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive\nPretty Printing of R Code. http://styler.r-lib.org.\n\n\nMüller, Kirill, and Hadley Wickham. 2018. Tibble: Simple Data\nFrames. http://tibble.tidyverse.org/.\n\n\nR Core Team. 2018a. “R Internals.” R Foundation for\nStatistical Computing. https://cran.r-project.org/doc/manuals/r-devel/R-ints.html.\n\n\n———. 2018b. “Writing R Extensions.” R\nFoundation for Statistical Computing. https://cran.r-project.org/doc/manuals/r-devel/R-exts.html.\n\n\nSkiena, Steven S. 1998. The Algorithm Design Manual. Springer.\nhttp://amzn.com/0387948600.\n\n\nTeetor, Nathan. 2018. Zeallot: Multiple, Unpacking, and\nDestructuring Assignment. https://CRAN.R-project.org/package=zeallot.\n\n\nTierney, Luke, and Riad Jarjour. 2016. Proftools: Profile Output\nProcessing Tools for R. https://CRAN.R-project.org/package=proftools.\n\n\nVan-Roy, Peter, and Seif Haridi. 2004. Concepts, Techniques, and\nModels of Computer Programming. MIT press.\n\n\nWickham, Hadley. 2011. “Mutatr: Mutable Objects for\nR.” Computational Statistics 26 (3):\n405--418. https://doi.org/10.1007/s00180-011-0235-7.\n\n\n———. 2018. Forcats: Tools for Working with Categorical\nVariables. http://forcats.tidyverse.org.\n\n\nWickham, Hadley, Jim Hester, Kirill Müller, and Daniel Cook. 2018.\nMemoise: Memoisation of Functions. https://github.com/r-lib/memoise.\n\n\nWickham, Hadley, and Yihui Xie. 2018. Evaluate: Parsing and\nEvaluation Tools That Provide More Details Than the Default. https://github.com/r-lib/evaluate.",
    "crumbs": [
      "Referencias"
    ]
  }
]